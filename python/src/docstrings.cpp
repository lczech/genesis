/**
* @brief Documentation strings for the Python module.
 *
 * @file
 * @ingroup python
 */

#include <src/common.hpp>

#include <map>
#include <string>

static std::map<std::string, std::string> doc_strings_ = {
    // Class EpcaData

    // Class JplaceReader
    {"static bool ::genesis::placement::JplaceReader::check_version (size_t version)", "Checks whether the version of the jplace format works with this parser.\n\nThis parser is intended for jplace versions 2 and 3. If while reading a different version tag is found, the reader will trigger a warning and try to continue anyway."},
    {"static bool ::genesis::placement::JplaceReader::check_version (std::string const & version)", "Checks whether the version of the jplace format works with this parser.\n\nThis parser is intended for jplace versions 2 and 3. If while reading a different version tag is found, the reader will trigger a warning and try to continue anyway."},
    {"Sample ::genesis::placement::JplaceReader::from_document (utils::JsonDocument & doc) const", "Take a JsonDocument and parse it as a Jplace document into a Sample."},
    {"Sample ::genesis::placement::JplaceReader::from_file (std::string const & fn) const", "Read a file and parse it as a Jplace document into a Sample."},
    {"SampleSet ::genesis::placement::JplaceReader::from_files (std::vector< std::string > const & fns) const", "Read a list of files and parse them as a Jplace document into a SampleSet."},
    {"void ::genesis::placement::JplaceReader::from_files (std::vector< std::string > const & fns, SampleSet & set) const", "Read a list of files and parse them as a Jplace document into a SampleSet.\n\nThe Samples are added to the SampleSet, so that existing Samples in the SampleSet are kept."},
    {"Sample ::genesis::placement::JplaceReader::from_stream (std::istream & is) const", "Read jplace data from a stream into a Sample."},
    {"Sample ::genesis::placement::JplaceReader::from_string (std::string const & jplace) const", "Parse a string as a Jplace document into a Sample."},
    {"SampleSet ::genesis::placement::JplaceReader::from_strings (std::vector< std::string > const & jps) const", "Parse a list of strings as a Jplace document into a SampleSet."},
    {"void ::genesis::placement::JplaceReader::from_strings (std::vector< std::string > const & jps, SampleSet & set) const", "Parse a list of strings as a Jplace document into a SampleSet.\n\nThe Samples are added to the SampleSet, so that existing Samples in the SampleSet are kept."},
    {"InvalidNumberBehaviour ::genesis::placement::JplaceReader::invalid_number_behaviour () const", "Return the currenlty set InvalidNumberBehaviour."},
    {"JplaceReader & ::genesis::placement::JplaceReader::invalid_number_behaviour (InvalidNumberBehaviour val)", "Set the InvalidNumberBehaviour.\n\nThis setter controls the InvalidNumberBehaviour of the JplaceReader. The default value is InvalidNumberBehaviour::kIgnore. See InvalidNumberBehaviour for the valid options.The function returns the JplaceReader object to allow for a fluent interface."},
    {"static std::string ::genesis::placement::JplaceReader::version ()", "Returns the version number that this class is written for. Currently, this is \"3\"."},

    // Class JplaceWriter
    {"size_t ::genesis::placement::JplaceWriter::branch_length_precision () const", "Get the precision used for printing the branch_length floating point numbers of the reference Tree of the Sample."},
    {"JplaceWriter & ::genesis::placement::JplaceWriter::branch_length_precision (size_t value)", "Set the precision used for printing the branch_length floating point numbers of the reference Tree of the Sample."},
    {"void ::genesis::placement::JplaceWriter::to_document (Sample const & smp, utils::JsonDocument & doc) const", "Store the data of a Sample in a JsonDocument object.\n\nThis method is not really useful anymore, as we can now directly write to files, strings and streams. It is however kept here for reference and in case someone wants to work with Json files directly."},
    {"void ::genesis::placement::JplaceWriter::to_file (Sample const & smp, std::string const & filename) const", "Write the data of a Sample to a file in Jplace format.\n\nIf the file cannot be written to, the function throws an exception. Also, by default, if the file already exists, an exception is thrown. See Options::allow_file_overwriting() to change this behaviour."},
    {"void ::genesis::placement::JplaceWriter::to_stream (Sample const & smp, std::ostream & os) const", "Write a Sample to a stream, using the Jplace format."},
    {"void ::genesis::placement::JplaceWriter::to_string (Sample const & smp, std::string & output) const", "Store the data of a Sample in a string in Jplace format."},
    {"std::string ::genesis::placement::JplaceWriter::to_string (Sample const & smp) const", "Return the data of a Sample as a string in Jplace format."},

    // Class NodeDistanceHistogram

    // Class NodeDistanceHistogramSet

    // Class PlacementEdgeData
    {"std::unique_ptr< BaseEdgeData > ::genesis::placement::PlacementEdgeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},
    {"int ::genesis::placement::PlacementEdgeData::edge_num () const", "Return the edge_num of this edge. This value is defined by the jplace standard."},
    {"std::unique_ptr< BaseEdgeData > ::genesis::placement::PlacementEdgeData::recreate () const", "Polymorphically create a default-constructed instance of this class with the same derived type as it was called on."},
    {"void ::genesis::placement::PlacementEdgeData::reset_edge_num (int val)", "Force to set the edge_num to a certain value.\n\nThe edge_num is usually considered to be constant for the tree. It rarely needs to be set, except for when constructing the object. Use with care."},

    // Class PlacementNodeData
    {"std::unique_ptr< BaseNodeData > ::genesis::placement::PlacementNodeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},
    {"std::unique_ptr< BaseNodeData > ::genesis::placement::PlacementNodeData::recreate () const", "Polymorphically create a default-constructed instance of this class with the same derived type as it was called on."},

    // Class PlacementTreeNewickReader

    // Class PlacementTreeNewickReaderPlugin

    // Class PlacementTreeNewickWriter

    // Class PlacementTreeNewickWriterPlugin

    // Class Pquery
    {"PqueryName & ::genesis::placement::Pquery::add_name (std::string name=\"\", double multiplicity=1.0)", "Create a new PqueryName using the provided parameters, add it to the Pquery and return it.\n\nAs this function might reallocate the memory where names are stored, all iterators and pointer to PqueryNamess are considered to be invalidated."},
    {"PqueryName & ::genesis::placement::Pquery::add_name (PqueryName const & other)", "Create a new PqueryName as a copy of the provided one, add it to the Pquery and return it.\n\nAs this function might reallocate the memory where names are stored, all iterators and pointer to PqueryNamess are considered to be invalidated."},
    {"PqueryPlacement & ::genesis::placement::Pquery::add_placement (PlacementTreeEdge & edge)", "Create a new PqueryPlacement at a given PlacementTreeEdge, add it to the Pquery and return it.\n\nThe values of the placement can then be adjusted using the returned object reference.It is important that the provided edge belongs to the same PlacementTree as the Pquery and its containing Sample do. This is up to the user and not checked.As this function might reallocate the memory where placements are stored, all iterators and pointer to PqueryPlacements are invalidated."},
    {"PqueryPlacement & ::genesis::placement::Pquery::add_placement (PqueryPlacement const & val)", "Create a new PqueryPlacement as a copy of the provided one, add it to the Pquery and return it.\n\nAs this function might reallocate the memory where placements are stored, all iterators and pointer to PqueryPlacements are considered to be invalidated."},
    {"PqueryPlacement & ::genesis::placement::Pquery::add_placement (PlacementTreeEdge & edge, PqueryPlacement const & val)", "Create a new PqueryPlacement at a given PlacementTreeEdge, add it to the Pquery and return it. The property values of the provided PqueryPlacement are copied.\n\nIt is important that the provided edge belongs to the same PlacementTree as the Pquery and its containing Sample do. This is up to the user and not checked.As this function might reallocate the memory where placements are stored, all iterators and pointer to PqueryPlacements are considered to be invalidated."},
    {"void ::genesis::placement::Pquery::clear ()", "Clear all data stored in this Pquery, i.e., clear all PqueryNames and all PqueryPlacements."},
    {"void ::genesis::placement::Pquery::clear_names ()", "Delete all PqueryNames of this Pquery."},
    {"void ::genesis::placement::Pquery::clear_placements ()", "Delete all PqueryPlacements of this Pquery."},
    {"PqueryName & ::genesis::placement::Pquery::name_at (size_t index)", "Return the PqueryName at a certain index.\n\nThe index must be smaller than name_size(), otherwise this functions throws an exception."},
    {"PqueryName const & ::genesis::placement::Pquery::name_at (size_t index) const", "Return the PqueryName at a certain index.\n\nThe index must be smaller than name_size(), otherwise this functions throws an exception."},
    {"size_t ::genesis::placement::Pquery::name_size () const", "Return the number of PqueryNames stored in this Pquery."},
    {"utils::Range< iterator_names > ::genesis::placement::Pquery::names ()", "Return a Range iterator to the PqueryNames.\n\nThis makes iterating placements via a range based for loop easy."},
    {"utils::Range< const_iterator_names > ::genesis::placement::Pquery::names () const", "Return a const Range iterator to the PqueryNames.\n\nThis makes iterating placements via a range based for loop easy."},
    {"PqueryPlacement & ::genesis::placement::Pquery::placement_at (size_t index)", "Return the PqueryPlacement at a certain index.\n\nThe index must be smaller than placement_size(), otherwise this functions throws an exception."},
    {"PqueryPlacement const & ::genesis::placement::Pquery::placement_at (size_t index) const", "Return the PqueryPlacement at a certain index.\n\nThe index must be smaller than placement_size(), otherwise this functions throws an exception."},
    {"size_t ::genesis::placement::Pquery::placement_size () const", "Return the number of PqueryPlacements stored in this Pquery."},
    {"utils::Range< iterator_placements > ::genesis::placement::Pquery::placements ()", "Return a Range iterator to the PqueryPlacements.\n\nThis makes iterating placements via a range based for loop easy."},
    {"utils::Range< const_iterator_placements > ::genesis::placement::Pquery::placements () const", "Return a const Range iterator to the PqueryPlacements.\n\nThis makes iterating placements via a range based for loop easy."},
    {"void ::genesis::placement::Pquery::remove_name_at (size_t index)", "Remove the PqueryName at a certain index position within this Pquery.\n\nAs this function moves names in the container, all iterators and pointer to PqueryNamess are considered to be invalidated."},
    {"void ::genesis::placement::Pquery::remove_placement_at (size_t index)", "Remove the PqueryPlacement at a certain index position within this Pquery.\n\nAs this function moves placements in the container, all iterators and pointer to PqueryPlacements are considered to be invalidated."},

    // Class PqueryName

    // Class PqueryPlacement
    {"const PlacementTreeEdge & ::genesis::placement::PqueryPlacement::edge () const", "Get the PlacementTreeEdge where this PqueryPlacement is placed."},
    {"PlacementTreeEdge & ::genesis::placement::PqueryPlacement::edge ()", "Get the PlacementTreeEdge where this PqueryPlacement is placed."},
    {"int ::genesis::placement::PqueryPlacement::edge_num () const", "Get the edge_num where this PqueryPlacement is placed.\n\nThis number corresponds to the edge_num property as described in the jplace standard. It is not to be confused with the index of the PlacementTreeEdge."},
    {"void ::genesis::placement::PqueryPlacement::reset_edge (PlacementTreeEdge & edge)", "Set the PlacementTreeEdge at which this PqueryPlacement is placed.\n\nThis should be rarely needed. It is mostly intended for the Readers that populate the data. When setting this value, the user is responsible to make sure that the new value is actually a PlacementTreeEdge of the PlacementTree that belongs to the Sample where the Pquery of this PqueryPlacement is stored."},

    // Class PqueryPlacementPlain

    // Class PqueryPlain

    // Class Sample
    {"Pquery & ::genesis::placement::Sample::add ()", "Create an empty Pquery, add it to the Sample and return it.\n\nThe returned reference can then be used to add PqueryPlacements and PqueryNames to the Pquery.As this function might reallocate the memory where Pqueries are stored, all iterators and pointers to the Pqueries of this Sample are invalidated."},
    {"Pquery & ::genesis::placement::Sample::add (Pquery const & other)", "Create a Pquery as a copy of the provided one, add it to the sample and return it.\n\nIt is possible to provide a Pquery from a different Sample, as long as the tree topology of both Samples is identical, including identical edge indices  and edge_nums. For that purpose, this function automatically adjusts the internal pointers of the Pquery and its PqueryPlacements accordingly. Furthermore, the proximal_length is also adjusted so that the relative position on the edge maintained.However, if the trees are incompatible (i.e., have a different topology, indices or edge nums), the PqueryPlacements will either point to different edges or the function might throw an exception, in cases where the tree does not have a corresponding edge at all. To further ensure correct behaviour, the function also checks whether the edge_num  is the same for the edge of the original PqueryPlacement and the new one, and throws an std::runtime_error if not.As this function might reallocate the memory where Pqueries are stored, all iterators and pointers to the Pqueries of this Sample are invalidated."},
    {"Pquery & ::genesis::placement::Sample::at (size_t index)", "Return the Pquery at a certain index."},
    {"Pquery const & ::genesis::placement::Sample::at (size_t index) const", "Return the Pquery at a certain index."},
    {"void ::genesis::placement::Sample::clear ()", "Clears all data of this object.\n\nThe Pqueries , the PlacementTree and the metadata are deleted."},
    {"void ::genesis::placement::Sample::clear_pqueries ()", "Clear all Pqueries  of this Sample.\n\nAll Pqueries are deleted. However, the PlacementTree and the metadata are left as they are. Thus this is a useful method for e.g., simulating placements: Take a copy of a given sample, clear its Pqueries, then generate new ones using the Simulator."},
    {"bool ::genesis::placement::Sample::empty () const", "Return whether the tree or the set of Pqueries is empty."},
    {"utils::Range< iterator_pqueries > ::genesis::placement::Sample::pqueries ()", "Return a Range iterator to the Pqueries .\n\nThis makes iterating Pqueries via a range based for loop easy."},
    {"utils::Range< const_iterator_pqueries > ::genesis::placement::Sample::pqueries () const", "Return a const Range iterator to the Pqueries .\n\nThis makes iterating Pqueries via a range based for loop easy."},
    {"void ::genesis::placement::Sample::remove (size_t index)", "Remove the Pquery at a given index from the Sample.\n\nAs this function might reallocate the memory where Pqueries are stored, all iterators and pointer to the Pqueries of this Sample are invalidated."},
    {"void ::genesis::placement::Sample::remove (size_t first_index, size_t last_index)", "Remove the Pqueries  between the first_index (inclusive) and the last_index (exclusive) from the Sample."},
    {"void ::genesis::placement::Sample::remove (iterator_pqueries position)", "Remove the Pquery at a given iterator position from the Sample."},
    {"void ::genesis::placement::Sample::remove (iterator_pqueries first, iterator_pqueries last)", "Remove the Pqueries  between the first (inclusive) and the last (exclusive) iterator position from the Sample."},
    {"size_t ::genesis::placement::Sample::size () const", "Return the number of Pqueries  that are stored in this Sample."},
    {"void ::genesis::placement::Sample::swap (Sample & other)", "Swap the contents of this Sample with the contents of another Sample."},
    {"PlacementTree & ::genesis::placement::Sample::tree ()", "Get the PlacementTree of this Sample."},
    {"PlacementTree const & ::genesis::placement::Sample::tree () const", "Get the PlacementTree of this Sample."},

    // Class SampleSerializer
    {"static Sample ::genesis::placement::SampleSerializer::load (std::string const & file_name)", "Loads a Sample from a binary file that was written by using save()."},
    {"static void ::genesis::placement::SampleSerializer::save (Sample const & map, std::string const & file_name)", "Saves the Sample to a binary file that can later be read by using load()."},

    // Class SampleSet
    {"void ::genesis::placement::SampleSet::add (Sample const & smp)", "Add a Sample to the SampleSet.\n\nThe Sample is copied. The name is set to empty string."},
    {"void ::genesis::placement::SampleSet::add (Sample const & smp, std::string const & name)", "Add a Sample with a name to the SampleSet.\n\nThe Sample is copied."},
    {"void ::genesis::placement::SampleSet::add (Sample && smp)", "Add a Sample to the SampleSet.\n\nThe Sample is moved. The name is set to empty string."},
    {"void ::genesis::placement::SampleSet::add (Sample && smp, std::string const & name)", "Add a Sample with a name to the SampleSet.\n\nThe Sample is moved."},
    {"NamedSample & ::genesis::placement::SampleSet::at (size_t index)", "Get the NamedSample at a certain index position."},
    {"NamedSample const & ::genesis::placement::SampleSet::at (size_t index) const", "Get the NamedSample at a certain index position."},
    {"void ::genesis::placement::SampleSet::clear ()", "Delete all Samples in this SampleSet."},
    {"bool ::genesis::placement::SampleSet::empty () const", "Return whether the SampleSet is empty."},
    {"void ::genesis::placement::SampleSet::remove_at (size_t index)", "Remove the Sample at a certain index position.\n\nAs this function moves Samples in the container around, all iterators and pointers to the elements of this SampleSet are considered to be invalidated."},
    {"size_t ::genesis::placement::SampleSet::size () const", "Return the size of the SampleSet, i.e., the number of Samples."},

    // Class Simulator
    {"void ::genesis::placement::Simulator::generate (Sample & sample, size_t n)", "Generate n many Pqueries and place them in the Sample."},

    // Class SimulatorEdgeDistribution
    {"size_t ::genesis::placement::SimulatorEdgeDistribution::generate ()", "Return a randomly chosen edge index, according to the distribution."},
    {"void ::genesis::placement::SimulatorEdgeDistribution::prepare (Sample const & sample)", "Prepare the distribution for usage. Needs to be called before generate()."},

    // Class SimulatorExtraPlacementDistribution
    {"void ::genesis::placement::SimulatorExtraPlacementDistribution::prepare (Sample const & sample)", "Prepare the distribution for usage. Needs to be called before generate().\n\nIt expects to be called with the Sample into which the generated (simulated) placements are inserted."},

    // Class SimulatorLikeWeightRatioDistribution
    {"double ::genesis::placement::SimulatorLikeWeightRatioDistribution::generate ()", "Return a randomly chosen like weight ratio."},
    {"void ::genesis::placement::SimulatorLikeWeightRatioDistribution::prepare (Sample const & sample)", "Prepare the distribution for usage. Needs to be called before generate()."},

    // Class SimulatorPendantLengthDistribution
    {"double ::genesis::placement::SimulatorPendantLengthDistribution::generate (PlacementTreeEdge const & edge)", "Return a randomly chosen position on an edge."},
    {"void ::genesis::placement::SimulatorPendantLengthDistribution::prepare (Sample const & sample)", "Prepare the distribution for usage. Needs to be called before generate()."},

    // Class SimulatorProximalLengthDistribution
    {"double ::genesis::placement::SimulatorProximalLengthDistribution::generate (PlacementTreeEdge const & edge)", "Return a randomly chosen position on an edge."},
    {"void ::genesis::placement::SimulatorProximalLengthDistribution::prepare (Sample const & sample)", "Prepare the distribution for usage. Needs to be called before generate()."},

    // Class NamedSample

    // Class EdgeProximity

    // Class FastaInputIterator
    {"self_type & ::genesis::sequence::FastaInputIterator::from_file (std::string const & file_name)", "Start reading from an input string.\n\nThis reads the first Sequence so that it is available for dereferencing."},
    {"self_type & ::genesis::sequence::FastaInputIterator::from_stream (std::istream & input_stream)", "Start reading from an input stream.\n\nThis reads the first Sequence so that it is available for dereferencing."},
    {"self_type & ::genesis::sequence::FastaInputIterator::from_string (std::string const & input_string)", "Start reading from an input file.\n\nThis reads the first Sequence so that it is available for dereferencing."},
    {"FastaReader & ::genesis::sequence::FastaInputIterator::reader ()", "Return the FastaReader used for this iterator.\n\nUse this to change the reading behaviour of the iterator. See FastaReader for details."},

    // Class FastaOutputIterator
    {"FastaWriter & ::genesis::sequence::FastaOutputIterator::writer ()", "Return the FastaWrtier used for this iterator.\n\nUse this to change the writing behaviour of the iterator. See FastaWriter for details."},

    // Class FastaReader
    {"void ::genesis::sequence::FastaReader::from_file (std::string const & file_name, SequenceSet & sequence_set) const", "Read all Sequences from a file in Fasta format into a SequenceSet.\n\nThe Sequences are added to the SequenceSet, whose existing Sequences are kept. Thus, by repeatedly calling this or similar read functions, multiple input files can easily be read into one SequenceSet."},
    {"SequenceSet ::genesis::sequence::FastaReader::from_file (std::string const & file_name) const", "Read all Sequences from a file in Fasta format and return them as a SequenceSet."},
    {"void ::genesis::sequence::FastaReader::from_stream (std::istream & input_stream, SequenceSet & sequence_set) const", "Read all Sequences from a std::istream in Fasta format into a SequenceSet.\n\nThe Sequences are added to the SequenceSet, whose existing Sequences are kept. Thus, by repeatedly calling this or similar read functions, multiple input files can easily be read into one SequenceSet."},
    {"SequenceSet ::genesis::sequence::FastaReader::from_stream (std::istream & input_stream) const", "Read all Sequences from a std::istream in Fasta format and return them as a SequenceSet."},
    {"void ::genesis::sequence::FastaReader::from_string (std::string const & input_string, SequenceSet & sequence_set) const", "Read all Sequences from a std::string in Fasta format into a SequenceSet.\n\nThe Sequences are added to the SequenceSet, whose existing Sequences are kept. Thus, by repeatedly calling this or similar read functions, multiple input files can easily be read into one SequenceSet."},
    {"SequenceSet ::genesis::sequence::FastaReader::from_string (std::string const & input_string) const", "Read all Sequences from a std::string in Fasta format and return them as a SequenceSet."},
    {"FastaReader & ::genesis::sequence::FastaReader::guess_abundances (bool value)", "Set whether Sequence labels are used to guess/extract Sequence abundances.\n\nDefault is false, that is, labels are just taken as they are in the input. If set to true, the label is used to guess an abundance count, which is set in the Sequence. See guess_sequence_abundance( Sequence const& ) for the valid formats of such abundances."},
    {"bool ::genesis::sequence::FastaReader::guess_abundances () const", "Return whether the label is used to guess/extracat Sequence abundances."},
    {"void ::genesis::sequence::FastaReader::parse_document (utils::InputStream & input_stream, SequenceSet & sequence_set) const", "Parse a whole fasta document into a SequenceSet.\n\nThis function is mainly used internally by the reading functions from_...(). It uses the currently set parsing_method() for parsing the data."},
    {"bool ::genesis::sequence::FastaReader::parse_sequence (utils::InputStream & input_stream, Sequence & sequence) const", "Parse a Sequence in Fasta format.\n\nThis function takes an InputStream and interprets it as a Fasta formatted sequence. It extracts the data and writes it into the given Sequence object. See the class description of FastaReader for the expected data format.The function stops after parsing one such sequence. It returns true if a sequence was extracted and false if the stream is empty. If the input is not in the correct format, an std::runtime_error exception is thrown indicating the malicious position in the input stream.This method has a maximum line length of utils::InputStream::BlockLength and reports errors only on the line where the sequence starts. If you have files with longer lines or want error reporting at the exact line and column where the error occurs, use ParsingMethod::kPedantic instead. See FastaReader::ParsingMethod for details."},
    {"bool ::genesis::sequence::FastaReader::parse_sequence_pedantic (utils::InputStream & input_stream, Sequence & sequence) const", "Parse a Sequence in Fasta format.\n\nThis function takes an InputStream and interprets it as a Fasta formatted sequence. It extracts the data and writes it into the given Sequence object. See the class description of FastaReader for the expected data format.The function stops after parsing one such sequence. It returns true if a sequence was extracted and false if the stream is empty. If the input is not in the correct format, an std::runtime_error exception is thrown indicating the malicious position in the input stream.Compared to parse_sequence(), this function allows for arbitrarily long lines and reports errors at the exact line and column where they occur. It is however slower. Apart from that, there are no differences. See FastaReader::ParsingMethod for details."},
    {"FastaReader & ::genesis::sequence::FastaReader::parsing_method (ParsingMethod value)", "Set the parsing method.\n\nThe parsing method is used for all the reader functions and parse_document(). See the ParsingMethod enum for details."},
    {"ParsingMethod ::genesis::sequence::FastaReader::parsing_method () const", "Return the currently set parsing method.\n\nSee the ParsingMethod enum for details."},
    {"FastaReader & ::genesis::sequence::FastaReader::site_casing (SiteCasing value)", "Set whether Sequence sites are automatically turned into upper or lower case.\n\nDefault is SiteCasing::kToUpper, that is, all sites of the read Sequences are turned into upper case letters automatically. This is demanded by the Fasta standard. The function returns the FastaReader object to allow for fluent interfaces."},
    {"SiteCasing ::genesis::sequence::FastaReader::site_casing () const", "Return whether Sequence sites are automatically turned into upper or lower case."},
    {"utils::CharLookup< bool > & ::genesis::sequence::FastaReader::valid_char_lookup ()", "Return the internal CharLookup that is used for validating the Sequence sites.\n\nThis function is provided in case direct access to the lookup is needed. Usually, the valid_chars() function should suffice. See there for details."},
    {"FastaReader & ::genesis::sequence::FastaReader::valid_chars (std::string const & chars)", "Set the chars that are used for validating Sequence sites when reading them.\n\nWhen this function is called with a string of chars, those chars are used to validate the sites when reading them. That is, only sequences consisting of the given chars are valid.If set to an empty string, this check is deactivated. This is also the default, meaning that no checking is done.In case that site_casing() is set to a value other than SiteCasing::kUnchanged: The validation is done after changing the casing, so that only lower or capital letters have to be provided for validation. In case that site_casing() is set to SiteCasing::kUnchanged: All chars that are to be considered valid have to be provided for validation.See nucleic_acid_codes...() and amino_acid_codes...() functions for presettings of chars that can be used for validation here."},
    {"std::string ::genesis::sequence::FastaReader::valid_chars () const", "Return the currently set chars used for validating Sequence sites.\n\nAn empty string means that no validation is done."},

    // Class FastaWriter
    {"FastaWriter & ::genesis::sequence::FastaWriter::abundance_notation (AbundanceNotation value)", "Set the notation for how to write Sequence abundances.\n\nDefault is to not write abundances. Use this setting to change that."},
    {"AbundanceNotation ::genesis::sequence::FastaWriter::abundance_notation () const", "Get the current setting for how to write abundances."},
    {"FastaWriter & ::genesis::sequence::FastaWriter::line_length (size_t value)", "Set the line length, which determines after how many chars (Sequence sites) lines breaks are inserted when writing the Fasta file.\n\nDefault is 80. If set to 0, no breaks are inserted. The functions returns the FastaWriter object to allow fluent interfaces."},
    {"size_t ::genesis::sequence::FastaWriter::line_length () const", "Get the current line length.\n\nSee the setter line_length( size_t ) for details."},
    {"void ::genesis::sequence::FastaWriter::to_file (SequenceSet const & sset, std::string const & fn) const", "Write Sequences of a SequenceSet to a file, using the Fasta format.\n\nIf the file cannot be written to, the function throws an exception. Also, by default, if the file already exists, an exception is thrown. See Options::allow_file_overwriting() to change this behaviour."},
    {"void ::genesis::sequence::FastaWriter::to_stream (SequenceSet const & sset, std::ostream & os) const", "Write Sequences of a SequenceSet to a stream, using the Fasta format."},
    {"std::string ::genesis::sequence::FastaWriter::to_string (SequenceSet const & sset) const", "Return Sequences of a SequenceSet in form of a Fasta formatted string.\n\nCaveat: This might be a long string! If you simply want to examine a Sequence or SequenceSet, have a look at the print() and print_color() functions."},
    {"void ::genesis::sequence::FastaWriter::write_sequence (Sequence const & seq, std::ostream & os) const", "Write a single Sequence to an output stream in Fasta format."},

    // Class PhylipReader
    {"void ::genesis::sequence::PhylipReader::from_file (std::string const & file_name, SequenceSet & sequence_set) const", "Read all Sequences from a file in Phylip format into a SequenceSet.\n\nThe Sequences are added to the SequenceSet, whose existing Sequences are kept. Thus, by repeatedly calling this or similar read functions, multiple input files can easily be read into one SequenceSet."},
    {"SequenceSet ::genesis::sequence::PhylipReader::from_file (std::string const & file_name) const", "Read all Sequences from a file in Phylip format and return them as a SequenceSet."},
    {"void ::genesis::sequence::PhylipReader::from_stream (std::istream & input_stream, SequenceSet & sequence_set) const", "Read all Sequences from a std::istream in Phylip format into a SequenceSet.\n\nThe Sequences are added to the SequenceSet, whose existing Sequences are kept. Thus, by repeatedly calling this or similar read functions, multiple input files can easily be read into one SequenceSet.This function is only allowed for Mode::kSequential and Mode::kInterleaved. Automatic mode does not work, as the stream might need to be reset, which is not possible. See mode(Mode) for details."},
    {"SequenceSet ::genesis::sequence::PhylipReader::from_stream (std::istream & input_stream) const", "Read all Sequences from a std::istream in Phylip format and return them as a SequenceSet.\n\nThis function is only allowed for Mode::kSequential and Mode::kInterleaved. Automatic mode does not work, as the stream might need to be reset, which is not possible. See mode(Mode) for details."},
    {"void ::genesis::sequence::PhylipReader::from_string (std::string const & input_string, SequenceSet & sequence_set) const", "Read all Sequences from a std::string in Phylip format into a SequenceSet.\n\nThe Sequences are added to the SequenceSet, whose existing Sequences are kept. Thus, by repeatedly calling this or similar read functions, multiple input files can easily be read into one SequenceSet."},
    {"SequenceSet ::genesis::sequence::PhylipReader::from_string (std::string const & input_string) const", "Read all Sequences from a std::string in Phylip format and return them as a SequenceSet."},
    {"PhylipReader & ::genesis::sequence::PhylipReader::label_length (size_t value)", "Set the length of the label in front of the sequences.\n\nPhylip has the weird property that labels are written in front of sequences and do not need to have a delimiter, but instead are simply the first n characters of the string. This value determines after how many chars the label ends and the actual sequence begins.If set to a value greater than 0, exaclty this many characters are read as label. Thus, they can also contain spaces. Spaces at the beginning or end of a label are stripped. The length that is dictated by the Phylip standard is 10, but any other length can also be used.If set to 0 (default), a relaxed version of Phylip is used instead, where the sequence begin is automatically detected. Labels can then be of arbitrary lengths, as long as they do not contain white spaces. However, in this case, there has to be at least one space or tab character between the label and the sequence. After the whitespace(s), the rest of the line is then treated as sequence data.The function returns the PhylipReader object to allow for fluent interfaces."},
    {"size_t ::genesis::sequence::PhylipReader::label_length () const", "Return the currently set label length.\n\nSee the setter label_length( size_t ) for details."},
    {"PhylipReader & ::genesis::sequence::PhylipReader::mode (Mode value)", "Set the mode for reading sequences.\n\nPhylip offers two variants for storing the sequences: sequential and interleaved. As there is no option or flag in the file itself, there is no chance of knowing the variant without trying to parse it. If one fails but not the other, it is proabably the latter variant. However, there are instances where both variants are valid at the same time, but yield different sequences. So, in general detecting the correct variant is undecidable, making Phylip a non-well-defined format.In order to avoid those problems, this function explicitly sets the variant being used for parsing. By default, it is set to Mode::kSequential. Use Mode::kInterleaved for the other variant.We also offer a Mode::kAutomatic. It first tries to parse in sequential mode, and, if this fails, in interleaved mode. However, as this might involve starting from the beginning of the data, this is only possible with the from_file() and from_string() readers and does not work when using the from_stream() reader. Also, be aware that using automatic mode is slower because of implementation details induced by those limitations. Try to avoid automatic mode. If possible, try to avoid Phylip at all."},
    {"Mode ::genesis::sequence::PhylipReader::mode () const", "Return the currently set mode for parsing Phylip.See the setter mode( Mode ) for details."},
    {"Header ::genesis::sequence::PhylipReader::parse_phylip_header (utils::InputStream & it) const", "Parse a Phylip header and return the contained sequence count and length.\n\nThis helper function expects to find a Phylip header line in the form x y, which describes the number of sequences x in the Phylip data and their length y. The remainder of the header line is interpreted as Phylip options. See Header struct for more information.The function then advances the stream and skips potential empty lines after the header. It thus leaves the stream at the beginning of the first sequence line."},
    {"void ::genesis::sequence::PhylipReader::parse_phylip_interleaved (utils::InputStream & it, SequenceSet & sset) const", "Parse a whole Phylip file using the interleaved variant (Mode::kInterleaved)."},
    {"std::string ::genesis::sequence::PhylipReader::parse_phylip_label (utils::InputStream & it) const", "Parse and return a Phylip label.\n\nThis helper functions either takes the first label_length chars as a label or, if label_length == 0 takes all chars until the first blank as label. It returns the trimmed label and leaves the stream at the next char after the label (and after subsequent blanks)."},
    {"std::string ::genesis::sequence::PhylipReader::parse_phylip_sequence_line (utils::InputStream & it) const", "Parse one sequence line.\n\nThe line (which can also start after a label) is parsed until the first '\\n' char. While parsing, the options site_casing() and valid_chars() are applied according to their settings. The stream is left at the beginning of the next line."},
    {"void ::genesis::sequence::PhylipReader::parse_phylip_sequential (utils::InputStream & it, SequenceSet & sset) const", "Parse a whole Phylip file using the sequential variant (Mode::kSequential)."},
    {"PhylipReader & ::genesis::sequence::PhylipReader::site_casing (SiteCasing value)", "Set whether Sequence sites are automatically turned into upper or lower case.\n\nDefault is SiteCasing::kToUpper, that is, all sites of the read Sequences are turned into upper case letters automatically. The function returns the PhylipReader object to allow for fluent interfaces."},
    {"SiteCasing ::genesis::sequence::PhylipReader::site_casing () const", "Return whether Sequence sites are automatically turned into upper or lower case."},
    {"utils::CharLookup< bool > & ::genesis::sequence::PhylipReader::valid_char_lookup ()", "Return the internal CharLookup that is used for validating the Sequence sites.\n\nThis function is provided in case direct access to the lookup is needed. Usually, the valid_chars() function should suffice. See there for details."},
    {"PhylipReader & ::genesis::sequence::PhylipReader::valid_chars (std::string const & chars)", "Set the chars that are used for validating Sequence sites when reading them.\n\nWhen this function is called with a string of chars, those chars are used to validate the sites when reading them. That is, only sequences consisting of the given chars are valid.If set to an empty string, this check is deactivated. This is also the default, meaning that no checking is done.In case that site_casing() is set to a value other than SiteCasing::kUnchanged: The validation is done after changing the casing, so that only lower or capital letters have to be provided for validation. In case that site_casing() is set to SiteCasing::kUnchanged: All chars that are to be considered valid have to be provided for validation.See nucleic_acid_codes...() and amino_acid_codes...() functions for presettings of chars that can be used for validation here."},
    {"std::string ::genesis::sequence::PhylipReader::valid_chars () const", "Return the currently set chars used for validating Sequence sites.\n\nAn empty string means that no validation is done."},

    // Class PhylipWriter
    {"PhylipWriter & ::genesis::sequence::PhylipWriter::label_length (size_t value)", "Set the length of the label in front of the sequences.\n\nPhylip has the weird property that labels are written in front of sequences and do not need to have a delimiter, but instead are simply the first n characters of the string. This value determines after how many chars the label ends and the actual sequence begins.If set to 0 (default), a relaxed version of Phylip is used, where the sequence begin is automatically detected. Labels can then be of arbitrary lengths, as long as they do not contain white spaces. After the label, a space is appended.If set to a value greater than 0, the label will be cut off after that many chars. For shorter labels, the remaining number is filled with spaces. The functions returns the PhylipWriter object to allow fluent interfaces."},
    {"size_t ::genesis::sequence::PhylipWriter::label_length () const", "Return the currently set label length.\n\nSee the setter label_length( size_t ) for details."},
    {"PhylipWriter & ::genesis::sequence::PhylipWriter::line_length (size_t value)", "Set the line length, which determines after how many chars (Sequence sites) lines breaks are inserted when writing the Phylip file.\n\nDefault is 80. If set to 0, no breaks are inserted. The functions returns the PhylipWriter object to allow fluent interfaces."},
    {"size_t ::genesis::sequence::PhylipWriter::line_length () const", "Get the current line length.\n\nSee the setter line_length( size_t ) for details."},
    {"void ::genesis::sequence::PhylipWriter::to_file (SequenceSet const & sset, std::string const & fn) const", "Write Sequences of a SequenceSet to a file in Phylip format.\n\nIf the file cannot be written to, the function throws an exception. Also, by default, if the file already exists, an exception is thrown. See Options::allow_file_overwriting() to change this behaviour."},
    {"void ::genesis::sequence::PhylipWriter::to_stream (SequenceSet const & sset, std::ostream & os) const", "Write Sequences of a SequenceSet to a stream in Phylip format."},
    {"std::string ::genesis::sequence::PhylipWriter::to_string (SequenceSet const & sset) const", "Return Sequences of a SequenceSet in form of a Phylip formatted string.\n\nCaveat: This might be a long string! If you simply want to examine a Sequence or SequenceSet, have a look at the print() and print_color() functions."},

    // Class PrinterBitmap
    {"PrinterBitmap & ::genesis::sequence::PrinterBitmap::color_map (std::map< char, utils::Color > const & value)", "Set the list of Colors to use for the Sequence charaters.\n\nThe provided map sets the colors for each Sequence character. The presettings nucleic_acid_colors() and amino_acid_colors() for default sequence types can be used as input for this parameter. If the colors map does not contain a key for one of the chars in the sequence, the char is printed in black."},
    {"std::map< char, utils::Color > const & ::genesis::sequence::PrinterBitmap::color_map () const", "Get the currently set list of Colors for each Sequence character.\n\nSee the setter for details."},

    // Class PrinterSimple
    {"PrinterSimple & ::genesis::sequence::PrinterSimple::color_map (std::map< char, std::string > const & value)", "Set the list of colors to use for the Sequence charaters.\n\nThe provided map sets the color name for each Sequence character. The presettings nucleic_acid_text_colors() and amino_acid_text_colors() for default sequence types can be used as input for this parameter. If the colors map does not contain a key for one of the chars in the sequence, the char is printed without color.See color_mode() for more details. See utils::Style for details and for a list of the available color names."},
    {"std::map< char, std::string > const & ::genesis::sequence::PrinterSimple::color_map () const", "Get the currently set list of colors for each Sequence character.\n\nSee the setter for details."},
    {"PrinterSimple & ::genesis::sequence::PrinterSimple::color_mode (ColorMode value)", "Set whether to use color in the background, foreground, or not at all.\n\nSee ColorMode for details."},
    {"ColorMode ::genesis::sequence::PrinterSimple::color_mode () const", "Get the currently set color mode.\n\nSee the setter for details."},
    {"PrinterSimple & ::genesis::sequence::PrinterSimple::label_mode (LabelMode value)", "Set the currently set LabelMode.\n\nSee LabelMode for more information."},
    {"LabelMode ::genesis::sequence::PrinterSimple::label_mode () const", "Get the currently set LabelMode.\n\nSee the setter and LabelMode for more information."},
    {"PrinterSimple & ::genesis::sequence::PrinterSimple::length_limit (size_t value)", "Set the length limit for printing Sequences.\n\nThis parameter limits the output length to the give number of chars. If set to 0, the whole Sequence is printed (default). If the limit is lower than the acutal number of sites in the Sequence, ellipsis \" ...\" are appended."},
    {"size_t ::genesis::sequence::PrinterSimple::length_limit () const", "Get the currently set length limit.\n\nSee the setter for details."},
    {"PrinterSimple & ::genesis::sequence::PrinterSimple::line_length (size_t value)", "Set the length of each line, i.e., when to wrap.\n\nIf this parameter is set to a value other than 0, the Sequence is wrapped at this line length. This also works in combination with length_limit()."},
    {"size_t ::genesis::sequence::PrinterSimple::line_length () const", "Get the currently set line length, i.e., when to wrap.\n\nSee the setter for details."},
    {"void ::genesis::sequence::PrinterSimple::print (std::ostream & out, Sequence const & seq) const", "Print a single Sequence to a stream."},
    {"void ::genesis::sequence::PrinterSimple::print (std::ostream & out, SequenceSet const & set) const", "Print a SequenceSet to a stream."},
    {"std::string ::genesis::sequence::PrinterSimple::print (Sequence const & seq) const", "Return a string representing the print of a single Sequence."},
    {"std::string ::genesis::sequence::PrinterSimple::print (SequenceSet const & set) const", "Return a string representing the print of a SequenceSet."},
    {"PrinterSimple & ::genesis::sequence::PrinterSimple::sequence_limit (size_t value)", "Set the limit for how many Sequences to print.\n\nIf this parameter is set to a value other than 0, only this number of Sequences are printed. Default is 0, thus, all Sequences are printed. If the given limit is lower than the acutal number of Sequences in the SequenceSet, ellipsis \" ...\" are appended."},
    {"size_t ::genesis::sequence::PrinterSimple::sequence_limit () const", "Get the currently set limit for how many Sequences to print.\n\nSee the setter for details."},

    // Class Sequence
    {"size_t ::genesis::sequence::Sequence::length () const", "Return the length (number of sites) of this sequence."},
    {"size_t ::genesis::sequence::Sequence::size () const", "Alias for length()."},

    // Class SequenceSet
    {"reference ::genesis::sequence::SequenceSet::add (Sequence const & s)", "Add a Sequence to the SequenceSet by copying it, and return a reference to it."},
    {"reference ::genesis::sequence::SequenceSet::add (Sequence && s)", "Add a Sequence to the SequenceSet by moving it, and return a reference to it."},
    {"void ::genesis::sequence::SequenceSet::clear ()", "Remove all Sequences from the SequenceSet, leaving it with a size() of 0."},
    {"bool ::genesis::sequence::SequenceSet::empty () const", "Return whether the SequenceSet is empty, i.e. whether its size() is 0."},
    {"void ::genesis::sequence::SequenceSet::remove (size_t index)", "Remove the Sequence at a given index from the SequenceSet."},
    {"void ::genesis::sequence::SequenceSet::remove (size_t first_index, size_t last_index)", "Remove the Sequences between the first_index (inclusive) and the last_index (exclusive) from the SequenceSet."},
    {"void ::genesis::sequence::SequenceSet::remove (iterator position)", "Remove the Sequence at a given iterator position from the SequenceSet."},
    {"void ::genesis::sequence::SequenceSet::remove (iterator first, iterator last)", "Remove the Sequences between the first (inclusive) and the last (exclusive) iterator position from the SequenceSet."},
    {"size_t ::genesis::sequence::SequenceSet::size () const", "Return the number of Sequences in the SequenceSet."},

    // Class SignatureSpecifications
    {"size_t ::genesis::sequence::SignatureSpecifications::char_index (char c) const", "Return the index of a char within the alphabet().\n\nFor chars that are not in the alphabet, InvalidCharIndex is returned as an indicator value."},
    {"bool ::genesis::sequence::SignatureSpecifications::is_nucleic_acids () const", "Speedup and shortcut to test whether the alphabet() is \"ACGT\"."},
    {"std::vector< size_t > const & ::genesis::sequence::SignatureSpecifications::kmer_combined_reverse_complement_map () const", "Get a map from indices of kmer_list() and signature_counts() vectors to a smaller list which combines reverse complementary kmers for nucleic acid sequences."},
    {"std::vector< std::string > const & ::genesis::sequence::SignatureSpecifications::kmer_list () const", "Return the list of all possible k-mers for the given k and alphabet."},
    {"std::vector< size_t > const & ::genesis::sequence::SignatureSpecifications::kmer_reverse_complement_indices () const", "Get the indices for each kmer in kmer_list() to its reverse complement in the list."},

    // Class SiteCounts
    {"void ::genesis::sequence::SiteCounts::add_sequence (Sequence const & sequence, bool use_abundance=true)", "Process a single Sequence and add its counts to the existing ones.\n\nIf use_abundance is true (default), the abundance of the Sequence is used as weight for the counting. Otherwise, a weight of 1 is used."},
    {"void ::genesis::sequence::SiteCounts::add_sequence (std::string const & sites, CountsIntType weight=1)", "Process a single sequence in string form and add its counts to the existing ones.\n\nUsing weight, the sequence can be weighted. That is, the count is increased by the weight."},
    {"void ::genesis::sequence::SiteCounts::add_sequences (SequenceSet const & sequences)", "Process a SequenceSet and add its counts to the existing ones for all contained Sequences."},
    {"CountsIntType ::genesis::sequence::SiteCounts::added_sequences_count () const", "Return the number of processed Sequences, i.e., how many Sequences were added in total."},
    {"std::string ::genesis::sequence::SiteCounts::characters () const", "Return the character set that is used for counting.\n\nThis function returns the upper case letters of the internal list of characters that is used for counting, in the order that is also used by the count_at() function."},
    {"void ::genesis::sequence::SiteCounts::clear ()", "Clear the object, that is, delete everything.\n\nThis function sets the object status to the same that the default constructor gives. Thus, it is not usable any more. It is mainly intended to save memory when many objects are used and then no longer needed.For an alternative function that simply resets the counts to zero but keeps the dimentions of the count matrix, see clear_counts()."},
    {"void ::genesis::sequence::SiteCounts::clear_counts ()", "Reset all counts to 0.\n\nThis clears the counts so that the object is as if newly created, while keeping the counted characters and length of the count matrix. It also clears the count for added_sequences_count()."},
    {"CountsIntType ::genesis::sequence::SiteCounts::count_at (size_t character_index, size_t site_index) const", "Return the count for a character and a site, given their indices.\n\nThe characters are indexed in the order given by characters(). This function is thus mainly for speedup reasons when iterating the whole Matrix."},
    {"CountsIntType ::genesis::sequence::SiteCounts::count_of (char character, size_t site_index) const", "Return the count of a specific character at a given site.\n\nIf the charater is not part of the set of used characters, the function throws an exception. This function is case-independent. See characters() to retrieve the set of characters."},
    {"size_t ::genesis::sequence::SiteCounts::length () const", "Return the number of sites used for counting.\n\nThis has to match the Sequence::length() property of the Sequences to be added for counting."},

    // Class Header

    // Class BaseTaxonData
    {"std::unique_ptr< BaseTaxonData > ::genesis::taxonomy::BaseTaxonData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},
    {"static std::unique_ptr< BaseTaxonData > ::genesis::taxonomy::BaseTaxonData::create ()", "Create a new instance of this class. Use instead of default constructor."},

    // Class BreadthFirstSearch

    // Class DepthFirstSearch

    // Class EntropyTaxonData
    {"std::unique_ptr< BaseTaxonData > ::genesis::taxonomy::EntropyTaxonData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},

    // Class IteratorPreorder

    // Class NcbiName

    // Class NcbiNode

    // Class PrinterNested

    // Class PruneByEntropySettings

    // Class Taxon
    {"BaseTaxonData * ::genesis::taxonomy::Taxon::data_ptr ()", "Return a pointer to the data.\n\nIn most cases, using data<>() is more convenient. However, in some cases, this function might be necessary."},
    {"BaseTaxonData const * ::genesis::taxonomy::Taxon::data_ptr () const", "Return a const pointer to the data.\n\nIn most cases, using data<>() is more convenient. However, in some cases, this function might be necessary."},
    {"bool ::genesis::taxonomy::Taxon::has_data () const", "Return true if the Taxon has a data object assigned to it."},
    {"std::string const & ::genesis::taxonomy::Taxon::id () const", "Set the ID of this taxon."},
    {"std::string const & ::genesis::taxonomy::Taxon::name () const", "Return the name of this taxon."},
    {"void ::genesis::taxonomy::Taxon::name (std::string const & value)", "Set the name of this taxon."},
    {"Taxon const * ::genesis::taxonomy::Taxon::parent () const", "Return a pointer to the parent of this taxon, or a nullptr if this is the top level taxon."},
    {"Taxon * ::genesis::taxonomy::Taxon::parent ()", "Return a pointer to the parent of this taxon, or a nullptr if this is the top level taxon."},
    {"std::string const & ::genesis::taxonomy::Taxon::rank () const", "Return the rank of this taxon."},
    {"Taxon & ::genesis::taxonomy::Taxon::reset_data (std::unique_ptr< BaseTaxonData > data)", "Reset the data pointer of this Taxon.\n\nUsing this function, a Taxon can be assigend new data. It is also possible to change the data type completely (as long as it derives from BaseTaxonData). Be however aware that many functions that work with a Taxonomy expect a certain data type. Thus, changing it might break those functions and lead to exceptions and other errors."},

    // Class Taxonomy
    {"Taxon & ::genesis::taxonomy::Taxonomy::add_child (Taxon const & child, bool merge_duplicates=true)", "Add a child Taxon as a copy of a given Taxon and return it.\n\nIf merge_duplicates is true (default), the Taxonomy is checked for a child Taxon with the same name, and if one exists, it is recursively merged with the given Taxon. Otherwise (merge_duplicates is false), the Taxon is added, even if this creates another child Taxon with the same name."},
    {"Taxon & ::genesis::taxonomy::Taxonomy::add_child (std::string const & name, bool merge_duplicates=true)", "Add a child Taxon by creating a new one with the given name and return it.\n\nIf merge_duplicates is true (default), the Taxonomy is checked for a child Taxon with the same name, and if one exists, nothing is added. Otherwise (merge_duplicates is false), a new Taxon is added, even if this creates another child Taxon with the same name."},
    {"Taxon const & ::genesis::taxonomy::Taxonomy::at (size_t index) const", "Return the child Taxon at the given index.\n\nThe function throws an exception if the index in invalid, i.e., >= size()."},
    {"Taxon & ::genesis::taxonomy::Taxonomy::at (size_t index)", "Return the child Taxon at the given index.\n\nThe function throws an exception if the index in invalid, i.e., >= size()."},
    {"const_iterator ::genesis::taxonomy::Taxonomy::cbegin () const", "Return a const iterator to the beginning of the child taxa."},
    {"const_iterator ::genesis::taxonomy::Taxonomy::cend () const", "Return a const iterator to the end of the child taxa."},
    {"void ::genesis::taxonomy::Taxonomy::clear_children ()", "Remove all children."},
    {"Taxon const & ::genesis::taxonomy::Taxonomy::get_child (std::string name) const", "Return the child Taxon with a given name if it exists, or throw otherwise."},
    {"Taxon & ::genesis::taxonomy::Taxonomy::get_child (std::string name)", "Return the child Taxon with a given name if it exists, or throw otherwise."},
    {"bool ::genesis::taxonomy::Taxonomy::has_child (std::string name) const", "Return whether an immediate child Taxon with the given name exists."},
    {"void ::genesis::taxonomy::Taxonomy::remove_at (size_t index)", "Remove a child Taxon at a certain index.\n\nThe Taxon (and all its sub-taxa) are destroyed. Throws an std::runtime_error if the index is out of bounds."},
    {"void ::genesis::taxonomy::Taxonomy::remove_child (std::string const & name)", "Remove a child Taxon with a certain name.\n\nThe Taxon (and all its sub-taxa) are destroyed. Throws an std::runtime_error if there is no Taxon with the given name."},
    {"size_t ::genesis::taxonomy::Taxonomy::size () const", "Return the number of immediate child Taxa.\n\nSee total_taxa_count() for counting all Taxa, including all nested ones."},
    {"void ::genesis::taxonomy::Taxonomy::sort (Compare comp)", "Sort the taxonomy according to some compare criterion."},

    // Class TaxonomyReader
    {"utils::CsvReader & ::genesis::taxonomy::TaxonomyReader::csv_reader ()", "Get the CsvReader used for reading a taxonomy file.\n\nThis can be used to modify the reading behaviour, particularly values like the separator chars within the lines of the file. By default, the TaxonomyReader uses a tab \\t char to separate fields, which is different from the comma ',' that is used as default by the CsvReader.It is also possible to change other properties of the CsvReader, for example escaping behaviour, if the input data needs special treatment in those regards.See CsvReader for details about those properties."},
    {"TaxonomyReader & ::genesis::taxonomy::TaxonomyReader::expect_strict_order (bool value)", "Set whether the reader expects a strict order of taxa.\n\nIn a strictly ordered taxonomy file, the super-groups have to be listed before any sub-groups.For example, the list Archaea;\nArchaea;Aenigmarchaeota;\nArchaea;Crenarchaeota;\nArchaea;Crenarchaeota;Thermoprotei;\nis in strict order.If this property is set to true, the reader expects this ordering and throws an exception if there is a violation, that is, if there is a sub-group in the list without a previous entry of its super-group (recursively). This is useful to check a file for consistency, e.g., it might happen that some super-group is misspelled by accident.If set to false (default), the order is ignored and all super-groups are created if necessary."},
    {"bool ::genesis::taxonomy::TaxonomyReader::expect_strict_order () const", "Return whether currently the reader expects a strict order of taxa.\n\nSee the setter for more information."},
    {"void ::genesis::taxonomy::TaxonomyReader::from_file (std::string const & fn, Taxonomy & tax) const", "Read a taxonomy file and add its contents to a Taxonomy."},
    {"Taxonomy ::genesis::taxonomy::TaxonomyReader::from_file (std::string const & fn) const", "Read a taxonomy file and and return the Taxonomy."},
    {"void ::genesis::taxonomy::TaxonomyReader::from_stream (std::istream & is, Taxonomy & tax) const", "Read taxonomy data until the end of the stream is reached, and add the contents to a Taxonomy."},
    {"Taxonomy ::genesis::taxonomy::TaxonomyReader::from_stream (std::istream & is) const", "Read taxonomy data until the end of the stream is reached, and return the Taxonomy."},
    {"void ::genesis::taxonomy::TaxonomyReader::from_string (std::string const & is, Taxonomy & tax) const", "Read a string with taxonomy data and add its contents to a Taxonomy."},
    {"Taxonomy ::genesis::taxonomy::TaxonomyReader::from_string (std::string const & is) const", "Read a string with taxonomy data and and return the Taxonomy."},
    {"TaxonomyReader & ::genesis::taxonomy::TaxonomyReader::id_field_position (int value)", "Set the position of the field in each line where the ID is located.\n\nThis value determines at with position (zero based) the field for the ID is located.For example, in a taxonomy file with entries like Archaea;Crenarchaeota;Thermoprotei; 7   class   119\nthis value could have to be set to 1, as this is where the ID \"7\" is found.If the file does not contain any IDs, or if this field should be skipped, set it to a value of -1. This is also the default."},
    {"int ::genesis::taxonomy::TaxonomyReader::id_field_position () const", "Get the currently set position of the field in each line where the ID is located.\n\nSee the setter of this function for details."},
    {"TaxonomyReader & ::genesis::taxonomy::TaxonomyReader::name_field_position (int value)", "Set the position of the field in each line where the taxon name (Taxopath) is located.\n\nThis value determines at with position (zero based) the field for the taxon name is located.For example, in a taxonomy file with entries like Archaea;Crenarchaeota;Thermoprotei; 7   class   119\nthis value would have to be set to 0, as this is where the taxon name is found. This reader expects the taxon name to be a Taxopath. This is what we call a string of taxonomic hierarchy elements, usually separated by semicola. See Taxopath for details.By default, this value is set to 0, that is, the first field. As it does not make sense to skip this value, it cannot be set to values below zero - which is different from rank_field_position. An exception is thrown should this be attempted."},
    {"int ::genesis::taxonomy::TaxonomyReader::name_field_position () const", "Get the currently set position of the field in each line where the taxon name is located.\n\nSee the setter of this function for details."},
    {"void ::genesis::taxonomy::TaxonomyReader::parse_document (utils::InputStream & it, Taxonomy & tax) const", "Parse all data from an InputStream into a Taxonomy object."},
    {"Line ::genesis::taxonomy::TaxonomyReader::parse_line (utils::InputStream & it) const", "Read a single line of a taxonomy file and return the contained name and rank.\n\nThe name is expected to be a taxonomic path string. See Taxopath for details on that format."},
    {"TaxonomyReader & ::genesis::taxonomy::TaxonomyReader::rank_field_position (int value)", "Set the position of the field in each line where the rank name is located.\n\nThis value determines at with position (zero based) the field for the rank name is located.For example, in a taxonomy file with entries like Archaea;Crenarchaeota;Thermoprotei; 7   class   119\nthis value would have to be set to 2, as this is where the rank name \"class\" is found.If the file does not contain any rank names, or if this field should be skipped, set it to a value of -1. This is also the default."},
    {"int ::genesis::taxonomy::TaxonomyReader::rank_field_position () const", "Get the currently set position of the field in each line where the rank name is located.\n\nSee the setter of this function for details."},
    {"TaxopathParser & ::genesis::taxonomy::TaxonomyReader::taxopath_parser ()", "Get the TaxopathParser used for parsing taxonomic path strings.\n\nThe name field is expected to be a taxonomic path string. It is turned into a Taxon using the settings of the TaxopathParser. See there for details. See Taxopath for a path of the expected string format."},

    // Class TaxonomyWriter

    // Class Taxopath
    {"void ::genesis::taxonomy::Taxopath::assign (std::vector< std::string > const & from)", "Replace the current elements of the Taxopath by a list of strings.\n\nThe strings are copied and used as Taxopath elements in the order in which they are stored in the vector."},
    {"std::string const & ::genesis::taxonomy::Taxopath::at (size_t index) const", "Return the taxonomic element at a certain position.\n\nThe function throws if the given index is not within the size of the taxonomic elements."},
    {"std::string & ::genesis::taxonomy::Taxopath::at (size_t index)", "Return the taxonomic element at a certain position.\n\nThe function throws if the given index is not within the size of the taxonomic elements."},
    {"void ::genesis::taxonomy::Taxopath::clear ()", "Clear all taxonomic elements. This results in an empty Taxopath."},
    {"std::vector< std::string > const & ::genesis::taxonomy::Taxopath::elements () const", "Return the elements of the Taxopath as a vector of strings."},
    {"std::vector< std::string > & ::genesis::taxonomy::Taxopath::elements ()", "Return the elements of the Taxopath as a vector of strings."},
    {"bool ::genesis::taxonomy::Taxopath::empty () const", "Return whether the Taxopath is empty, i.e., does not contain any elements."},
    {"std::string ::genesis::taxonomy::Taxopath::pop_back ()", "Remove the last element of the Taxopath and return its value.\n\nThe returned value is obtained as a copy of the last element before it is removed."},
    {"void ::genesis::taxonomy::Taxopath::push_back (std::string const & value)", "Add an element to the end of the Taxopath by copying it."},
    {"void ::genesis::taxonomy::Taxopath::push_back (std::string && value)", "Add an element to the end of the Taxopath by moving it."},
    {"reverse_iterator ::genesis::taxonomy::Taxopath::rbegin ()", "Return a reverse iterator to the reverse beginning of the taxonomic elements."},
    {"const_reverse_iterator ::genesis::taxonomy::Taxopath::rbegin () const", "Return a const reverse iterator to the reverse beginning of the taxonomic elements."},
    {"reverse_iterator ::genesis::taxonomy::Taxopath::rend ()", "Return a reverse iterator to the reverse end of the taxonomic elements."},
    {"const_reverse_iterator ::genesis::taxonomy::Taxopath::rend () const", "Return a const reverse iterator to the reverse end of the taxonomic elements."},
    {"size_t ::genesis::taxonomy::Taxopath::size () const", "Return the number of elements of this Taxopath."},
    {"void ::genesis::taxonomy::Taxopath::swap (Taxopath & other)", "Swap the elements of two Taxopaths."},

    // Class TaxopathGenerator
    {"TaxopathGenerator & ::genesis::taxonomy::TaxopathGenerator::append_delimiter (bool value)", "Set whether to append the delimiter string to the generated string.\n\nIn many taxonomic databases, the string representation ends with the delimiter char, for example Animalia;Vertebrata;Mammalia;Carnivora;\nThis setting determines whether this last delimiter is appended or not."},
    {"bool ::genesis::taxonomy::TaxopathGenerator::append_delimiter () const", "Return whether currently a delimiter is appended to the taxonomic path string.\n\nSee the setter for details."},
    {"TaxopathGenerator & ::genesis::taxonomy::TaxopathGenerator::delimiter (std::string const & value)", "Set the string used to join the taxonomic path string elements.\n\nThis value is used in between the elements of the taxonomic path string. Default is ';', as this is the usual value in many databases. See Taxopath for details."},
    {"std::string ::genesis::taxonomy::TaxopathGenerator::delimiter () const", "Return the currelty set value used to join the taxonomic path string elements.\n\nSee the setter for details."},
    {"TaxopathGenerator & ::genesis::taxonomy::TaxopathGenerator::field (TaxonField value)", "Set the string field to use for Taxon input.\n\nThe Taxon class stores three strings that describe a taxon: its name, its rank, and an ID. Using this setting, one can chose which of the fields to use when generating a taxopath."},
    {"TaxonField ::genesis::taxonomy::TaxopathGenerator::field () const", "Return the currelty set field to use for describing a Taxon.\n\nSee the setter for details."},
    {"std::string ::genesis::taxonomy::TaxopathGenerator::to_string (Taxopath const & taxopath) const", "Return a string representation of a Taxopath.\n\nThis generator function uses the settings of this class to generate the string."},
    {"std::string ::genesis::taxonomy::TaxopathGenerator::to_string (Taxon const & taxon) const", "Return a string representation of a Taxon.\n\nThis generator function uses the settings of this class to generate the string."},
    {"TaxopathGenerator & ::genesis::taxonomy::TaxopathGenerator::trim_nested_duplicates (bool value)", "Set whether lower level taxa are omitted if they are the same as the next higher level one.\n\nIf set to true, lower level names are set to empty if they are the same as higher level names. Default is false, that is, nothing is trimmed.Example: For a Taxopath [ \"Tax_1\", \"Tax_1\", \"Tax_2\" ]\nthe generator function returns Tax_1;Tax_1;Tax_2, and respectively Tax_1;;Tax_2 with trimming nested duplicates."},
    {"bool ::genesis::taxonomy::TaxopathGenerator::trim_nested_duplicates () const", "Return the currently set value whether to trim nested duplicates of taxa names.\n\nSee the setter for details."},

    // Class TaxopathParser
    {"TaxopathParser & ::genesis::taxonomy::TaxopathParser::delimiters (std::string const & value)", "Set the chars used to split the taxonomic path string.\n\nThose chars are used to split the taxon name into its hierarchical parts. Default is ';', as this is the usual value in many databases. See Taxopath for details.If this value is set to multiple chars (string longer than 1), any of them is used for splitting.Example: The taxonomic path string Archaea;Euryarchaeota;Halobacteria;\nis split into \"Archaea\", \"Euryarchaeota\" and \"Halobacteria\"."},
    {"std::string ::genesis::taxonomy::TaxopathParser::delimiters () const", "Return the currelty set delimiter chars used to split the taxonomic path string.\n\nSee the setter for details."},
    {"Taxopath ::genesis::taxonomy::TaxopathParser::from_string (std::string const & taxopath) const", "Parse a taxonomic path string into a Taxopath object and return it.\n\nSee the class description for details on what this parser does."},
    {"Taxopath ::genesis::taxonomy::TaxopathParser::from_taxon (Taxon const & taxon) const", "Helper function to turn a Taxon into a Taxopath.\n\nThis function is probably not need often, as the Taxopath is a helper object from a taxonomic path string towards a Taxon object, but not the other way round. In order to get the string from a Taxon, see the TaxopathGenerator class instead.However, this function might still be useful in some cases. You never know."},
    {"TaxopathParser & ::genesis::taxonomy::TaxopathParser::remove_trailing_delimiter (bool value)", "Set whether to remove an empty taxonomic element at the end, if it occurs.\n\nIn many taxonomic databases, the taxonomic string representation end with a ';' by default. When splitting such a string, this results in an empty last element. If this option is set to true (default), this element is removed from the Taxopath.If set to false, the element is not removed, but instead treated as a normal \"empty\" element, which means, it is replaced by the value of the preceeding element. See the class description for details on that."},
    {"bool ::genesis::taxonomy::TaxopathParser::remove_trailing_delimiter () const", "Return whether currently trailing delimiters are removed from the taxonomic path string.\n\nSee the setter for details."},
    {"TaxopathParser & ::genesis::taxonomy::TaxopathParser::trim_whitespaces (bool value)", "Set whether to trim whitespaces around the taxonomic elements after splitting them.\n\nDefault is true. If set to true, the taxa given are trimmed off white spaces after splitting them. This is helpful if the input string is copied from some spreadsheet application or CSV file, where spaces between cells might be added.If set to false, all elements are left as they are.Example: The line Archaea; Aigarchaeota; Aigarchaeota Incertae Sedis; 11091   class   123\ncontains spaces both between the taxa names (separated by ;), as well as within the names. Only the former ones will be trimmed, while latter ones are left as they are."},
    {"bool ::genesis::taxonomy::TaxopathParser::trim_whitespaces () const", "Return the currently set value whether whitespaces are trimmed off the taxonomic elements.\n\nSee the setter for details."},

    // Class Line

    // Class AttributeTreeEdgeData
    {"std::unique_ptr< BaseEdgeData > ::genesis::tree::AttributeTreeEdgeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},
    {"std::unique_ptr< BaseEdgeData > ::genesis::tree::AttributeTreeEdgeData::recreate () const", "Polymorphically create a default-constructed instance of this class with the same derived type as it was called on."},

    // Class AttributeTreeNodeData
    {"std::unique_ptr< BaseNodeData > ::genesis::tree::AttributeTreeNodeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},
    {"std::unique_ptr< BaseNodeData > ::genesis::tree::AttributeTreeNodeData::recreate () const", "Polymorphically create a default-constructed instance of this class with the same derived type as it was called on."},

    // Class BaseEdgeData
    {"std::unique_ptr< BaseEdgeData > ::genesis::tree::BaseEdgeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},
    {"static std::unique_ptr< BaseEdgeData > ::genesis::tree::BaseEdgeData::create ()", "Create a new instance of this class. Use instead of default constructor."},
    {"std::unique_ptr< BaseEdgeData > ::genesis::tree::BaseEdgeData::recreate () const", "Polymorphically create a default-constructed instance of this class with the same derived type as it was called on."},

    // Class BaseNodeData
    {"std::unique_ptr< BaseNodeData > ::genesis::tree::BaseNodeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},
    {"static std::unique_ptr< BaseNodeData > ::genesis::tree::BaseNodeData::create ()", "Create a new instance of this class. Use instead of default constructor."},
    {"std::unique_ptr< BaseNodeData > ::genesis::tree::BaseNodeData::recreate () const", "Polymorphically create a default-constructed instance of this class with the same derived type as it was called on."},

    // Class Bipartition

    // Class CircularLayout

    // Class ColorWriterPlugin
    {"void ::genesis::tree::ColorWriterPlugin::edge_colors (std::vector< utils::Color > const & color_vector)", "Set the edge colors that shall be written to the output.\n\nIf this function is called with a vector of size > 0, the edges in the output will be colored according to the values given as a parameter. The vector then needs to contain as many elements as the tree has edges. The elements need to be indexed using the edge.index() value.If this function is called with an empty vector, the color printing is reset to not print the edge colors that might have been set before."},
    {"std::vector< utils::Color > const & ::genesis::tree::ColorWriterPlugin::edge_colors () const", "Return the edge colors that are currently set."},
    {"void ::genesis::tree::ColorWriterPlugin::enable_color (bool value)", "Set whether colors tags are written to the output."},
    {"bool ::genesis::tree::ColorWriterPlugin::enable_color () const", "Returns whether colors tags are written to the output."},
    {"void ::genesis::tree::ColorWriterPlugin::ignored_color (utils::Color value)", "Set a color that is used as marker for partially disabling the output of color tags.\n\nAll edges that have set a color equal to the ignored color will produce no color tag output. This is thus something like magic pink, where all parts of an image are rendered transparent when originially colored in pink.By default, we do not use an ignored color. If this function is called (which sets a color), also use_ignored_color() is set to true, so that the color is actually used."},
    {"utils::Color ::genesis::tree::ColorWriterPlugin::ignored_color () const", "Return the currently set ignored color. See the setter for more information."},
    {"void ::genesis::tree::ColorWriterPlugin::use_ignored_color (bool value)", "Set whether to use the ignored_color().\n\nIf this option is set to true, the color that is set via ignored_color() is not written as a color attribute to the output format."},
    {"bool ::genesis::tree::ColorWriterPlugin::use_ignored_color () const", "Return whether currently an ignored color is used."},

    // Class CommonEdgeData
    {"std::unique_ptr< BaseEdgeData > ::genesis::tree::CommonEdgeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},
    {"std::unique_ptr< BaseEdgeData > ::genesis::tree::CommonEdgeData::recreate () const", "Polymorphically create a default-constructed instance of this class with the same derived type as it was called on."},

    // Class CommonNodeData
    {"std::unique_ptr< BaseNodeData > ::genesis::tree::CommonNodeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},
    {"std::unique_ptr< BaseNodeData > ::genesis::tree::CommonNodeData::recreate () const", "Polymorphically create a default-constructed instance of this class with the same derived type as it was called on."},

    // Class CommonTreeNewickReader

    // Class CommonTreeNewickReaderPlugin
    {"double ::genesis::tree::CommonTreeNewickReaderPlugin::default_branch_length () const", "Get the default branch length used when there is none given for an edge."},
    {"self_type & ::genesis::tree::CommonTreeNewickReaderPlugin::default_branch_length (double value)", "Set the default branch length used when there is none given for an edge.\n\nBy default, this is 1.0."},
    {"std::string const & ::genesis::tree::CommonTreeNewickReaderPlugin::default_inner_name () const", "Get the default named used when there is none given for an inner node."},
    {"self_type & ::genesis::tree::CommonTreeNewickReaderPlugin::default_inner_name (std::string const & value)", "Set the default named used when there is none given for an inner node."},
    {"std::string const & ::genesis::tree::CommonTreeNewickReaderPlugin::default_leaf_name () const", "Get the default named used when there is none given for a leaf node."},
    {"self_type & ::genesis::tree::CommonTreeNewickReaderPlugin::default_leaf_name (std::string const & value)", "Set the default named used when there is none given for a leaf node."},
    {"std::string const & ::genesis::tree::CommonTreeNewickReaderPlugin::default_root_name () const", "Get the default named used when there is none given for the root node."},
    {"self_type & ::genesis::tree::CommonTreeNewickReaderPlugin::default_root_name (std::string const & value)", "Set the default named used when there is none given for the root node."},
    {"bool ::genesis::tree::CommonTreeNewickReaderPlugin::replace_name_underscores () const", "Return whether currently this plugin replaces underscores with spaces.\n\nSee the setter replace_name_underscores( bool ) for details."},
    {"self_type & ::genesis::tree::CommonTreeNewickReaderPlugin::replace_name_underscores (bool value)", "Set whether to replace all underscores ('_') in names with spaces (' ').\n\nThis is demanded by the original definition of the Newick format, see http://evolution.genetics.washington.edu/phylip/newicktree.html However, because under most common circumstances, it is more confusing than helpful, we decided to deactivate this by default. Thus, the default for this setting is false."},
    {"self_type & ::genesis::tree::CommonTreeNewickReaderPlugin::set_default_names (std::string const & value)", "Shorthand to set the default names for leaf, inner and root node at once, to one value."},
    {"bool ::genesis::tree::CommonTreeNewickReaderPlugin::use_default_names () const", "Return whether currently default names are activated in this plugin.\n\nSee the setter use_default_names( bool ) for details."},
    {"self_type & ::genesis::tree::CommonTreeNewickReaderPlugin::use_default_names (bool value)", "Set whether to replace unnamed nodes with a default name.\n\nCommon is false. In this case, nodes without names in the Newick tree are simply unnamed, i.e., their name is the emptry string.If set to true, unnamed nodes are named using one of the default names:\nLeaf nodes are named using default_leaf_name().Inner nodes are named using default_inner_name().The root node is named using default_root_name().\nThese default names can be changed by using default_leaf_name( std::string const& ), default_inner_name( std::string const& ) and default_root_name( std::string const& ), or by using set_default_names( std::string const& ) to set all three at once."},

    // Class CommonTreeNewickWriter

    // Class CommonTreeNewickWriterPlugin
    {"int ::genesis::tree::CommonTreeNewickWriterPlugin::branch_length_precision () const", "Get the currently set maximum precision (in number of digits) used for printing the branch_length floating point numbers."},
    {"self_type & ::genesis::tree::CommonTreeNewickWriterPlugin::branch_length_precision (int value)", "Set the maximum precision (in number of digits) used for printing the branch_length floating point numbers.\n\nCommon is 6."},
    {"std::string const & ::genesis::tree::CommonTreeNewickWriterPlugin::default_inner_name () const", "Get the named used to filter out an inner node name."},
    {"self_type & ::genesis::tree::CommonTreeNewickWriterPlugin::default_inner_name (std::string const & value)", "Set the named used to filter out an inner node name."},
    {"std::string const & ::genesis::tree::CommonTreeNewickWriterPlugin::default_leaf_name () const", "Get the named used to filter out a leaf node name."},
    {"self_type & ::genesis::tree::CommonTreeNewickWriterPlugin::default_leaf_name (std::string const & value)", "Set the named used to filter out a leaf node name."},
    {"std::string const & ::genesis::tree::CommonTreeNewickWriterPlugin::default_root_name () const", "Get the named used to filter out the root node name."},
    {"self_type & ::genesis::tree::CommonTreeNewickWriterPlugin::default_root_name (std::string const & value)", "Set the named used to filter out the root node name."},
    {"self_type & ::genesis::tree::CommonTreeNewickWriterPlugin::enable_branch_lengths (bool value)", "Set whether to write branch lengths."},
    {"bool ::genesis::tree::CommonTreeNewickWriterPlugin::enable_branch_lengths () const", "Get whether currently any branch lengths are written."},
    {"self_type & ::genesis::tree::CommonTreeNewickWriterPlugin::enable_names (bool value)", "Set whether to write node names at all.\n\nIf disabled, no names are written for any node."},
    {"bool ::genesis::tree::CommonTreeNewickWriterPlugin::enable_names () const", "Get whether currently any node names are written at all."},
    {"bool ::genesis::tree::CommonTreeNewickWriterPlugin::replace_name_spaces () const", "Return whether currently this plugin replaces spaces with underscores.\n\nSee the setter replace_name_spaces( bool ) for details."},
    {"self_type & ::genesis::tree::CommonTreeNewickWriterPlugin::replace_name_spaces (bool value)", "Set whether to replace all spaces (' ') in names with underscores ('_').\n\nThis is the reverse of CommonTreeNewickReaderPlugin::replace_name_underscores(). It is activated by default, as it does no harm on already existing underscores. However, as spaces cannot be part of names in Newick, if it is deactivated (set to false), all names that contain spaces are instead wrapped in quotation marks by the NewickWriter, see NewickWriter::quotation_marks( std::string const& ) for details."},
    {"self_type & ::genesis::tree::CommonTreeNewickWriterPlugin::set_default_names (std::string const & value)", "Shorthand to set the default names for leaf, inner and root node at once, to one value."},
    {"bool ::genesis::tree::CommonTreeNewickWriterPlugin::use_default_names () const", "Return whether currently default names are activated in this plugin.\n\nSee the setter use_default_names( bool ) for details."},
    {"self_type & ::genesis::tree::CommonTreeNewickWriterPlugin::use_default_names (bool value)", "Set whether to replace default named nodes with an empty string.\n\nThis setting activates the \"reverse\" operation of CommonTreeNewickReaderPlugin::use_default_names( bool ). Thus, when the default names are set to the same values as in the reader plugin, reading a Newick tree and then writing it again should yield the same names in the Newick tree again.Common is false. In this case, all node names are written to the Newick tree, indepentenly of whether they match the default names.If set to true, a node that has one of the default names will result in an empty node name in the Newick tree:\nLeaf nodes with a name equal to default_leaf_name().Inner nodes with a name equal to default_inner_name().The root node with a name equal to default_root_name().\nThese default names can be changed by using default_leaf_name( std::string const& ), default_inner_name( std::string const& ) and default_root_name( std::string const& ), or by using set_default_names( std::string const& ) to set all three at once."},

    // Class CommonTreePhyloxmlWriter

    // Class CommonTreePhyloxmlWriterPlugin

    // Class IndexedAttributeTreeNewickReader

    // Class IndexedAttributeTreeNewickReaderPlugin
    {"self_type & ::genesis::tree::IndexedAttributeTreeNewickReaderPlugin::add_attribute (Source source, size_t index, Target target, std::string const & target_key)", "Store the Newick data at a given index in an AttributeTreeMap.\n\nConsider the exemplary Newick tree ((C,D)[0.1],(A,(B,X)[0.3])[0.2],E);\nIn this tree, Newick comments are used to store bootstrap support values. The values are always the first Newick comment of a node (if they occur), i.e. the comment with index 0.To store these values in the attributes map of the corresponding AttributeTreeEdgeData, we can use:IndexedAttributeTreeNewickReaderreader;\nreader.add_attribute(\nIndexedAttributeTreeNewickReader::Source::kComment,0,\nIndexedAttributeTreeNewickReader::Target::kEdge,\"bootstrap\"\n);\nautotree=reader.from_file(\"path/to/tree.newick\");\nThis stores the Newick comment (such as \"[0.1]\" in the example) with index 0 (the first one) at the corresponding Edge, using the key \"bootstrap\".The same can be done for Newick values and tags (see NewickBrokerElement for their description), and we can store them on the Node instead of the Edge.In cases where there is no corresponding index in the Newick element data, no data is added. For example, the Newick tree above does not contain any bootstrap support values for the leaf nodes. That means, the comments of the NewickBrokerElement is empty, so there is no index 0 in them. If you want to use a default value in such cases, use add_attribute( Source, size_t, Target, std::string const&, std::string const& ) instead.\n\nsource\n\n\nInput Newick element to take the data from. One of kComment, kValue or kTag. \n\n\n\nindex\n\n\nInput index of the element, e.g., 0, to select the first comment. \n\n\n\ntarget\n\n\nTarget Tree element to store the data at. Either kNode or kEdge. \n\n\n\ntarget_key\n\n\nTarget key to use for storing the data in the AttributeTreeMap of the Node or Edge, e.g., \"bootstrap\"."},
    {"self_type & ::genesis::tree::IndexedAttributeTreeNewickReaderPlugin::add_attribute (Source source, size_t index, Target target, std::string const & target_key, std::string const & default_value)", "Store the Newick data at a given index in an AttributeTreeMap, using a default value if there is no data at that index.\n\nThe function behaves the same as add_attribute( Source, size_t, Target, std::string const& ) in cases where the given index is found at a Newick element.However, in cases where there is no corresponding index in the Newick element data, this function uses a default value in the attribute map, insted of ingoring it.For example, the Newick tree ((C,D)[0.1],(A,(B,X)[0.3])[0.2],E);\ndoes not contain any bootstrap support values for the leaf nodes. That means, the comments of the NewickBrokerElement is empty, so there is no index 0 in them. In this case, the specified default value is used.\n\nsource\n\n\nInput Newick element to take the data from. One of kComment, kValue or kTag. \n\n\n\nindex\n\n\nInput index of the element, e.g., 0, to select the first comment. \n\n\n\ntarget\n\n\nTarget Tree element to store the data at. Either kNode or kEdge. \n\n\n\ntarget_key\n\n\nTarget key to use for storing the data in the AttributeTreeMap of the Node or Edge, e.g., \"bootstrap\". \n\n\n\ndefault_value\n\n\nDefault value for Newick elements where there is no corresponding index."},
    {"self_type & ::genesis::tree::IndexedAttributeTreeNewickReaderPlugin::add_catch_all (Source source, Target target, std::string const & target_key_prefix)", "Store all Newick data of a given source in an AttributeTreeMap.\n\nThis function allows to capture all Newick data of a given type (comment, value or tag) and store it at a Tree element (Node or Edge), using a given prefix and a sequential number.For example, given the Newick tree ((C,D)[inner_A],(A,(B,X)[inner_B])[inner_C],E);\nwe can store all comments at the tree Nodes usingIndexedAttributeTreeNewickReaderreader;\nreader.add_catch_all(\nIndexedAttributeTreeNewickReader::Source::kComment,\nIndexedAttributeTreeNewickReader::Target::kNode,\"comment_\"\n);\nautotree=reader.from_file(\"path/to/tree.newick\");\nThe resulting tree has attributes at the inner nodes, with the key comment_0 and the values inner_A, inner_B and inner_C, respectively.Remark: This will store all data at either the Nodes or Edges of the Tree. This can lead to problems if some of the data actually belongs to the other element (Edges or Nodes). In these cases, better set the capturing explicitly, using add_attribute().\n\nsource\n\n\nInput Newick element to take the data from. One of kComment, kValue or kTag. \n\n\n\ntarget\n\n\nTarget Tree element to store the data at. Either kNode or kEdge. \n\n\n\ntarget_key_prefix\n\n\nPrefix for the target key, to which a sequential number according to the index of the data is appended."},
    {"self_type & ::genesis::tree::IndexedAttributeTreeNewickReaderPlugin::add_catch_all (Target target)", "Store all Newick data in an AttributeTreeMap.\n\nThis is a simplification of add_catch_all(), which adds three catch-alls for the Newick comments, values and tags at once. It uses comment_, value_ and tag_ as key prefix, respectively. The function is meant for the most general use case, where we want to capture all Newick data and store it in an AttributeTree.\n\ntarget\n\n\nOptional parameter that can be used to specify where to store the data; default is to store it at the Tree Nodes."},
    {"void ::genesis::tree::IndexedAttributeTreeNewickReaderPlugin::clear ()", "Reset all settings to the default, i.e., delete all attribute settings."},

    // Class IteratorEulertour

    // Class IteratorLevelorder

    // Class IteratorNodeLinks

    // Class IteratorPath
    {"bool ::genesis::tree::IteratorPath::is_last_common_ancestor () const", "Return whether the current iterator position (node) is the last common ancestor of the two start and finish nodes.\n\nThis is useful in many cases:\nFind the LCA (obviously).Check when the path is moving away from the root again.Iterating edges instead of nodes.\nThe last bullet point may need some explanation:The iterator visits all nodes between the start and the finish (both included). On the path between them, there is however one edge fewer than the number of visited nodes. That means, if you want to visit each edge on the path between two nodes (instead of each node), you need a way to spot this superflous edge. This function indicates the edge that needs to be skipped in this case."},
    {"bool ::genesis::tree::IteratorPath::is_lca () const", "Alias for is_last_common_ancestor(). See there for more information."},

    // Class IteratorPathSet

    // Class IteratorPostorder

    // Class IteratorPreorder

    // Class KeyedAttributeTreeNewickReader

    // Class KeyedAttributeTreeNewickReaderPlugin
    {"self_type & ::genesis::tree::KeyedAttributeTreeNewickReaderPlugin::add_attribute (std::string const & key, Target target)", "Store values of a key at a target (i.e., Node or Edge).\n\nFor example, using the Newick tree ((C,D)[&!color=#009966],(A,(B,X)[&bs=82,!color=#137693])[&bs=70],E);\nwe can read the bootstrap support values (bs) and store them at the Edges like this:KeyedAttributeTreeNewickReaderreader;\nreader.add_attribute(\"bs\",KeyedAttributeTreeNewickReader::Target::kEdge);\nautotree=reader.from_file(\"path/to/tree.newick\");\nThis is a simple form which uses the same key for the source (Newick comment) and target (Node or Edge), and does not use a default value, i.e., if the key is not found, no value is added to the target.See add_attribute( source_key, target, target_key ) for more details.\n\nkey\n\n\nKey of a key-value-pair. If found in the source Newick comment, the value is added to the target Node or Edge, using the same key. \n\n\n\ntarget\n\n\nTarget Tree element to store the data at. Either kNode or kEdge."},
    {"self_type & ::genesis::tree::KeyedAttributeTreeNewickReaderPlugin::add_attribute (std::string const & source_key, Target target, std::string const & target_key)", "Store values of a source_key at a target (i.e., Node or Edge), using the target_key.\n\nUsing this form, the source and target key can differ. For example, using the Newick tree ((C,D)[&!color=#009966],(A,(B,X)[&bs=82,!color=#137693])[&bs=70],E);\nwe can read the color values (!color) like this:KeyedAttributeTreeNewickReaderreader;\nreader.add_attribute(\"!color\",KeyedAttributeTreeNewickReader::Target::kEdge,\"color\");\nautotree=reader.from_file(\"path/to/tree.newick\");\nwhich stores the values under the key color (without the leading exclamation mark).The function does not use default values. I.e., if the key is not found in the source comment, no value is added to the target.Also, see add_attribute( source_key, target, target_key, default_value ) for details.\n\nsource_key\n\n\nSource key of a key-value-pair. If found in the source Newick comment, the value is added to the target Node or Edge, using the target_key. \n\n\n\ntarget\n\n\nTarget Tree element to store the data at. Either kNode or kEdge. \n\n\n\ntarget_key\n\n\nTarget key, used to store a value, if the source_key is found in the Newick comment."},
    {"self_type & ::genesis::tree::KeyedAttributeTreeNewickReaderPlugin::add_attribute (std::string const & source_key, Target target, std::string const & target_key, std::string const & default_value)", "Store values of a source_key at a target (i.e., Node or Edge), using the target_key, and a default_value, if the key is not found in the source.\n\nThis is the most flexible form of this function. It is similar to add_attribute( source_key, target, target_key ), but additionally used a default value, if the key is not found in the source Newick comment.\n\nsource_key\n\n\nSource key of a key-value-pair. If found in the source Newick comment, the value is added to the target Node or Edge, using the target_key. \n\n\n\ntarget\n\n\nTarget Tree element to store the data at. Either kNode or kEdge. \n\n\n\ntarget_key\n\n\nTarget key, used to store a value at the target Node or Edge. \n\n\n\ndefault_value\n\n\nDefault value to be used if the source Newick comment does not contain the source_key."},
    {"self_type & ::genesis::tree::KeyedAttributeTreeNewickReaderPlugin::add_catch_all (Target target)", "Store all key-value-pairs of the Newick data in an AttributeTree.\n\nThis function allows to capture all Newick comment data in key-value-form and store it at a Tree element (Node or Edge).For example, given the Newick tree ((C,D)[&!color=#009966],(A,(B,X)[&bs=82,!color=#137693])[&bs=70],E);\nwe can store all data at the tree Edges usingKeyedAttributeTreeNewickReaderreader;\nreader.add_catch_all(KeyedAttributeTreeNewickReader::Target::kEdge);\nautotree=reader.from_file(\"path/to/tree.newick\");\nRemark: This will store all data at either the Nodes or Edges of the Tree. This can lead to problems if some of the data actually belongs to the other element (Edges or Nodes). In these cases, better set the captureing explicitly, using add_attribute()."},
    {"self_type & ::genesis::tree::KeyedAttributeTreeNewickReaderPlugin::add_nhx_attributes ()", "Add typical attributes of the NHX format, and set the appropriate delimiters.\n\nThe New Hampshire eXtended (NHX) format is an extension of the Newick format that uses specially formatted Newick comments to store additional data for the nodes and edges of a tree. See for example https://sites.google.com/site/cmzmasek/home/software/forester/nhx and https://home.cc.umanitoba.ca/~psgendb/doc/atv/NHX.pdf for details.This function adds capturing for the following keys:\nKey Target Description  \n\nAC Node sequence accession \n\nB Edge confidence value for parent branch \n\nCo Node collapse this node when drawing the tree (default is not to collapse) \n\nD Node duplication event \n\nE Node EC number \n\nGN Node gene name \n\nL Edge log likelihood value on parent branch \n\nO Node orthologous to this external node \n\nS Node species name \n\nSO Node \"super orthologous\" (no duplications on paths) \n\nSw Edge placing a subtree on the parent branch of this node makes the tree significantly worse according to Kishino/Hasegawa test (or similar) \n\nT Node taxonomy ID \n\nIf you need other NHX keys, want to use different keys for the target, or want to use default values for keys that are not present in the Newick data, please use the normal add_attribute() functions or add_catch_all() instead. This is only meant to be a very basic simplification for supporting NHX."},
    {"self_type & ::genesis::tree::KeyedAttributeTreeNewickReaderPlugin::assigner (std::string const & value)", "Set the assign symbol between a key and its value.\n\nDefault is =, as used in the examples of this class."},
    {"std::string ::genesis::tree::KeyedAttributeTreeNewickReaderPlugin::assigner () const", "Get the currently set assign symbol between a key and its value."},
    {"void ::genesis::tree::KeyedAttributeTreeNewickReaderPlugin::clear ()", "Reset all settings to the default and delete all attribute settings."},
    {"self_type & ::genesis::tree::KeyedAttributeTreeNewickReaderPlugin::prefix (std::string const & value)", "Set the prefix to look for in Newick comments.\n\nDefault is &, as used in the examples of this class."},
    {"std::string ::genesis::tree::KeyedAttributeTreeNewickReaderPlugin::prefix () const", "Get the currently set prefix to look for in Newick comments."},
    {"self_type & ::genesis::tree::KeyedAttributeTreeNewickReaderPlugin::separator (std::string const & value)", "Set the separator between key-value-pairs.\n\nDefault is ,, as used in the examples of this class."},
    {"std::string ::genesis::tree::KeyedAttributeTreeNewickReaderPlugin::separator () const", "Get the currently set separator between key-value-pairs."},
    {"self_type & ::genesis::tree::KeyedAttributeTreeNewickReaderPlugin::set_delimiters (std::string const & prefix, std::string const & separator, std::string const & assigner=\"=\")", "Set the delimiters for key-value-pairs.\n\nThis function is a shortcut to set the prefix(), separator() and assigner() at once."},
    {"self_type & ::genesis::tree::KeyedAttributeTreeNewickReaderPlugin::set_nhx_delimiters ()", "Set the delimiters to the format used by NHX.\n\nThese are\nPrefix: &&NHXSeparator: :Assigner: =\nSee add_nhx_attributes() for details on the NHX format."},
    {"self_type & ::genesis::tree::KeyedAttributeTreeNewickReaderPlugin::trim (bool value)", "Set whether to trim keys and values before storing them in the Tree.\n\nDefault is true."},
    {"bool ::genesis::tree::KeyedAttributeTreeNewickReaderPlugin::trim () const", "Get whether to trim keys and values before storing them in the Tree."},

    // Class LayoutBase

    // Class LayoutEdgeData
    {"std::unique_ptr< BaseEdgeData > ::genesis::tree::LayoutEdgeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},
    {"std::unique_ptr< BaseEdgeData > ::genesis::tree::LayoutEdgeData::recreate () const", "Polymorphically create a default-constructed instance of this class with the same derived type as it was called on."},

    // Class LayoutNodeData
    {"std::unique_ptr< BaseNodeData > ::genesis::tree::LayoutNodeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},
    {"std::unique_ptr< BaseNodeData > ::genesis::tree::LayoutNodeData::recreate () const", "Polymorphically create a default-constructed instance of this class with the same derived type as it was called on."},

    // Class LayoutParameters

    // Class LcaLookup

    // Class MassTreeEdgeData
    {"std::unique_ptr< BaseEdgeData > ::genesis::tree::MassTreeEdgeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},
    {"std::unique_ptr< BaseEdgeData > ::genesis::tree::MassTreeEdgeData::recreate () const", "Polymorphically create a default-constructed instance of this class with the same derived type as it was called on."},

    // Class MassTreeKmeans

    // Class MassTreeNodeData
    {"std::unique_ptr< BaseNodeData > ::genesis::tree::MassTreeNodeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},
    {"std::unique_ptr< BaseNodeData > ::genesis::tree::MassTreeNodeData::recreate () const", "Polymorphically create a default-constructed instance of this class with the same derived type as it was called on."},

    // Class NewickBroker
    {"void ::genesis::tree::NewickBroker::assign_ranks () const", "Iterate over the tree and assign ranks (= number of immediate children) to all nodes.\n\nThis function is for example needed to check whether it is a bifurcating/binary tree, or to check how many leaves and inner nodes the tree has. Thus, it is usually called after the broker is filled with data."},
    {"NewickBrokerElement & ::genesis::tree::NewickBroker::at (std::size_t index)", "Provides index based array access to the nodes, doing a boundary check first.\n\nIn out of bounds cases, an exception is thrown."},
    {"NewickBrokerElement & ::genesis::tree::NewickBroker::bottom ()", "Returns a reference to the bottom node of the tree stack.\n\nCalling this function on an empty() broker causes undefined behavior."},
    {"const_iterator ::genesis::tree::NewickBroker::cbegin () const", "Const version of begin()."},
    {"const_iterator ::genesis::tree::NewickBroker::cend () const", "Const version of end()."},
    {"void ::genesis::tree::NewickBroker::clear ()", "Deletes all nodes from the broker."},
    {"const_reverse_iterator ::genesis::tree::NewickBroker::crbegin ()", "Const version of rbegin()."},
    {"const_reverse_iterator ::genesis::tree::NewickBroker::crend ()", "Const version of rend()."},
    {"std::string ::genesis::tree::NewickBroker::dump () const", "Return a readable string representation of the elements of the NewickBroker."},
    {"bool ::genesis::tree::NewickBroker::empty () const", "Returns whether the stack is empty."},
    {"int ::genesis::tree::NewickBroker::leaf_count () const", "Returns the number of leaf nodes in the tree. assign_ranks() has to be called first."},
    {"int ::genesis::tree::NewickBroker::max_rank () const", "Returns the highest rank of the nodes in the tree. assign_ranks() has to be called first."},
    {"int ::genesis::tree::NewickBroker::node_count () const", "Alias for size()."},
    {"reverse_iterator ::genesis::tree::NewickBroker::rbegin ()", "Returns a reverse iterator to the nodes on the stack."},
    {"const_reverse_iterator ::genesis::tree::NewickBroker::rbegin () const", "Returns a reverse iterator to the nodes on the stack for const objects."},
    {"reverse_iterator ::genesis::tree::NewickBroker::rend ()", "Reverse version of end()."},
    {"const_reverse_iterator ::genesis::tree::NewickBroker::rend () const", "Reverse version of end() for const objects."},
    {"size_t ::genesis::tree::NewickBroker::size () const", "Returns the size of the stack, i.e. the number of nodes stored in the broker."},
    {"NewickBrokerElement & ::genesis::tree::NewickBroker::top ()", "Returns a reference to the top node of the tree stack.\n\nUsually, the top element is the root of the tree (i.e., it has depth zero). Only when called during the broker is being filled with nodes (for example, while parsing a Newick tree), the top element is not the root.Calling this function on an empty() broker causes undefined behavior."},
    {"bool ::genesis::tree::NewickBroker::validate () const", "Returns true iff the tree is valid. assign_ranks() has to be called first.\n\nA valid tree in a NewickBroker has to fullfill those criteria:\nThe depth (nesting level) of the nodes cannot increase more than one level between nodes, as this would imply a non-existing node with a depth in between. However, it can arbitrarily decrease, as this simply means the end of a subtree.Furthermore, rank 1 is not valid, as this represents a node that is not furcating in any way. %"},

    // Class NewickBrokerElement
    {"bool ::genesis::tree::NewickBrokerElement::is_inner () const", "Return whether this is an inner node, i.e., not a leaf node."},
    {"bool ::genesis::tree::NewickBrokerElement::is_leaf () const", "Return whether this is a leaf node."},
    {"bool ::genesis::tree::NewickBrokerElement::is_root () const", "Return whether this is the root node of the tree."},
    {"int ::genesis::tree::NewickBrokerElement::rank () const", "Returns the rank (number of immediate children) of this node.\n\nNewickBroker::assign_ranks() has to be called before using this function. Otherwise, this function will throw an std::logic_error."},

    // Class NewickColorWriterPlugin
    {"void ::genesis::tree::NewickColorWriterPlugin::color_tag_prefix (std::string prefix)", "Set the prefix string that is used within the Newick comment before the actual color value.\n\nBy default, this string is set to &!color=, which is for example used by FigTree to mark color in trees. This will result in a Newick comment like [&!color=#c0ffee]."},
    {"std::string ::genesis::tree::NewickColorWriterPlugin::color_tag_prefix () const", "Get the currently set prefix string. See the setter for more information."},
    {"void ::genesis::tree::NewickColorWriterPlugin::color_tag_suffix (std::string suffix)", "Set the suffix string that is used within the Newick comment after the actual color value.\n\nBy default, this string is empty. See the setter color_tag_prefix() for more information."},
    {"std::string ::genesis::tree::NewickColorWriterPlugin::color_tag_suffix () const", "Get the currently set suffix string. See the setter for more information."},

    // Class NewickInputIterator
    {"NewickReader & ::genesis::tree::NewickInputIterator::reader ()", "Return the NewickReader used for this iterator.\n\nUse this to change the reading behaviour of the iterator. See NewickReader for details."},

    // Class NewickReader
    {"NewickReader & ::genesis::tree::NewickReader::enable_tags (bool value)", "Set whether Newick tags are enabled for reading.\n\nNewick tags are an inofficial extension to the Newick format. They consist of values in curly braces, for example {value} and can occur where node labels are allowed in Newick.For example: (( A{0}, B{1} )D{3}, C{4} )R{5};\nThus, they are used similarly to the way Newick comments are often (mis-)used to annotate a tree with additional information about the nodes and edges.They are for example used in the jplace format, see placement::JplaceReader for details.If this option is set to true, such tags are stored in NewickBrokerElement::tags. If it is false (default), any string that has the form of Newick tags will simply be treated as part of the node name."},
    {"bool ::genesis::tree::NewickReader::enable_tags () const", "Return whether currently Newick tags are enabled.\n\nSee enable_tags( bool ) for details."},
    {"Tree ::genesis::tree::NewickReader::from_file (std::string const & filename) const", "Read a Tree from a file containing a Newick tree."},
    {"void ::genesis::tree::NewickReader::from_file (std::string const & filename, TreeSet & tree_set, std::string const & default_name=\"\") const", "Add Trees to a TreeSet from a file containing a list of Newick trees.\n\nSee from_string() for more information."},
    {"void ::genesis::tree::NewickReader::from_files (std::vector< std::string > const & filenames, TreeSet & tree_set) const", "Fill a TreeSet from a list of files containing Newick trees.\n\nThis function can for example be used with the output of utils::dir_list_files()."},
    {"Tree ::genesis::tree::NewickReader::from_stream (std::istream & input_stream) const", "Read a Tree from an input stream containing a Newick tree."},
    {"void ::genesis::tree::NewickReader::from_stream (std::istream & input_stream, TreeSet & tree_set, std::string const & default_name=\"\") const", "Add Trees to a TreeSet from an input stream containing a list of Newick trees.\n\nSee from_string() for more information."},
    {"Tree ::genesis::tree::NewickReader::from_string (std::string const & tree_string) const", "Read a Tree from a string containing a Newick tree."},
    {"void ::genesis::tree::NewickReader::from_string (std::string const & tree_string, TreeSet & tree_set, std::string const & default_name=\"\") const", "Add Trees to a TreeSet from a string containing a list of Newick trees.\n\nThese trees can either be named or unnamed, using this syntax: Tree_A = (...);\n'Tree B'=(...);\n(...);\nwhere the first two lines are named trees and the third line is an unnamed tree. The trees do not have to be on distinct lines of the input, as whitespaces are completely stripped anyway. However, they are required to end with a semicolon ;.In case of unnamed trees, a default_name can be provided, which will be appended by a counter that counts up all unnamed trees. For example, default_name == \"tree_\" results in trees named \"tree_0\", \"tree_1\" etc. If no default name is given, the trees will simply be named using the counter itself.The Trees are simply added to the TreeSet. That means, Trees that already exist in the TreeSet are kept. Thus, this function can be used to add additional Trees to the set."},
    {"void ::genesis::tree::NewickReader::from_strings (std::vector< std::string > const & tree_strings, TreeSet & tree_set, std::string const & default_name=\"\") const", "Fill a TreeSet from a list of strings containing Newick trees."},
    {"void ::genesis::tree::NewickReader::parse_multiple_trees (utils::InputStream & input_stream, TreeSet & tree_set, std::string const & default_name) const", "Parse until the end of the stream and add all Trees to the TreeSet."},
    {"std::pair< std::string, Tree > ::genesis::tree::NewickReader::parse_named_tree (utils::InputStream & input_stream) const", "Parse one named tree, i.e., a tree as described here."},
    {"Tree ::genesis::tree::NewickReader::parse_single_tree (utils::InputStream & input_stream) const", "Parse a single tree. Depending on stop_at_semicolon(), stop after the semicolon or continue until the end of the input, checking if there are only comments."},
    {"NewickReader & ::genesis::tree::NewickReader::stop_at_semicolon (bool value)", "Set whether reading a single tree stops after the semicolon that finishes a Newick tree.\n\nWhen reading a single Newick tree, it is possible that there is input after the semicolon. If this input is just Newick comments, this is allowed. However, other input might indicate an error in the tree. Using this function, the behaviour of the reading can be controlled.If set to false (default), reading continues until the end of the input is reached. This is mostly wanted when reading e.g., a complete file. If then input contains invalid data (non-comments) after the semicolon, an execption is thrown.If set to true, reading stops after the semicolon. This is useful if the Newick tree is part of some other file, e.g., Nexus. In this case, we simply want to stop and continue parsing the rest of the input as Nexus data."},
    {"bool ::genesis::tree::NewickReader::stop_at_semicolon () const", "Return whether currently reading stops after the semicolon that finishes a Newick tree.\n\nSee stop_at_semicolon( bool ) for details."},

    // Class NewickWriter
    {"void ::genesis::tree::NewickWriter::broker_to_file (NewickBroker const & broker, std::string const & filename) const", "Writes a NewickBroker to a file in Newick format."},
    {"void ::genesis::tree::NewickWriter::broker_to_stream (NewickBroker const & broker, std::ostream & os) const", "Write a NewickBroker to a stream, in Newick format."},
    {"void ::genesis::tree::NewickWriter::broker_to_string (NewickBroker const & broker, std::string & ts) const", "Gives a Newick string representation of the tree."},
    {"std::string ::genesis::tree::NewickWriter::broker_to_string (NewickBroker const & broker) const", "Returns a Newick string representation of the tree."},
    {"NewickWriter & ::genesis::tree::NewickWriter::force_quotation_marks (bool value)", "If set to true, all names are wrapped in quotation marks, regardless of whether the name contains any characters that need to be wrapped.\n\nDefault is false. This setting can be used to ensure that all names have quotation marks, which is a requirement for certain other parser. See also quotation_marks( char ) to set the type of quotation mark."},
    {"bool ::genesis::tree::NewickWriter::force_quotation_marks () const", "Get whether all names are wrapped in quotation marks.\n\nforce_quotation_marks( bool )"},
    {"NewickWriter & ::genesis::tree::NewickWriter::quotation_marks (char value)", "Set the type of quotation marks used for node names that contain special characters.\n\nAccording to http://evolution.genetics.washington.edu/phylip/newicktree.html,\"A name can be any string of printable characters except blanks, colons, semicolons,\nparentheses, and square brackets.\"They forgot to mention commas in that list. One more reason to be suspicious of the Newick format. Anyway, whenever one of these characters (including commas) occurs in the name of a node (see NewickBrokerElement::name), the writer wraps the whole name in quotation markes. This is not officially in the standard, but common practice.Remark: When using a CommonTreeNewickWriterPlugin (or a CommonTreeNewickWriter, as it internally uses the plugin), you can use its setting replace_name_spaces() in order to replace any spaces in node nams into underscores.This function sets the kind of quotation marks used for wrapping such names. Common are double quotation marks ('\"'), which seem to be understood by many other programs that work with Newick trees.We currently do not support a function to deactivate quotation marks - they are used whenever necessary, for safety reasons. Otherwise, we'd end up with invalid trees anyway. Thus, in order to get a Newick tree without any quotation marks, make sure that your node names do not contain any of the listed characters.Lastly, if write_tags() is true, names with curly braces in them ('{}') are also wrapped in quotation marks, as those are used for tags."},
    {"char ::genesis::tree::NewickWriter::quotation_marks () const", "Get the currently set type of quotation marks used for node names.\n\nSee quotation_marks( char ) for details."},
    {"void ::genesis::tree::NewickWriter::to_file (Tree const & tree, std::string const & filename) const", "Writes the tree to a file in Newick format.\n\nIf the file cannot be written to, the function throws an exception. Also, by default, if the file already exists, an exception is thrown. See Options::allow_file_overwriting() to change this behaviour."},
    {"void ::genesis::tree::NewickWriter::to_stream (Tree const & tree, std::ostream & os) const", "Write a Tree to a stream, in Newick format."},
    {"void ::genesis::tree::NewickWriter::to_string (Tree const & tree, std::string & ts) const", "Gives a Newick string representation of the tree."},
    {"std::string ::genesis::tree::NewickWriter::to_string (Tree const & tree) const", "Returns a Newick string representation of the tree."},
    {"NewickBroker ::genesis::tree::NewickWriter::tree_to_broker (Tree const & tree) const", "Transform the information of the tree into a NewickBroker object."},
    {"NewickWriter & ::genesis::tree::NewickWriter::write_comments (bool value)", "Set whether to write Newick comments (e.g., some forms of bootstrap values).\n\nDefault is true. This setting can be used to override any comments that might be set by a plugin."},
    {"bool ::genesis::tree::NewickWriter::write_comments () const", "Get whether Newick comments (e.g., some forms of bootstrap values) are written.\n\nwrite_comments( bool )"},
    {"NewickWriter & ::genesis::tree::NewickWriter::write_names (bool value)", "Set whether to write Newick node names.\n\nDefault is true. This setting can be used to override any names that might be set by a plugin."},
    {"bool ::genesis::tree::NewickWriter::write_names () const", "Get whether Newick node names are written.\n\nwrite_names( bool )"},
    {"NewickWriter & ::genesis::tree::NewickWriter::write_tags (bool value)", "Set whether to write Newick tags (e.g., for jplace files).\n\nDefault is true. This setting can be used to override any tags that might be set by a plugin. See NewickReader::enable_tags( bool ) for details on the inofficial Newick tags extension."},
    {"bool ::genesis::tree::NewickWriter::write_tags () const", "Get whether Newick tags (e.g., for jplace files) are written.\n\nwrite_tags( bool )"},
    {"NewickWriter & ::genesis::tree::NewickWriter::write_values (bool value)", "Set whether to write Newick values (e.g., branch lengths).\n\nDefault is true. This setting can be used to override any values that might be set by a plugin."},
    {"bool ::genesis::tree::NewickWriter::write_values () const", "Get whether Newick values (e.g., branch lengths) are written.\n\nwrite_values( bool )"},

    // Class PhyloxmlColorWriterPlugin

    // Class PhyloxmlWriter
    {"void ::genesis::tree::PhyloxmlWriter::to_document (const Tree & tree, utils::XmlDocument & xml) const", "Store the information of the tree into an Phyloxml-formatted XmlDocument."},
    {"void ::genesis::tree::PhyloxmlWriter::to_file (const Tree & tree, const std::string filename) const", "Writes the tree to a file in Phyloxml format.\n\nIf the file cannot be written to, the function throws an exception. Also, by default, if the file already exists, an exception is thrown. See Options::allow_file_overwriting() to change this behaviour."},
    {"void ::genesis::tree::PhyloxmlWriter::to_string (const Tree & tree, std::string & ts) const", "Gives a Phyloxml string representation of the tree."},
    {"std::string ::genesis::tree::PhyloxmlWriter::to_string (const Tree & tree) const", "Return a Phyloxml string representation of the tree."},

    // Class PrinterCompact
    {"PrinterCompact & ::genesis::tree::PrinterCompact::limit (long value)", "Set the line limit.\n\nIf set to a negative value, the full tree is printed. For any value greater than 0, only this many lines are printed, following a preorder traversal of the tree. If the tree contains more nodes than being printed, an additional line with ellipsis is printed, to indicate this fact."},
    {"long ::genesis::tree::PrinterCompact::limit () const", "Get the current line limit.\n\nSee limit( long ) for details."},
    {"void ::genesis::tree::PrinterCompact::print (std::ostream & out, Tree const & tree, std::function< std::string(TreeNode const &node, TreeEdge const &edge)> const print_line)", "Print a compact representation of a Tree to an output stream, using a given function for output of the Node and Edge data.\n\nThe print_line function parameter is used to customize the output per printed line: The function takes the current TreeNode and TreeEdge, and returns the desired string representation for that line. See the implementation of print( Tree const& ) for an example."},
    {"std::string ::genesis::tree::PrinterCompact::print (Tree const & tree, std::function< std::string(TreeNode const &node, TreeEdge const &edge)> const print_line)", "Print a compact representation of a Tree to a std::string, using a given function for output of the Node and Edge data.\n\nSee print() for details on the print_line function parameter."},
    {"std::string ::genesis::tree::PrinterCompact::print (Tree const & tree)", "Print a compact representation of a Tree to a std::string, for CommonTrees.\n\nThe function casts the node and edge data to CommonNodeData and CommonEdgeData, and, if successfull, prints the node name and branch length for each line.If the data is not actually default data, the nodes are printed without any text, i.e., only the topology of the Tree via lines is shown."},

    // Class PrinterDetailed

    // Class PrinterTable

    // Class RectangularLayout

    // Class SquashClustering
    {"void ::genesis::tree::SquashClustering::clear ()", "Clear the clusters() and mergers() data."},
    {"void ::genesis::tree::SquashClustering::run (std::vector< MassTree > && trees)", "Perfom Squash Clustering.\n\nSee the guppy documentation and the corresponding paper for details on this algorithm.The funciton takes MassTrees as input, which are consumed. The optional parameter p is used as exponent to calculate the earth_movers_distance(). See there for details."},
    {"std::string ::genesis::tree::SquashClustering::tree_string (std::vector< std::string > const & labels) const", "Build a Newick-format tree for visualizing the result of a squash_clustering().\n\nThe resulting Tree is a tree of samples, i.e., each leaf node represents one MassTree that was used as input for the Squash Clustering. The labels vector needs to contain the labels for those tips, in the order of elements that was used for running squash_clustering()."},

    // Class Tree
    {"void ::genesis::tree::Tree::clear ()", "Deletes all data of the tree, including all links, nodes and edges.\n\nThis functions results in an empty tree."},
    {"Tree ::genesis::tree::Tree::clone_topology () const", "Return a Tree with the same topology, but without any data.\n\nAll data pointers of the nodes and edges of the returned tree are nullptr."},
    {"TreeEdge & ::genesis::tree::Tree::edge_at (size_t index)", "Return the TreeEdge at a certain index.\n\nIf the index is invalid, the functions throws an std::out_of_range exception."},
    {"TreeEdge const & ::genesis::tree::Tree::edge_at (size_t index) const", "Return the TreeEdge at a certain index.\n\nIf the index is invalid, the functions throws an std::out_of_range exception."},
    {"size_t ::genesis::tree::Tree::edge_count () const", "Return the number of TreeEdges of the Tree."},
    {"bool ::genesis::tree::Tree::empty () const", "Return whether the Tree is empty (i.e., has no nodes, edges and links)."},
    {"EdgeContainerType & ::genesis::tree::Tree::expose_edge_container ()", "Get the container that stores all TreeEdges of the Tree.\n\nThis function gives direct access to the underlying container for the Links. It is meant to be used by external functions that need to manupulate the Tree, e.g., for reading or re-rooting the tree, or for adding elements to it. Use with care!"},
    {"LinkContainerType & ::genesis::tree::Tree::expose_link_container ()", "Get the container that stores all TreeLinks of the Tree.\n\nThis function gives direct access to the underlying container for the Links. It is meant to be used by external functions that need to manupulate the Tree, e.g., for reading or re-rooting the tree, or for adding elements to it. Use with care!"},
    {"NodeContainerType & ::genesis::tree::Tree::expose_node_container ()", "Get the container that stores all TreeNodes of the Tree.\n\nThis function gives direct access to the underlying container for the Links. It is meant to be used by external functions that need to manupulate the Tree, e.g., for reading or re-rooting the tree, or for adding elements to it. Use with care!"},
    {"TreeLink & ::genesis::tree::Tree::link_at (size_t index)", "Return the TreeLink at a certain index.\n\nIf the index is invalid, the functions throws an std::out_of_range exception."},
    {"TreeLink const & ::genesis::tree::Tree::link_at (size_t index) const", "Return the TreeLink at a certain index.\n\nIf the index is invalid, the functions throws an std::out_of_range exception."},
    {"size_t ::genesis::tree::Tree::link_count () const", "Return the number of TreeLinks of the Tree."},
    {"TreeNode & ::genesis::tree::Tree::node_at (size_t index)", "Return the TreeNode at a certain index.\n\nIf the index is invalid, the functions throws an std::out_of_range exception."},
    {"TreeNode const & ::genesis::tree::Tree::node_at (size_t index) const", "Return the TreeNode at a certain index.\n\nIf the index is invalid, the functions throws an std::out_of_range exception."},
    {"size_t ::genesis::tree::Tree::node_count () const", "Return the number of TreeNodes of the Tree."},
    {"Tree & ::genesis::tree::Tree::reset_root_link_index (size_t val)", "Reset the index of the link that is considered to be the root of the Tree.\n\nThis function is meant for tree manipulation functions. Use with care!Caveat: This function simply sets the index, but does not change any other properties of the tree. Particularly the correct primary/secondary order of TreeEdges and primary links of TreeNodes needs to be maintained manually when using this function! Otherwise, we end up with an invalid Tree that breaks its invariants!"},
    {"TreeLink & ::genesis::tree::Tree::root_link ()", "Return the TreeLink at the current root of the Tree.\n\nIf the tree is empty(), the functions throws an std::out_of_range exception."},
    {"TreeLink const & ::genesis::tree::Tree::root_link () const", "Return the TreeLink at the current root of the Tree.\n\nIf the tree is empty(), the functions throws an std::out_of_range exception."},
    {"TreeNode & ::genesis::tree::Tree::root_node ()", "Return the TreeNode at the current root of the Tree.\n\nIf the tree is empty(), the functions throws an std::out_of_range exception."},
    {"TreeNode const & ::genesis::tree::Tree::root_node () const", "Return the TreeNode at the current root of the Tree.\n\nIf the tree is empty(), the functions throws an std::out_of_range exception."},
    {"void ::genesis::tree::Tree::swap (Tree & other)", "Swap."},

    // Class TreeEdge
    {"BaseEdgeData * ::genesis::tree::TreeEdge::data_ptr ()", "Return a pointer to the data.\n\nIn most cases, using data<>() is more convenient. However, in some cases, this function might be necessary."},
    {"BaseEdgeData const * ::genesis::tree::TreeEdge::data_ptr () const", "Return a const pointer to the data.\n\nIn most cases, using data<>() is more convenient. However, in some cases, this function might be necessary."},
    {"bool ::genesis::tree::TreeEdge::has_data () const", "Return true if the TreeEdge has a data object assigned to it."},
    {"size_t ::genesis::tree::TreeEdge::index () const", "Return the index of this Edge."},
    {"TreeLink & ::genesis::tree::TreeEdge::primary_link ()", "Return the TreeLink of this TreeEdge that points towards the root."},
    {"TreeLink const & ::genesis::tree::TreeEdge::primary_link () const", "Return the TreeLink of this TreeEdge that points towards the root."},
    {"TreeNode & ::genesis::tree::TreeEdge::primary_node ()", "Return the TreeNode of this TreeEdge that points towards the root."},
    {"TreeNode const & ::genesis::tree::TreeEdge::primary_node () const", "Return the TreeNode of this TreeEdge that points towards the root."},
    {"TreeEdge & ::genesis::tree::TreeEdge::reset_data (std::unique_ptr< BaseEdgeData > data)", "Reset the data pointer of this TreeEdge.\n\nUsing this function, a TreeEdge can be assigend new data. It is also possible to change the data type completely (as long as it derives from BaseEdgeData). Be however aware that many functions that work with Trees expect a certain data type. Thus, changing it might break those functions and lead to exceptions and other errors."},
    {"TreeEdge & ::genesis::tree::TreeEdge::reset_index (size_t val)", "Reset the internal index of this TreeEdge.\n\nThis is a helper function that needs to be used with care and only in cases where appropriate. The index is an invariant that needs to be kept, as it needs to match the index in the Tree container.This function exists to allow building and modifying a Tree without the need for many friend declarations. However, the function should rarely be needed outside of this context."},
    {"TreeEdge & ::genesis::tree::TreeEdge::reset_primary_link (TreeLink * val)", "Reset the internal pointer to the primary TreeLink of this TreeEdge.\n\nThis is a helper function that needs to be used with care and only in cases where appropriate.This function exists to allow building and modifying a Tree without the need for many friend declarations. However, the function should rarely be needed outside of this context."},
    {"TreeEdge & ::genesis::tree::TreeEdge::reset_secondary_link (TreeLink * val)", "Reset the internal pointer to the secondary TreeLink of this TreeEdge.\n\nThis is a helper function that needs to be used with care and only in cases where appropriate.This function exists to allow building and modifying a Tree without the need for many friend declarations. However, the function should rarely be needed outside of this context."},
    {"TreeLink & ::genesis::tree::TreeEdge::secondary_link ()", "Return the TreeLink of this TreeEdge that points away from the root."},
    {"TreeLink const & ::genesis::tree::TreeEdge::secondary_link () const", "Return the TreeLink of this TreeEdge that points away from the root."},
    {"TreeNode & ::genesis::tree::TreeEdge::secondary_node ()", "Return the TreeNode of this TreeEdge that points away from the root."},
    {"TreeNode const & ::genesis::tree::TreeEdge::secondary_node () const", "Return the TreeNode of this TreeEdge that points away from the root."},

    // Class TreeLink
    {"TreeEdge & ::genesis::tree::TreeLink::edge ()", "Return the TreeEdge of this TreeLink."},
    {"TreeEdge const & ::genesis::tree::TreeLink::edge () const", "Return the TreeEdge of this TreeLink."},
    {"size_t ::genesis::tree::TreeLink::index () const", "Return the index of this Link."},
    {"TreeLink & ::genesis::tree::TreeLink::next ()", "Return the next TreeLink within the TreeNode of this link."},
    {"TreeLink const & ::genesis::tree::TreeLink::next () const", "Return the next TreeLink within the TreeNode of this link."},
    {"TreeNode & ::genesis::tree::TreeLink::node ()", "Return the TreeNode of this TreeLink."},
    {"TreeNode const & ::genesis::tree::TreeLink::node () const", "Return the TreeNode of this TreeLink."},
    {"TreeLink & ::genesis::tree::TreeLink::outer ()", "Return the TreeLink of the adjacent TreeNode."},
    {"TreeLink const & ::genesis::tree::TreeLink::outer () const", "Return the TreeLink of the adjacent TreeNode."},
    {"TreeLink & ::genesis::tree::TreeLink::prev ()", "Return the previous TreeLink within the TreeNode of this link.\n\nThe previous link of a given link L is the one whose next-pointer is pointing to L. As this link first has to be found, this function is not as cheap as next()."},
    {"TreeLink const & ::genesis::tree::TreeLink::prev () const", "Return the previous TreeLink within the TreeNode of this link.\n\nThe previous link of a given link L is the one whose next-pointer is pointing to L. As this link first has to be found, this function is not as cheap as next()."},
    {"TreeLink & ::genesis::tree::TreeLink::reset_edge (TreeEdge * val)", "Reset the internal pointer to the TreeEdge of this TreeLink.\n\nThis is a helper function that needs to be used with care and only in cases where appropriate.This function exists to allow building and modifying a Tree without the need for many friend declarations. However, the function should rarely be needed outside of this context."},
    {"TreeLink & ::genesis::tree::TreeLink::reset_index (size_t val)", "Reset the internal index of this TreeLink.\n\nThis is a helper function that needs to be used with care and only in cases where appropriate. The index is an invariant that needs to be kept, as it needs to match the index in the Tree container.This function exists to allow building and modifying a Tree without the need for many friend declarations. However, the function should rarely be needed outside of this context."},
    {"TreeLink & ::genesis::tree::TreeLink::reset_next (TreeLink * val)", "Reset the internal pointer to the next TreeLink of this TreeLink.\n\nThis is a helper function that needs to be used with care and only in cases where appropriate.This function exists to allow building and modifying a Tree without the need for many friend declarations. However, the function should rarely be needed outside of this context."},
    {"TreeLink & ::genesis::tree::TreeLink::reset_node (TreeNode * val)", "Reset the internal pointer to the TreeNode of this TreeLink.\n\nThis is a helper function that needs to be used with care and only in cases where appropriate.This function exists to allow building and modifying a Tree without the need for many friend declarations. However, the function should rarely be needed outside of this context."},
    {"TreeLink & ::genesis::tree::TreeLink::reset_outer (TreeLink * val)", "Reset the internal pointer to the outer TreeLink of this TreeLink.\n\nThis is a helper function that needs to be used with care and only in cases where appropriate.This function exists to allow building and modifying a Tree without the need for many friend declarations. However, the function should rarely be needed outside of this context."},

    // Class TreeNode
    {"BaseNodeData * ::genesis::tree::TreeNode::data_ptr ()", "Return a pointer to the data.\n\nIn most cases, using data<>() is more convenient. However, in some cases, this function might be necessary."},
    {"BaseNodeData const * ::genesis::tree::TreeNode::data_ptr () const", "Return a const pointer to the data.\n\nIn most cases, using data<>() is more convenient. However, in some cases, this function might be necessary."},
    {"bool ::genesis::tree::TreeNode::has_data () const", "Return true if the TreeNode has a data object assigned to it."},
    {"size_t ::genesis::tree::TreeNode::index () const", "Return the index of this Node."},
    {"TreeLink & ::genesis::tree::TreeNode::link ()", "Return the TreeLink that points towards the root.\n\nThis is just an alias for primary_link(), that is shorter to use when needed frequently in an algorithm."},
    {"TreeLink const & ::genesis::tree::TreeNode::link () const", "Return the TreeLink that points towards the root.\n\nThis is just an alias for primary_link(), that is shorter to use when needed frequently in an algorithm."},
    {"TreeLink & ::genesis::tree::TreeNode::primary_link ()", "Return the TreeLink that points towards the root."},
    {"TreeLink const & ::genesis::tree::TreeNode::primary_link () const", "Return the TreeLink that points towards the root."},
    {"TreeNode & ::genesis::tree::TreeNode::reset_data (std::unique_ptr< BaseNodeData > data)", "Reset the data pointer of this TreeNode.\n\nUsing this function, a TreeNode can be assigend new data. It is also possible to change the data type completely (as long as it derives from BaseNodeData). Be however aware that many functions that work with trees expcet a certain data type. Thus, changing it might break those functions and lead to exceptions and other errors."},
    {"TreeNode & ::genesis::tree::TreeNode::reset_index (size_t val)", "Reset the internal index of this TreeNode.\n\nThis is a helper function that needs to be used with care and only in cases where appropriate. The index is an invariant that needs to be kept, as it needs to match the index in the Tree container.This function exists to allow building and modifying a Tree without the need for many friend declarations. However, the function should rarely be needed outside of this context."},
    {"TreeNode & ::genesis::tree::TreeNode::reset_primary_link (TreeLink * val)", "Reset the internal pointer to the TreeLink of this TreeNode.\n\nThis is a helper function that needs to be used with care and only in cases where appropriate.This function exists to allow building and modifying a Tree without the need for many friend declarations. However, the function should rarely be needed outside of this context."},

    // Class TreeSet
    {"void ::genesis::tree::TreeSet::add (std::string const & name, Tree const & tree)", "Add a Tree with a name to the TreeSet.\n\nThe Tree is copied."},
    {"void ::genesis::tree::TreeSet::clear ()", "Clear the TreeSet and destroy all contained Trees."},
    {"bool ::genesis::tree::TreeSet::empty () const", "Return whether the TreeSet is empty."},
    {"void ::genesis::tree::TreeSet::remove_at (size_t index)", "Remove the Tree at a certain index position.\n\nAs this function moves Trees in the container around, all iterators and pointers to the elements of this TreeSet are considered to be invalidated."},
    {"size_t ::genesis::tree::TreeSet::size () const", "Return the size of the TreeSet, i.e., the number of stored Trees."},

    // Class AttributeDescriptor

    // Class StackElement

    // Class AttributeDescriptor

    // Class Token

    // Class Cluster

    // Class Merger

    // Class NamedTree

    // Class ArrowOperatorProxy

    // Class BaseInputSource
    {"size_t ::genesis::utils::BaseInputSource::read (char * buffer, size_t size)", "Read size many bytes into the char buffer."},
    {"std::string ::genesis::utils::BaseInputSource::source_name () const", "Get a name of the input source. Mainly interesting for user output."},

    // Class Bitvector
    {"size_t ::genesis::utils::Bitvector::count () const", "Count the number of set bits in the Bitvector, that is, its Hamming weight."},
    {"void ::genesis::utils::Bitvector::flip (size_t index)", "Flip (negate) the value of a single bit, with boundary check."},
    {"bool ::genesis::utils::Bitvector::get (size_t index) const", "Return the value of a single bit, with boundary check."},
    {"size_t ::genesis::utils::Bitvector::hash () const", "Return an std::hash value for the Bitvector."},
    {"void ::genesis::utils::Bitvector::negate ()", "Flip all bits."},
    {"void ::genesis::utils::Bitvector::normalize ()", "Bring the Bitvector in a normalized form, where the first bit is always zero.\n\nIf the first bit is zero, nothing happens. However, if is is one, the whole Bitvector is flipped using negate()."},
    {"void ::genesis::utils::Bitvector::set (size_t index)", "Set the value of a single bit to true, with boundary check."},
    {"void ::genesis::utils::Bitvector::set (size_t index, bool value)", "Set the value of a single bit to a given bool value, with boundary check."},
    {"void ::genesis::utils::Bitvector::set_all (const bool value=false)", "Set all the bits to a specified value."},
    {"size_t ::genesis::utils::Bitvector::size () const", "Return the size (number of bits) of this Bitvector."},
    {"void ::genesis::utils::Bitvector::unset (size_t index)", "Set the value of a single bit to false, with boundary check."},
    {"IntType ::genesis::utils::Bitvector::x_hash () const", "Return a hash value of type IntType that is quicker to calculate than hash().\n\nThis can be used for obtaining a simple hash using xor of the words. The avalanche effect is of course not present, but for many applications, this hash is good enough and quite useful."},

    // Class BmpWriter
    {"void ::genesis::utils::BmpWriter::to_file (Matrix< Color > const & image, std::string const & filename) const", "Write a full 24bit RGB Color image to a file."},
    {"void ::genesis::utils::BmpWriter::to_file (Matrix< unsigned char > const & image, std::string const & filename) const", "Write an 8 bit grayscale image to a file.\n\nThe entries of the given Matrix are simply translated into a grayscale image, where 0 gives black and 255 gives white pixels."},
    {"void ::genesis::utils::BmpWriter::to_file (Matrix< unsigned char > const & image, std::vector< Color > const & palette, std::string const & filename) const", "Write an 8 bit image with a Color palette to a file.\n\nThe given palette needs to contain exaclty 256 Color entries. The values of the given image Matrix are then mapped to the palette entries, e.g., the value at image( 2, 3 ) == 5 maps to the Color palette[ 5 ]."},
    {"void ::genesis::utils::BmpWriter::to_stream (Matrix< Color > const & image, std::ostream & outstream) const", "Write a full 24bit RGB Color image to a stream."},
    {"void ::genesis::utils::BmpWriter::to_stream (Matrix< unsigned char > const & image, std::ostream & outstream) const", "Write an 8 bit grayscale image to a stream.\n\nThe entries of the given Matrix are simply translated into a grayscale image, where 0 gives black and 255 gives white pixels."},
    {"void ::genesis::utils::BmpWriter::to_stream (Matrix< unsigned char > const & image, std::vector< Color > const & palette, std::ostream & outstream) const", "Write an 8 bit image with a Color palette to a stream.\n\nThe given palette needs to contain exaclty 256 Color entries. The values of the given image Matrix are then mapped to the palette entries, e.g., the value at image( 2, 3 ) == 5 maps to the Color palette[ 5 ]."},

    // Class CharLookup
    {"bool ::genesis::utils::CharLookup::all_equal_to (T comp_value) const", "Return whether all chars compare equal to a given value."},
    {"T ::genesis::utils::CharLookup::get (char c) const", "Return the lookup status for a given char."},
    {"std::string ::genesis::utils::CharLookup::get_chars_equal_to (T comp_value) const", "Return a std::string containg all chars which have lookup status equal to a given value."},
    {"void ::genesis::utils::CharLookup::set_all (T value)", "Set the lookup status for all chars at once."},
    {"void ::genesis::utils::CharLookup::set_char (char c, T value)", "Set the lookup status for a given char."},
    {"void ::genesis::utils::CharLookup::set_char_upper_lower (char c, T value)", "Set the lookup status for both the upper and lower case of a given char."},
    {"void ::genesis::utils::CharLookup::set_if (std::function< bool(char)> predicate, T value)", "Set the lookup status for all chars that fulfill a given predicate."},
    {"void ::genesis::utils::CharLookup::set_range (char first, char last, T value)", "Set the lookup status for all chars in an inlcuding range between two chars."},
    {"void ::genesis::utils::CharLookup::set_selection (std::string const & chars, T value)", "Set the lookup status for all chars that are contained in a given std::string."},
    {"void ::genesis::utils::CharLookup::set_selection_upper_lower (std::string const & chars, T value)", "Set the lookup status for both the upper and lower case of all chars that are contained in a given std::string."},

    // Class Color

    // Class ColorBytes

    // Class ColorMap
    {"ColorMap & ::genesis::utils::ColorMap::clip (bool value)", "Set both clip_under( bool ) and clip_over( bool )."},
    {"bool ::genesis::utils::ColorMap::clip_over () const", "Clip (clamp) values greater than max() to be inside [ min, max ].\n\nIf set to true, over_color() is not used to indicate values out of range."},
    {"ColorMap & ::genesis::utils::ColorMap::clip_over (bool value)", "Clip (clamp) values greater than max() to be inside [ min, max ].\n\nIf set to true, over_color() is not used to indicate values out of range."},
    {"bool ::genesis::utils::ColorMap::clip_under () const", "Clip (clamp) values less than min() to be inside [ min, max ].\n\nIf set to true, under_color() is not used to indicate values out of range."},
    {"ColorMap & ::genesis::utils::ColorMap::clip_under (bool value)", "Clip (clamp) values less than min() to be inside [ min, max ].\n\nIf set to true, under_color() is not used to indicate values out of range."},
    {"Color ::genesis::utils::ColorMap::color (size_t index) const", "Return a particular color from the palette, module the palette size.\n\nThis is useful for qualitative measures. The function respects the reverse() setting, and uses modulo for indices out of range, that is, it \"wraps around\"."},
    {"std::vector< Color > ::genesis::utils::ColorMap::color_list (size_t n=256) const", "Get a color list based on the palette, containing n colors sampled at equal distance across the palette.\n\nThis is for example useful for creating a palette to write a bitmap file, see BmpWriter::to_file().If n == 0, the original palette is returned, making it equal to palette(). If n == 1, the mid point color is returned."},
    {"bool ::genesis::utils::ColorMap::empty () const", "Return whether the Palette is empty, that is, no colors were set."},
    {"Color ::genesis::utils::ColorMap::mask_color () const", "Color that indicates values equal to mask_value() or non-finite values."},
    {"ColorMap & ::genesis::utils::ColorMap::mask_color (Color value)", "Color that indicates values equal to mask_value() or non-finite values."},
    {"Color ::genesis::utils::ColorMap::over_color () const", "Color that indicates values greater than max().\n\nOnly used if clip_over() == false."},
    {"ColorMap & ::genesis::utils::ColorMap::over_color (Color value)", "Color that indicates values greater than max().\n\nOnly used if clip_over() == false."},
    {"std::vector< Color > const & ::genesis::utils::ColorMap::palette () const", "Get the color list currently in use."},
    {"bool ::genesis::utils::ColorMap::reverse () const", "Use the palette colors in reverse, back to front."},
    {"size_t ::genesis::utils::ColorMap::size () const", "Return the size of the map, that is, the number of colors in the list."},
    {"Color ::genesis::utils::ColorMap::under_color () const", "Color that indicates values less than min().\n\nOnly used if clip_under() == false."},
    {"ColorMap & ::genesis::utils::ColorMap::under_color (Color value)", "Color that indicates values less than min().\n\nOnly used if clip_under() == false."},

    // Class ColorNormalization
    {"bool ::genesis::utils::ColorNormalization::is_valid () const", "Return whether ranges and other values are correct."},
    {"double ::genesis::utils::ColorNormalization::mask_value () const", "Mask value that identifies invalid values.\n\nWhen querying a value that compares equal to the mask value, the color functions return mask_color() instead of a Color from the palette. This is meant as a simple means of filtering and visualizing invalid values.The mask value is initialized to quiet_NaN, so that it never compares equal to anything. Thus, it is not used by default has to be explicitly set to a different value."},
    {"ColorNormalization & ::genesis::utils::ColorNormalization::mask_value (double value)", "Mask value that identifies invalid values.\n\nWhen querying a value that compares equal to the mask value, the color functions return mask_color() instead of a Color from the palette. This is meant as a simple means of filtering and visualizing invalid values.The mask value is initialized to quiet_NaN, so that it never compares equal to anything. Thus, it is not used by default has to be explicitly set to a different value."},

    // Class ColorNormalizationBoundary
    {"ColorNormalizationBoundary & ::genesis::utils::ColorNormalizationBoundary::autoscale (std::vector< double > const & values, size_t intervals)", "Set the boundaries similar to scale(), but use the given vector of values to determine min and max first."},
    {"ColorNormalizationBoundary & ::genesis::utils::ColorNormalizationBoundary::autoscale (ForwardIterator first, ForwardIterator last, size_t intervals)", "Set the boundaries similar to scale(), but use the given range to determine min and max first."},
    {"std::vector< double > const & ::genesis::utils::ColorNormalizationBoundary::boundaries () const", "Return the boundaries currently set."},
    {"ColorNormalizationBoundary & ::genesis::utils::ColorNormalizationBoundary::boundaries (std::vector< double > const & values)", "Explicitly set the boundaries to the given values. Have to be sorted."},
    {"int ::genesis::utils::ColorNormalizationBoundary::interval (double value) const", "Return the interval index of a value."},
    {"bool ::genesis::utils::ColorNormalizationBoundary::is_valid_ () const", "Return whether the boundaries are correct."},
    {"ColorNormalizationBoundary & ::genesis::utils::ColorNormalizationBoundary::scale (double min, double max, size_t intervals)", "Set the boundaries to equal-sizes intervals between min and max, using interval many steps."},

    // Class ColorNormalizationDiverging
    {"bool ::genesis::utils::ColorNormalizationDiverging::is_valid_ () const", "Return whether the ranges are correct."},
    {"ColorNormalizationDiverging & ::genesis::utils::ColorNormalizationDiverging::make_centric (double center=0.0)", "Make the range symmetric around a center value.\n\nFor example, if autoscale() yielded min == -0.89 and max == 0.95, then calling this function with center == 0.0 sets min == -0.95 and mid == 0.0;"},
    {"double ::genesis::utils::ColorNormalizationDiverging::mid_value () const", "Mid-point value, that is, where the middle value of a diverging_color() is."},

    // Class ColorNormalizationLinear
    {"ColorNormalizationLinear & ::genesis::utils::ColorNormalizationLinear::autoscale (ForwardIterator first, ForwardIterator last)", "Set the min and max of the Palette so that they reflect the min and max valid values that are found in the range [ first, last ).\n\nThe provided iterator range needs to contain values that are convertible and comparable to double. Any non-finite values or values that are equal to the mask_value() are skipped. If then no value is found at all, the min and max are not changed.In derived classes, other values might also be set from this. For example, ColorNormalizationLinearDiverging also sets the mid value accordingly."},
    {"ColorNormalizationLinear & ::genesis::utils::ColorNormalizationLinear::autoscale_max (ForwardIterator first, ForwardIterator last)", "Same as autoscale(), but only updates the max_value()."},
    {"ColorNormalizationLinear & ::genesis::utils::ColorNormalizationLinear::autoscale_min (ForwardIterator first, ForwardIterator last)", "Same as autoscale(), but only updates the min_value()."},
    {"bool ::genesis::utils::ColorNormalizationLinear::is_valid_ () const", "Return whether the ranges are correct."},
    {"double ::genesis::utils::ColorNormalizationLinear::max_value () const", "Minimum value, that is, where to end the color scale."},
    {"double ::genesis::utils::ColorNormalizationLinear::min_value () const", "Minimum value, that is, where to begin the color scale."},

    // Class ColorNormalizationLogarithmic
    {"bool ::genesis::utils::ColorNormalizationLogarithmic::is_valid_ () const", "Return whether the ranges are correct."},

    // Class CsvReader
    {"CsvReader & ::genesis::utils::CsvReader::comment_chars (std::string const & chars)", "Set chars that are used to mark comment lines.\n\nBy default, no chars are used, that is, no line is interpreted as comment. Use this function to change that behaviour, e.g., use # as marker for comment lines. All lines starting with any of the set chars are then skipped while reading. The char has to be the first on the line, that is, no leading blanks are allowed.The function returns a reference to the CsvReader object in order to allow a fluent interface."},
    {"std::string const & ::genesis::utils::CsvReader::comment_chars () const", "Return the currently set chars that are used to mark comment lines.\n\nSee the setter  of this function for more details."},
    {"Table ::genesis::utils::CsvReader::from_file (std::string const & fn) const", "Read a CSV file and return its contents."},
    {"Table ::genesis::utils::CsvReader::from_stream (std::istream & is) const", "Read CSV data until the end of the stream is reached, and return it."},
    {"Table ::genesis::utils::CsvReader::from_string (std::string const & fs) const", "Read a string in CSV format and return its contents."},
    {"CsvReader & ::genesis::utils::CsvReader::merge_separators (bool value)", "Set whether consecutive separater chars are merged or whether each of them creates a new field.\n\nDefault is false. Usually, CSV data has the same number of columns for the whole dataset. Thus, empty fields will result in consecutive separator chars. When this value is set to false, those fields are correctly parsed into empty fields.It might however be useful to not create separate empty fields when consecutive separator chars are encountered. This is particularly the case if spaces or tabs are used as separators. In this case it makes sense to have more than one of them consecutively in order to align the columns of the data. For such datasets, this value can be set to true.To put it in other words, this value determines whether empty strings resulting from adjacent separator chars are excluded from the output.The function returns a reference to the CsvReader object in order to allow a fluent interface."},
    {"bool ::genesis::utils::CsvReader::merge_separators () const", "Return the current setting whether consecutive separators are merged or not.\n\nSee the setter  of this function for details."},
    {"Table ::genesis::utils::CsvReader::parse_document (utils::InputStream & input_stream) const", "Parse a whole CSV document and return its contents."},
    {"std::string ::genesis::utils::CsvReader::parse_field (utils::InputStream & input_stream) const", "Parse one field (i.e., one cell) of the CSV data and return it.\n\nThis function reads from a given input stream until the column separator or the end of the line or the end of the stream is found. It furthermore trims the necessary chars from the beginning and end of the field, and handles quoted strings according to the settings of the CsvReader.The stream is left at either the separator char, the new line char, or the end of the file, depending on which occurs first.See trim_chars(), quotation_chars(), separator_chars(), use_escapes()  and use_twin_quotes()  to change the behaviour of this function."},
    {"std::vector< std::string > ::genesis::utils::CsvReader::parse_line (utils::InputStream & input_stream) const", "Parse one line of the CSV data and return it.\n\nThis function parses a whole line using parse_field() until the new line char (or the end of the stream) is found. The fields are returned in a vector. The stream is left at either the next char after the new line char or the end of the file, if there is no new line.See merge_separators()  to change the behaviour of this function."},
    {"CsvReader & ::genesis::utils::CsvReader::quotation_chars (std::string const & chars)", "Set the chars that are used for quoting strings in fields.\n\nBy default, the double quotation mark char \" is used as quotation mark. Any other set of chars can be used instead, for example a combination of single and double quotation marks by providing `'\"` to this function.Within a quoted part, any char can appear, even new lines. However, in order to use the quotation mark itself, it has to be escaped. See use_escapes()  and use_twin_quotes()  for changing the behaviour of escaping with backslashes and with twin quotation marks.The function returns a reference to the CsvReader object in order to allow a fluent interface."},
    {"std::string const & ::genesis::utils::CsvReader::quotation_chars () const", "Return the currently set chars for quoting strings in fields.\n\nSee the setter  of this function for more details."},
    {"CsvReader & ::genesis::utils::CsvReader::separator_chars (std::string const & chars)", "Set the chars used to separate fields of the CSV data.\n\nBy default, the comma char , is used. Any other set of chars can be used instead, for example a combination of tabs and bars by providing \\t| to this function.Caveat: If more than one char is used as separater, any of them separates fields. That is, the string provided to this function is not taken as a whole to separate fields, but its single chars are used.See merge_separators()  to set whether consecutive separator chars are merged.The function returns a reference to the CsvReader object in order to allow a fluent interface."},
    {"std::string const & ::genesis::utils::CsvReader::separator_chars () const", "Return the currently set chars used to separate fields of the CSV data.\n\nSee the setter  of this function for more details."},
    {"CsvReader & ::genesis::utils::CsvReader::skip_empty_lines (bool value)", "Set whether to skip empty lines.\n\nDefault is false. If set to true, all lines that are empty (that is, no content, or just consisting of spaces and tabs) are skipped while reading.The function returns a reference to the CsvReader object in order to allow a fluent interface."},
    {"bool ::genesis::utils::CsvReader::skip_empty_lines () const", "Return whether currently empty lines are skipped.\n\nSee the setter  of this function for more details."},
    {"CsvReader & ::genesis::utils::CsvReader::trim_chars (std::string const & chars)", "Set chars that are trimmed from the start and end of each field.\n\nBy default, no chars are trimmed. Use this function to change that behaviour, e.g., to trim spaces and tabs. Be aware that according to some CSV definitions, blanks are considered to be part of the field and should not be trimmed.The function returns a reference to the CsvReader object in order to allow a fluent interface."},
    {"std::string const & ::genesis::utils::CsvReader::trim_chars () const", "Return the currently set chars that are trimmed from the start and end of each field.\n\nSee the setter  of this function for more details."},
    {"CsvReader & ::genesis::utils::CsvReader::use_escapes (bool value)", "Set whether to use backslash escape sequences.\n\nDefault is false. If set to true, character sequences of \\x (backslash and some other char) are turned into the respective string form, according to the rules of deescape(). Also, see parse_quoted_string() for more information on escaping.This works inside and outside of quoted strings. In order to create new lines within a field, either the sequence \\n (backslash n) can be used, or a backslash at the end of the line.The function returns a reference to the CsvReader object in order to allow a fluent interface."},
    {"bool ::genesis::utils::CsvReader::use_escapes () const", "Return whether backslash escape sequences are used.\n\nSee the setter  of this function for details."},
    {"CsvReader & ::genesis::utils::CsvReader::use_twin_quotes (bool value)", "Set whether to interpret two consequtive quotation marks as a single (\"escaped\") one.\n\nDefault is true. Use this setting in order to be able to escape quotation marks by doubling them. This is a common variant in CSV data. It means, whenever two consecutive quotation marks are encountered, they are turned into one (thus, the first one \"escapes\" the second). This works both inside and outside of regularly quoted parts. That is, the following two fields are interpreted the same: \"My \"\"old\"\" friend\"\nMy \"\"old\"\" friend\nThis also works in addition to normal backslash escape sequences, see use_escapes()  for more on this.See quotation_chars()  to set which chars are interpreted as quotation marks.The function returns a reference to the CsvReader object in order to allow a fluent interface."},
    {"bool ::genesis::utils::CsvReader::use_twin_quotes () const", "Return whether to interpret two consequtive quotation marks as a single (\"escaped\") one.\n\nSee the setter  of this function for details."},

    // Class Dataframe

    // Class DataframeReader

    // Class Deserializer
    {"T ::genesis::utils::Deserializer::get_float ()", "Read a floating point number from the stream and return it."},
    {"void ::genesis::utils::Deserializer::get_float (T & res)", "Read an floating point number from the stream and store it in the result."},
    {"T ::genesis::utils::Deserializer::get_int ()", "Read an integer number from the stream and return it."},
    {"void ::genesis::utils::Deserializer::get_int (T & res)", "Read an integer number from the stream and store it in the result."},
    {"bool ::genesis::utils::Deserializer::get_null (size_t n)", "Reads n bytes from the stream and returns whether all of them are \\0 bytes."},
    {"T ::genesis::utils::Deserializer::get_plain ()", "Read as many bytes from the stream as the type T holds, and return them in form of a value of type T."},
    {"void ::genesis::utils::Deserializer::get_plain (T & res)", "Read as many bytes from the stream as the type T holds, and put them in the result value of type T."},
    {"void ::genesis::utils::Deserializer::get_raw (char * buffer, size_t n)", "Read n bytes from the stream and store them in the buffer.\n\nThe buffer needs to be big enough to hold n bytes."},
    {"std::string ::genesis::utils::Deserializer::get_raw_string (size_t n)", "Read n bytes from the stream and return them as a string."},
    {"std::string ::genesis::utils::Deserializer::get_string ()", "Read a string from the stream, provided that its length it written preceding it, as done by put_string()."},

    // Class EuclideanKmeans

    // Class FileInputSource
    {"void ::genesis::utils::FileInputSource::rewind ()", "Rewind the source to its start, so that it can be re-read."},

    // Class GeoCoordinate
    {"double ::genesis::utils::GeoCoordinate::latitude () const", "Latitude, in range [ -90.0, 90.0 ]."},
    {"GeoCoordinate & ::genesis::utils::GeoCoordinate::latitude (double value)", "Latitude, in range [ -90.0, 90.0 ]."},
    {"double ::genesis::utils::GeoCoordinate::longitude () const", "Longitude, in range [ -180.0, 180.0 ]."},
    {"GeoCoordinate & ::genesis::utils::GeoCoordinate::longitude (double value)", "Longitude, in range [ -180.0, 180.0 ]."},

    // Class GzipInputSource

    // Class Histogram

    // Class HistogramAccumulator
    {"size_t ::genesis::utils::HistogramAccumulator::added_values () const", "Return the number of values that have been added to the Accumulator.\n\nThis is simply the number of function calls to increment() and accumulate(). The count is reset when calling clear()."},

    // Class IndexedList

    // Class IndexedListIterator

    // Class InputBuffer

    // Class InputReadFunctions

    // Class InputSource

    // Class InputStream
    {"self_type & ::genesis::utils::InputStream::advance ()", "Move to the next char in the stream and advance the counters."},
    {"std::string ::genesis::utils::InputStream::at () const", "Return a textual representation of the current input position in the form \"line:column\"."},
    {"size_t ::genesis::utils::InputStream::column () const", "Return the current column of the input stream.\n\nThe counter starts with column 1 for each line of the input stream. New line characters \\n are included in counting and count as the last character of a line."},
    {"char ::genesis::utils::InputStream::current () const", "Return the current char, with some checks.\n\nThis function is similar to the dereference operator, but additionally performs two checks:\nEnd of input: If this function is called when there is no more data left in the input, it throws an runtime_error.Current char: This iterator is meant for ASCII (or similar) text format encodings with single bytes, and its output should be usable for lookup tables etc. Thus, this function ensures that the char is in the range [0, 127]. If not, an std::domain_error is thrown.\nUsually, those two conditions are checked in the parser anyway, so in most cases it is preferred to use the dereference operator instead."},
    {"bool ::genesis::utils::InputStream::eof () const", "Return true iff the input reached its end."},
    {"char ::genesis::utils::InputStream::get_char ()", "Extract a single char from the input.\n\nReturn the current char and move to the next one."},
    {"std::pair< char *, size_t > ::genesis::utils::InputStream::get_line ()", "Return the current line and move to the beginning of the next.\n\nThe function finds the end of the current line, starting from the current position. It returns a pointer to the current position and the length of the line. Furthermore, a null char is set at the end of the line, replacing the new line char. This allows downstream parses to directly use the returned pointer as a c-string.The stream is left at the first char of the next line."},
    {"bool ::genesis::utils::InputStream::good () const", "Return true iff the input is good (not end of data) and can be read from."},
    {"size_t ::genesis::utils::InputStream::line () const", "Return the current line of the input stream.\n\nThe counter starts with line 1 for input stream."},
    {"std::string ::genesis::utils::InputStream::source_name () const", "Get the input source name where this stream reads from.\n\nDepending on the type of input, this is either\n\"input string\",\"input stream\" or\"input file <filename>\"\nThis is mainly useful for user output like log and error messages."},

    // Class IteratorDeletions
    {"TwobitVector::WordType ::genesis::utils::IteratorDeletions::hash () const", "Get the hash value of the current vector."},
    {"size_t ::genesis::utils::IteratorDeletions::position () const", "Get the position that is currently deleted."},
    {"TwobitVector const & ::genesis::utils::IteratorDeletions::vector () const", "Get the current vector."},

    // Class IteratorInsertions
    {"TwobitVector::WordType ::genesis::utils::IteratorInsertions::hash () const", "Get the hash value of the current vector."},
    {"size_t ::genesis::utils::IteratorInsertions::position () const", "Get the position that is currently deleted."},
    {"TwobitVector const & ::genesis::utils::IteratorInsertions::vector () const", "Get the current vector."},

    // Class IteratorSubstitutions
    {"TwobitVector::WordType ::genesis::utils::IteratorSubstitutions::hash () const", "Get the hash value of the current vector."},
    {"size_t ::genesis::utils::IteratorSubstitutions::position () const", "Get the position that is currently deleted."},
    {"TwobitVector const & ::genesis::utils::IteratorSubstitutions::vector () const", "Get the current vector."},

    // Class JsonDocument
    {"static JsonDocument ::genesis::utils::JsonDocument::array (std::initializer_list< JsonDocument > init=std::initializer_list< )", "Explicitly create an array from an initializer list."},
    {"static JsonDocument ::genesis::utils::JsonDocument::boolean (BooleanType value)", "Explicitly create a boolean."},
    {"const_iterator ::genesis::utils::JsonDocument::cbegin () const", "Return a const iterator to the first element."},
    {"const_iterator ::genesis::utils::JsonDocument::cend () const", "Return a const iterator to one past the last element."},
    {"void ::genesis::utils::JsonDocument::clear ()", "Clears the content of a JSON value and resets it to the default value as if JsonDocument(ValueType) would have been called.\n\nThe values are cleared as follows:\nValue type initial value  \n\nnull null \n\nboolean false \n\nstring \"\" \n\nnumber 0 \n\nobject {} \n\narray [] \n\nIn order to complete eliminate a Json value, set it to nullptr instead."},
    {"size_type ::genesis::utils::JsonDocument::count (typename ObjectType::key_type key) const", "Return the number of occurrences of a key in a JSON object.\n\nAs we use a std::map for objects, this value is either 0 (key not found) or 1 (key found). For non-object types, the return value is always 0."},
    {"iterator ::genesis::utils::JsonDocument::find (typename JsonDocument::ObjectType::key_type key)", "Find an element in a JSON object.\n\nFinds an element in a JSON object with key equivalent to key. If the element is not found or the JSON value is not an object, end() is returned."},
    {"const_iterator ::genesis::utils::JsonDocument::find (typename JsonDocument::ObjectType::key_type key) const", "Find an element in a JSON object.\n\nFinds an element in a JSON object with key equivalent to key. If the element is not found or the JSON value is not an object, end() is returned."},
    {"bool ::genesis::utils::JsonDocument::is_array () const", "Return true iff the JSON value is an array."},
    {"bool ::genesis::utils::JsonDocument::is_boolean () const", "Return true iff the JSON value is a boolean."},
    {"bool ::genesis::utils::JsonDocument::is_null () const", "Return true iff the JSON value is null."},
    {"bool ::genesis::utils::JsonDocument::is_number () const", "Return true iff the JSON value is a number, i.e., a float or signed or unsigned integer."},
    {"bool ::genesis::utils::JsonDocument::is_number_float () const", "Return true iff the JSON value is a float number."},
    {"bool ::genesis::utils::JsonDocument::is_number_integer () const", "Return true iff the JSON value is a signed or unsigned integer number."},
    {"bool ::genesis::utils::JsonDocument::is_number_signed () const", "Return true iff the JSON value is a signed integer number."},
    {"bool ::genesis::utils::JsonDocument::is_number_unsigned () const", "Return true iff the JSON value is an unsigned integer number."},
    {"bool ::genesis::utils::JsonDocument::is_object () const", "Return true iff the JSON value is an object."},
    {"bool ::genesis::utils::JsonDocument::is_primitive () const", "Return true iff the JSON type is primitive (string, number, boolean, or null)."},
    {"bool ::genesis::utils::JsonDocument::is_string () const", "Return true iff the JSON value is a string."},
    {"bool ::genesis::utils::JsonDocument::is_structured () const", "Return true iff the JSON type is structured (array or object)."},
    {"static JsonDocument ::genesis::utils::JsonDocument::number_float (NumberFloatType value)", "Explicitly create a float number."},
    {"static JsonDocument ::genesis::utils::JsonDocument::number_signed (NumberSignedType value)", "Explicitly create a signed number."},
    {"static JsonDocument ::genesis::utils::JsonDocument::number_unsigned (NumberUnsignedType value)", "Explicitly create an unsigned number."},
    {"static JsonDocument ::genesis::utils::JsonDocument::object (std::initializer_list< JsonDocument > init=std::initializer_list< )", "Explicitly create an object from an initializer list."},
    {"void ::genesis::utils::JsonDocument::push_back (JsonDocument && val)", "Add a Json value to an array.\n\nAppends the given element val to the end of the JSON value. If the function is called on a JSON null value, an empty array is created before appending val.void push_back( JsonDocument&& val );"},
    {"void ::genesis::utils::JsonDocument::push_back (JsonDocument const & val)", "Add a Json value to an array.\n\nAppends the given element val to the end of the JSON value. If the function is called on a JSON null value, an empty array is created before appending val.void push_back( JsonDocument&& val );"},
    {"void ::genesis::utils::JsonDocument::push_back (typename ObjectType::value_type const & val)", "Add an object to an object.\n\nInserts the given element val to the JSON object. If the function is called on a JSON null value, an empty object is created before inserting val."},
    {"static JsonDocument ::genesis::utils::JsonDocument::string (std::string const & init)", "Explicitly create a string."},
    {"ValueType ::genesis::utils::JsonDocument::type () const", "Return the type of the JSON value."},

    // Class JsonIterator
    {"JsonDocument::ObjectType::key_type ::genesis::utils::JsonIterator::key () const", "return the key of an object iterator\n\nThe iterator is initialized; i.e. object_ != nullptr."},
    {"reference ::genesis::utils::JsonIterator::value () const", "return the value of an iterator\n\nThe iterator is initialized; i.e. object_ != nullptr."},

    // Class JsonReader
    {"JsonDocument ::genesis::utils::JsonReader::from_file (const std::string & filename) const", "Take a JSON document file path and parse its contents into a JsonDocument.\n\nIf the file does not exists, the function throws."},
    {"JsonDocument ::genesis::utils::JsonReader::from_stream (std::istream & input_stream) const", "Read from a stream containing a JSON document and parse its contents into a JsonDocument."},
    {"JsonDocument ::genesis::utils::JsonReader::from_string (const std::string & json) const", "Take a string containing a JSON document and parse its contents into a JsonDocument."},

    // Class JsonWriter
    {"size_t ::genesis::utils::JsonWriter::indent () const", "Get the indent used for printing the elements of Json arrays and objects."},
    {"JsonWriter & ::genesis::utils::JsonWriter::indent (size_t value)", "Set the indent used for printing the elements of Json arrays and objects.\n\nThe function returns a reference to the JsoNWriter to allow for fluent interfaces."},
    {"size_t ::genesis::utils::JsonWriter::precision () const", "Get the precision used for printing floating point numbers."},
    {"JsonWriter & ::genesis::utils::JsonWriter::precision (size_t value)", "Set the precision used for printing floating point numbers.\n\nThe function returns a reference to the JsoNWriter to allow for fluent interfaces."},
    {"void ::genesis::utils::JsonWriter::to_file (JsonDocument const & document, std::string const & filename) const", "Write a JsonDocument to a file.\n\nIf the file cannot be written to, the function throws an exception. Also, by default, if the file already exists, an exception is thrown. See Options::allow_file_overwriting() to change this behaviour."},
    {"void ::genesis::utils::JsonWriter::to_stream (JsonDocument const & document, std::ostream & out) const", "Write a JsonDocument to a stream."},
    {"void ::genesis::utils::JsonWriter::to_string (JsonDocument const & document, std::string & output) const", "Give the Json string representation of a JsonDocument."},
    {"std::string ::genesis::utils::JsonWriter::to_string (JsonDocument const & document) const", "Return the Json representation of a JsonDocument."},

    // Class Kmeans

    // Class KmeansClusteringInfo

    // Class Logging
    {"std::ostringstream & ::genesis::utils::Logging::get (const std::string & file, const int line, const std::string & function, const LoggingLevel level)", "Getter for the singleton instance of log, is called by the standard macros.\n\nIt returns the string stream buffer used to capture the log messages."},
    {"std::ostringstream & ::genesis::utils::Logging::get (const std::string & file, const int line, const std::string & function, const LoggingLevel level, const LoggingDetails dets)", "Getter for the singleton instance of log, is called by special macros that change the details of the log message.\n\nIt stores some relevant information and returns the string stream buffer used to capture the log messages."},
    {"static std::string ::genesis::utils::Logging::level_to_string (const LoggingLevel level)", "Return a string representation of a log level."},
    {"static void ::genesis::utils::Logging::log_to_file (const std::string & fn)", "Add an output file to which log messages are written.\n\nThis creates a stream to the file."},
    {"static void ::genesis::utils::Logging::log_to_stdout ()", "Add stdout as output stream to which log messages are written."},
    {"static void ::genesis::utils::Logging::log_to_stream (std::ostream & os)", "Add an output stream to which log messages are written."},
    {"static LoggingLevel ::genesis::utils::Logging::max_level ()", "Get the highest log level that is reported."},
    {"static void ::genesis::utils::Logging::max_level (const LoggingLevel level)", "Set the highest log level that is reported.\n\nInvocations of log with higher levels will create no output. It creates a warning if the set level is higher than the static compile time level set by LOG_LEVEL_MAX."},
    {"static int ::genesis::utils::Logging::report_percentage ()", "Get the current percentage for reporting LOG_PROG messages."},
    {"static void ::genesis::utils::Logging::report_percentage (const int percentage)", "set the percentage for reporting LOG_PROG messages."},

    // Class LoggingDetails

    // Class LoggingScopeLevel

    // Class MD5
    {"void ::genesis::utils::MD5::clear ()", "Reset to initial state, that is, delete any intermediate input from update() calls."},
    {"DigestType ::genesis::utils::MD5::final_digest ()", "Finish the calculation, prepare the object for next use, and return the digest."},
    {"std::string ::genesis::utils::MD5::final_hex ()", "Finish the calculation, prepare the object for next use, and return the hash."},
    {"static DigestType ::genesis::utils::MD5::from_file_digest (std::string const & filename)", "Calculate the hash digest for the content of a file, given its path."},
    {"static std::string ::genesis::utils::MD5::from_file_hex (std::string const & filename)", "Calculate the checksum for the content of a file, given its path."},
    {"static DigestType ::genesis::utils::MD5::from_stream_digest (std::istream & is)", "Calculate the hash digest for the content of a stream."},
    {"static std::string ::genesis::utils::MD5::from_stream_hex (std::istream & is)", "Calculate the checksum for the content of a stream."},
    {"static DigestType ::genesis::utils::MD5::from_string_digest (std::string const & input)", "Calculate the hash digest for the content of a string."},
    {"static std::string ::genesis::utils::MD5::from_string_hex (std::string const & input)", "Calculate the checksum for the content of a string."},
    {"void ::genesis::utils::MD5::update (std::string const & s)", "Add the contents of a string to the hash digest."},

    // Class Matrix

    // Class MatrixCol
    {"self_type & ::genesis::utils::MatrixCol::assign (self_type const & other)", "Overwrite a column by the elements of another column.\n\nThe sizes of both columns need to match each other. The given column can also be a column of the same Matrix."},
    {"value_type & ::genesis::utils::MatrixCol::at (size_t row) const", "Return the element at a given row of the Matrix column."},
    {"size_t ::genesis::utils::MatrixCol::col () const", "Get the column index that this object represents."},
    {"matrix_type & ::genesis::utils::MatrixCol::matrix () const", "Get the underlying Matrix."},
    {"size_t ::genesis::utils::MatrixCol::size () const", "Get the size of the column, that is, the number of rows of the Matrix."},
    {"std::vector< non_const_value_type > ::genesis::utils::MatrixCol::to_vector () const", "Explicit conversion to vector."},

    // Class MatrixReader

    // Class MatrixRow
    {"self_type & ::genesis::utils::MatrixRow::assign (self_type const & other)", "Overwrite a row by the elements of another row.\n\nThe sizes of both rows need to match each other. The given row can also be a row of the same Matrix."},
    {"value_type & ::genesis::utils::MatrixRow::at (size_t column) const", "Return the element at a given column of the Matrix row."},
    {"matrix_type & ::genesis::utils::MatrixRow::matrix () const", "Get the underlying Matrix."},
    {"size_t ::genesis::utils::MatrixRow::row () const", "Get the row index that this object represents."},
    {"size_t ::genesis::utils::MatrixRow::size () const", "Get the size of the row, that is, the number of columns of the Matrix."},
    {"std::vector< non_const_value_type > ::genesis::utils::MatrixRow::to_vector () const", "Explicit conversion to vector."},

    // Class MatrixWriter

    // Class MeanStddevPair

    // Class MinMaxPair

    // Class MruCache
    {"size_type ::genesis::utils::MruCache::capacity () const", "Return the currently set capacity of the cache, i.e., its maximal size.\n\nA capacity of 0 means limitless, that is, no elements are ever removed."},
    {"void ::genesis::utils::MruCache::capacity (size_t value)", "Set the capacity of the cache, i.e., its maximal size.\n\nSetting the capacity to 0 means limitless, that is, no elements are ever removed."},
    {"const_iterator ::genesis::utils::MruCache::cbegin ()", "Get a const iterator to the begin of the cache, that is, the most recently used element."},
    {"const_iterator ::genesis::utils::MruCache::cend ()", "Get a const iterator to past-the-end of the cache, that is, one element after the least recently used one."},
    {"void ::genesis::utils::MruCache::clear ()", "Clear the cache."},
    {"bool ::genesis::utils::MruCache::contains (key_type const & key)", "Return whether an element is currently in the cache.\n\nThread safety: Safe. But the element might be removed by other threads soon."},
    {"bool ::genesis::utils::MruCache::empty () const", "Return whether the cache is currently empty, that is, has no elements loaded."},
    {"mapped_type & ::genesis::utils::MruCache::fetch (key_type const & key)", "Get an element.\n\nThis is the main function of the class. It gets an element given its key, either by retrieving it from the cache, or loading it into the cache first, if needed.If loading an element leads to the capacity of the cache begin exceeded, the least recently used element is removed. The removal is done after loading the new element. This means that the memory usage can be one more element than the capacity() allows. This is done to make sure that an exception thrown when loading the new element does not lead to the cache being altered.Thread safety: Not thread safe, because it does not use a guard, and because it returns a reference, which can become dangling if other threads fetch new elements, leading to the referenced one being removed. For multi-threaded use, see fetch_copy().Caveat: Even in single-thread use, a variable storing a reference obtained from fetch() can become dangling, if more new elements are fetched or touched than the capacity allows. Thus, the variable needs to go out of scope before this happens. For example, a loop over keys, fetching an element in the beginning of the loop body and keeping the reference only within the loop body without calling fetch() again, is fine."},
    {"mapped_type ::genesis::utils::MruCache::fetch_copy (key_type const & key)", "Get an element by copy.\n\nThis works exactly the same as fetch(), but is thread safe and returns a copy. See fetch() for details.Because the loading is not part of the mutex that makes this function thread safe, it is possible to parallely load elements in different threads. However, when two threads need to load an element at the same time, the loading may happen twice. Then, only the first thread that finishes loading stores the element in the cache, while the other one is discarded. This is done in order to allow parallel loading without the hassle of per-element locks.If the cache is used in a multi-threaded environment and holds large elements, making actual copies might be too expensive. In that case, a neat trick is to store shared pointers to the elements instead://Pathtosomedata.\nstd::stringdir=\"/path/to/data\";\n\n//Createacachefromfilenamestosharedpointersoffilecontents.\nMruCache<std::string,std::shared_ptr<std::string>>cache{5};\n\n//Loadelementsfromfile.\ncache.load_function=[&dir](std::stringconst&file){\nreturnstd::make_shared<std::string>(file_read(dir+\"/\"+file));\n};\n\n//Fetchanelement,thatis,loadafileintothecache.\n//Storeitbycopy,whichjustcopiesthesharedpointer.\nautocontent=cache.fetch_copy(\"fail2.jtest\");\nAs the control block of std::shared_ptr is thread safe, these shared pointer copies can stay alive in a thread that still needs the element, even if the element was removed from the cache by other threads in the meantime."},
    {"size_type ::genesis::utils::MruCache::size () const", "Get the current count of elements being loaded in the cache."},
    {"void ::genesis::utils::MruCache::touch (key_type const & key)", "Bring an element to the front, and load it if needed.\n\nThe function behaves just like fetch_copy(), but without returning the element. Useful to pre-load the cache.Be aware however that having touched an element in multi threaded used does not guarantee that it stays in the cache for long. Other threads might have fetched other elements, leading to the removal of the touched one. In that case, it has to be loaded again when fetched later."},

    // Class NexusBlock

    // Class NexusDocument

    // Class NexusTaxa

    // Class NexusTrees

    // Class NexusWriter

    // Class Options
    {"bool ::genesis::utils::Options::allow_file_overwriting () const", "Get whether Genesis is allowed to overwrite files when outputting data.\n\nSee allow_file_overwriting( bool ) for details."},
    {"void ::genesis::utils::Options::allow_file_overwriting (bool value)", "Set whether Genesis is allowed to overwrite files when outputting data.\n\nThe option is false by default, which causes Genesis to throw an execption when it attempts to write to a file that is already existing.By setting this option to true, files are silently overwritten in case they already exist. This has to be activated explicitly in order to avoid losing files by accident.file_output_stream()"},
    {"static std::string ::genesis::utils::Options::build_type ()", "Return the build type that was used to compile the binary, i.e., \"debug\" or \"release\"."},
    {"std::vector< std::string > ::genesis::utils::Options::command_line () const", "Returns an array of strings containing the program's command line arguments."},
    {"void ::genesis::utils::Options::command_line (int const argc, char const *const * argv)", "Set arguments to the program's command line options.\n\nIf the program is run from the command line, this method has to be used to properly propagate the command line options to this options class."},
    {"std::string ::genesis::utils::Options::command_line_string () const", "Returns a string containing the program's command line arguments."},
    {"static std::string ::genesis::utils::Options::compile_date_time ()", "Return the date and time when genesis was compiled.\n\nDue to this using the preprocessor, the returned date and time are from when the Options class was first compiled in a clean build process."},
    {"static std::string ::genesis::utils::Options::compiler_family ()", "Return the compiler family (name) that was used to compile genesis.\n\nSee compiler_version() to get the version of the compiler."},
    {"static std::string ::genesis::utils::Options::compiler_version ()", "Return the compiler version that was used to compile genesis.\n\nSee compiler_family() to get the corresponding compiler name."},
    {"static std::string ::genesis::utils::Options::cpp_version ()", "Return the CPP version that was used to compile genesis."},
    {"static Options & ::genesis::utils::Options::get ()", "Returns a single instance of this class."},
    {"std::string ::genesis::utils::Options::info () const", "Return a list with compile time and run time options with their values."},
    {"static bool ::genesis::utils::Options::is_big_endian ()", "Return whether the system uses big endian memory."},
    {"static bool ::genesis::utils::Options::is_debug ()", "Return whether the binary was compiled with build type DEBUG."},
    {"static bool ::genesis::utils::Options::is_little_endian ()", "Return whether the system uses little endian memory."},
    {"static bool ::genesis::utils::Options::is_release ()", "Return whether the binary was compiled with build type RELEASE."},
    {"unsigned int ::genesis::utils::Options::number_of_threads () const", "Returns the number of threads."},
    {"void ::genesis::utils::Options::number_of_threads (unsigned int number)", "Overwrite the system given number of threads.\n\nWhen the Options class is first instanciated, the value is initialized with the actual number of cores available in the system using std::thread::hardware_concurrency(). This method overwrites this value.If number is 0, the number of threads is set again to hardware concurrency."},
    {"static std::string ::genesis::utils::Options::platform ()", "Return the platform under which genesis was compiled.\n\nThis can be either \"Win32\", \"Linux\", \"Apple\", \"Unix\" or \"Unknown\"."},
    {"void ::genesis::utils::Options::print_object_gists (long value)", "Set whether an object gist is printed when using the operator << that is defined for many (container) classes.\n\nIn genesis, we create the functions print_info() and print_gist(), and overload the operator << for many classes as a convenient way to get information about an object, for example for debugging purposes. Using this setting, the behaviour of the operator << is controlled: If set to a value n greather than 0, the first n elements that the object contains are printed. If set to a negative value, all elements are printed. Default is 0, that is, no gist of the object's elements is printed.See also print_object_infos( bool ) for an additional setting that allows to print an info one-liner when using operator << on an object. Both settings can also be combined. In that case, first, the one-line info is printed, followed by the gist."},
    {"long ::genesis::utils::Options::print_object_gists () const", "Get whether an object gist is printed when using the operator <<.\n\nSee print_object_gists( long ) for details."},
    {"void ::genesis::utils::Options::print_object_infos (bool value)", "Set whether an object info one-liner is printed when using the operator << that is defined for many classes.\n\nIn genesis, we create the functions print_info() and print_gist(), and overload the operator << for many classes as a convenient way to get information about an object, for example for debugging purposes. Using this setting, the behaviour of the operator << is controlled: If set to true, a one-liner containing basic information about the object (its type, and for containers, its size) is printed.See also print_object_gists( int ) for an additional setting that allows to print more details when using operator << on an object. Both settings can also be combined. In that case, first, the one-line info is printed, followed by the gist."},
    {"bool ::genesis::utils::Options::print_object_infos () const", "Get whether an object info one-liner is printed when using the operator <<.\n\nSee print_object_infos( bool ) for details."},
    {"std::default_random_engine & ::genesis::utils::Options::random_engine ()", "Returns the default engine for random number generation.\n\nCaveat: This is not intended for the use in more than one thread. As the order of execution in threads is not deterministic, results would not be reproducible, even when using a fixed seed. Furthermore, it might be a speed bottleneck to add a mutex to this method.If in the future there is need for multi-threaded random engines, they needed to be outfitted with separate seeds each (otherwise they would all produce the same results). Thus, for now we simply assume single-threaded use."},
    {"unsigned ::genesis::utils::Options::random_seed () const", "Returns the random seed that was used to initialize the engine."},
    {"void ::genesis::utils::Options::random_seed (const unsigned seed)", "Set a specific seed for the random engine.\n\nOn startup, the random engine is initialized using the current system time. This value can be overwritten using this method."},
    {"static bool ::genesis::utils::Options::stderr_is_terminal ()", "Return true iff the standard error stream is a terminal, and false if not, i.e., if it is a file or a pipe."},
    {"static bool ::genesis::utils::Options::stdin_is_terminal ()", "Return true iff the standard input stream is a terminal, and false if not, i.e., if it is a file or a pipe."},
    {"static bool ::genesis::utils::Options::stdout_is_terminal ()", "Return true iff the standard output stream is a terminal, and false if not, i.e., if it is a file or a pipe."},
    {"static std::pair< int, int > ::genesis::utils::Options::terminal_size ()", "Return the width and height of the terminal that is used to run the program, in number of columns and lines."},
    {"static bool ::genesis::utils::Options::using_openmp ()", "Return whether the binary was compiled using OpenMP."},
    {"static bool ::genesis::utils::Options::using_pthreads ()", "Return whether the binary was compiled using Pthreads."},
    {"static bool ::genesis::utils::Options::using_zlib ()", "Return whether the binary was compiled using zlib."},

    // Class PcaData

    // Class Quartiles

    // Class Range

    // Class RangeMinimumQuery
    {"size_t ::genesis::utils::RangeMinimumQuery::query (size_t i, size_t j) const", "Main function for the Range Minimum Query.\n\nThe function returns the index of the minimum element in the given vector of integers (see RangeMinimumQuery()) that lies between the indices i and j.Caveat: Both given indices are inclusive, i.e., the interval is [ i, j ]. If j < i, the function throws an std::invalid_argument."},

    // Class SHA1
    {"void ::genesis::utils::SHA1::clear ()", "Reset to initial state, that is, delete any intermediate input from update() calls."},
    {"DigestType ::genesis::utils::SHA1::final_digest ()", "Finish the calculation, prepare the object for next use, and return the digest."},
    {"std::string ::genesis::utils::SHA1::final_hex ()", "Finish the calculation, prepare the object for next use, and return the hash."},
    {"static DigestType ::genesis::utils::SHA1::from_file_digest (std::string const & filename)", "Calculate the hash digest for the content of a file, given its path."},
    {"static std::string ::genesis::utils::SHA1::from_file_hex (std::string const & filename)", "Calculate the checksum for the content of a file, given its path."},
    {"static DigestType ::genesis::utils::SHA1::from_stream_digest (std::istream & is)", "Calculate the hash digest for the content of a stream."},
    {"static std::string ::genesis::utils::SHA1::from_stream_hex (std::istream & is)", "Calculate the checksum for the content of a stream."},
    {"static DigestType ::genesis::utils::SHA1::from_string_digest (std::string const & input)", "Calculate the hash digest for the content of a string."},
    {"static std::string ::genesis::utils::SHA1::from_string_hex (std::string const & input)", "Calculate the checksum for the content of a string."},
    {"void ::genesis::utils::SHA1::update (std::string const & s)", "Add the contents of a string to the hash digest."},
    {"void ::genesis::utils::SHA1::update (std::istream & is)", "Add the contents of a stream to the hash digest."},

    // Class SHA256
    {"void ::genesis::utils::SHA256::clear ()", "Reset to initial state, that is, delete any intermediate input from update() calls."},
    {"DigestType ::genesis::utils::SHA256::final_digest ()", "Finish the calculation, prepare the object for next use, and return the digest."},
    {"std::string ::genesis::utils::SHA256::final_hex ()", "Finish the calculation, prepare the object for next use, and return the hash."},
    {"static DigestType ::genesis::utils::SHA256::from_file_digest (std::string const & filename)", "Calculate the hash digest for the content of a file, given its path."},
    {"static std::string ::genesis::utils::SHA256::from_file_hex (std::string const & filename)", "Calculate the checksum for the content of a file, given its path."},
    {"static DigestType ::genesis::utils::SHA256::from_stream_digest (std::istream & is)", "Calculate the hash digest for the content of a stream."},
    {"static std::string ::genesis::utils::SHA256::from_stream_hex (std::istream & is)", "Calculate the checksum for the content of a stream."},
    {"static DigestType ::genesis::utils::SHA256::from_string_digest (std::string const & input)", "Calculate the hash digest for the content of a string."},
    {"static std::string ::genesis::utils::SHA256::from_string_hex (std::string const & input)", "Calculate the checksum for the content of a string."},
    {"void ::genesis::utils::SHA256::update (std::string const & s)", "Add the contents of a string to the hash digest."},

    // Class Serializer
    {"void ::genesis::utils::Serializer::put_float (const T v)", "Write a floating point number to the stream.\n\nCurrently, this simply uses put_plain(), but future versions might change this behaviour and convert it to some machine-independent format."},
    {"void ::genesis::utils::Serializer::put_int (const T v)", "Write an integer number to the stream.\n\nCurrently, this simply uses put_plain(), but future versions might change this behaviour and use specific conversions (litte/big endianness, signed/unsigned) before writing."},
    {"void ::genesis::utils::Serializer::put_null (const size_t n)", "Write n zero bytes (\\0) to the stream."},
    {"void ::genesis::utils::Serializer::put_plain (const T v)", "Write plain data to the stream, by casting it to a char array."},
    {"void ::genesis::utils::Serializer::put_raw (char const * data, size_t n)", "Write raw data, provided as a char array of length n, to the stream."},
    {"void ::genesis::utils::Serializer::put_raw_string (const std::string & v)", "Write raw data, provided as a string, to the stream, without writing its length."},
    {"void ::genesis::utils::Serializer::put_string (const std::string & v)", "Write a string, preceded by its length, to the stream. Use get_string() to read it."},

    // Class SortedVector
    {"bool ::genesis::utils::SortedVector::contains (const_reference value) const", "Return whether a certain value is present in the container."},
    {"size_type ::genesis::utils::SortedVector::index_of (const_reference value) const", "Return the index at which a certain value is stored, or size(), if it is not present in the container."},
    {"void ::genesis::utils::SortedVector::insert (const_reference value)", "Insert a value into the container by copying it.\n\nIf a value comparing equal to the new one is already stored in the container, nothing happens."},
    {"void ::genesis::utils::SortedVector::insert (value_type && value)", "Insert a value into the container by moving it.\n\nIf a value comparing equal to the new one is already stored in the container, nothing happens."},
    {"void ::genesis::utils::SortedVector::insert (InputIterator first, InputIterator last)", "Insert values into the container by copying from an InputIterator range.\n\nThe function copies all values in the range [ first, last ) into the container."},
    {"void ::genesis::utils::SortedVector::remove (const_reference value)", "Remove a certain value from the container.\n\nIf the value is not stored in the container, nothing happens."},
    {"void ::genesis::utils::SortedVector::reserve (size_t n)", "Reserve space in the unterlying vector."},

    // Class StreamInputSource

    // Class StringInputSource
    {"void ::genesis::utils::StringInputSource::rewind ()", "Rewind the source to its start, so that it can be re-read."},

    // Class Style
    {"bool ::genesis::utils::Style::bold () const", "Return whether the Style uses bold."},
    {"Style & ::genesis::utils::Style::bold (bool value)", "Set whether the Style uses bold.\n\nThe function returns the Style object itself, in order to allow a fluent interface."},
    {"bool ::genesis::utils::Style::enabled () const", "Return whether the Style is currently enabled."},
    {"Style & ::genesis::utils::Style::enabled (bool value)", "Set whether the Style is enabled.\n\nIf set to false, no style attributes are outputted when the Style is applied to a text with operator()(). Default is true.The function returns the Style object itself, in order to allow a fluent interface."},
    {"static std::string ::genesis::utils::Style::get_background_color_value (std::string name)", "Return the color value string for a given background color name.\n\nSee Style::foreground_colors for background valid color names. If the name is invalid, the function throws an std::out_of_range exception."},
    {"static std::string ::genesis::utils::Style::get_foreground_color_value (std::string name)", "Return the color value string for a given foreground color name.\n\nSee Style::foreground_colors for valid foreground color names. If the name is invalid, the function throws an std::out_of_range exception."},
    {"static bool ::genesis::utils::Style::is_background_color (std::string name)", "Return true iff the given name is a background color name."},
    {"static bool ::genesis::utils::Style::is_foreground_color (std::string name)", "Return true iff the given name is a foreground color name."},
    {"Style & ::genesis::utils::Style::reset ()", "Reset the Style to use not colors and not bold."},
    {"std::string ::genesis::utils::Style::to_bash_string (std::string const & text) const", "Additional output function with the same purpose as operator().\n\nIt uses the notation \\033 for the escape symbol, which is best interpreted by bash. Usually, there is no need to use this function. The operator() should just work fine."},
    {"std::string ::genesis::utils::Style::to_python_string (std::string const & text) const", "Additional output function with the same purpose as operator().\n\nIt uses the notation \\x1b for the escape symbol, which is best interpreted by python. Usually, there is no need to use this function. The operator() should just work fine."},

    // Class SvgBox

    // Class SvgCircle

    // Class SvgColorBarSettings

    // Class SvgDefinitions

    // Class SvgDocument
    {"self_type & ::genesis::utils::SvgDocument::add (SvgObject const & object)", "Add an SvgObject to the document.\n\nReturns the SvgDocument in order to allow for a fluent interface."},
    {"void ::genesis::utils::SvgDocument::write (std::ostream & out) const", "Write the SvgDocument to an output stream."},

    // Class SvgDrawingOptions

    // Class SvgEllipse

    // Class SvgFill

    // Class SvgFont

    // Class SvgGradientLinear

    // Class SvgGradientStop

    // Class SvgGroup
    {"self_type & ::genesis::utils::SvgGroup::add (SvgObject const & object)", "Add an SvgObject to the document.\n\nReturns the SvgDocument in order to allow for a fluent interface."},
    {"self_type & ::genesis::utils::SvgGroup::reverse ()", "Reverse the order to the stored SvgObjects."},

    // Class SvgImage

    // Class SvgLine

    // Class SvgMargin

    // Class SvgObject

    // Class SvgPath

    // Class SvgPoint

    // Class SvgPolygon

    // Class SvgPolyline

    // Class SvgRect

    // Class SvgSize

    // Class SvgStroke

    // Class SvgText

    // Class SvgTransform

    // Class SvgUse

    // Class SynchronousReader

    // Class Table
    {"Column & ::genesis::utils::Table::add_column (std::string label=\"\")", "Add a column to the table.\n\nIf the table already contains columns with data, the new one is initialized with empty strings for the whole length of the table."},
    {"void ::genesis::utils::Table::clear ()", "Clears all columns and their data from the table."},
    {"void ::genesis::utils::Table::clear_content ()", "Clears the data contents of all columns. Their labels etc stay unchanged."},
    {"Table & ::genesis::utils::Table::line_break ()", "Finish the currently line and move to the next one.\n\nThis function fills the columns of the current line with empty strings, so that the next append() call will add content to the first column of the next line. If we are currently at the beginning of a line, this function results in an empty line (useful for grouping of lines)."},

    // Class TableLayout

    // Class Tickmarks
    {"std::vector< LabeledTick > ::genesis::utils::Tickmarks::linear_labels (double min, double max, size_t target_steps)", "Return a set of labels with relative positions between min and max, where the labels correspond to the linear_ticks() numbers.\n\nThis function is a convenience wrapper for linear_ticks(), that turns the tick positions into relative values, while keeping the actual tick value as a label. Relative position 0.0 corresponds to min, relative position 1.0 to max."},
    {"std::vector< double > ::genesis::utils::Tickmarks::linear_ticks (double min, double max, size_t target_steps)", "Calculate a set of ticks that linearily span from min to max in approximately target_steps many steps, where each tick sits on a \"nice\" number.\n\nSee step_size() for what is meant by nice numbers."},
    {"std::vector< LabeledTick > ::genesis::utils::Tickmarks::logarithmic_labels (double min, double max, double base=10.0)", "Return a set of labels with relative positions between min and max, where the labels correspond to logarithmic ticks.\n\nThis function is the equivalent of linear_labels(), but instead uses logarithmic scaling. Also, it inserts as many ticks as are needed to go up to max in powers of base, and thus has no target steps.Example: Given min == 1.0, max == 350, with overshoot_at_max == false and include_max == true, the resulting vector contains entries with labels 1, 10, 100, 350.Remark: There is no logarithmic equivalent for linear_ticks(), as those would simply be powers of base up to max."},
    {"static double ::genesis::utils::Tickmarks::step_size (double interval_size, size_t target_steps)", "Calculate a step size that fills the interval_size in approximately target_steps many steps.\n\nThe resulting step size is calculated to be a \"nice\" size, i.e. fits [ 1 | 2 | 5 ] * 10^n. Thus, exemplary nice step sizes are 0.01, 20 and 500."},

    // Class TridiagonalDecompositionData

    // Class TwobitVector
    {"void ::genesis::utils::TwobitVector::clear ()", "Clear the vector, so that it contains no data."},
    {"WordType const & ::genesis::utils::TwobitVector::data_at (size_t index) const", "Return a single word of the vector.\n\nThis is useful for external functions that want to directly work on the underlying bit representation."},
    {"WordType & ::genesis::utils::TwobitVector::data_at (size_t index)", "Return a single word of the vector.\n\nThis is useful for external functions that want to directly work on the underlying bit representation."},
    {"size_t ::genesis::utils::TwobitVector::data_size () const", "Return the number of words (of type WordType) that are used to store the values in the vector."},
    {"ValueType ::genesis::utils::TwobitVector::get (size_t index) const", "Get the value at a position in the vector."},
    {"WordType ::genesis::utils::TwobitVector::hash () const", "Calculate a hash value of the vector, based on its size() and the xor of all its words.\n\nThis is a simple function, but might just be enough for using it in a hashmap."},
    {"void ::genesis::utils::TwobitVector::insert_at (size_t index, ValueType value)", "Insert a value at a position.\n\nThe size() is increased by one."},
    {"void ::genesis::utils::TwobitVector::remove_at (size_t index)", "Remove the value at a position.\n\nThe size() is decreased by one."},
    {"void ::genesis::utils::TwobitVector::set (size_t index, ValueType value)", "Set a value at a position in the vector."},
    {"size_t ::genesis::utils::TwobitVector::size () const", "Return the size of the vector, that is, how many values (of type ValueType) it currently holds."},
    {"bool ::genesis::utils::TwobitVector::validate () const", "Validation function that checks some basic invariants.\n\nThis is mainly useful in testing. The function checks whether the vector is correctly sized and contains zero padding at its end."},

    // Class XmlComment

    // Class XmlDocument

    // Class XmlElement

    // Class XmlMarkup

    // Class XmlValue

    // Class XmlWriter
    {"void ::genesis::utils::XmlWriter::to_file (const XmlDocument & document, const std::string & filename)", "Write an XML file from an XmlDocument. Return true iff successful.\n\nIf the file cannot be written to, the function throws an exception. Also, by default, if the file already exists, an exception is thrown. See Options::allow_file_overwriting() to change this behaviour."},
    {"void ::genesis::utils::XmlWriter::to_string (const XmlDocument & document, std::string & output)", "Give the XML string representation of a XmlDocument."},
    {"std::string ::genesis::utils::XmlWriter::to_string (const XmlDocument & document)", "Return the XML representation of a XmlDocument."},

    // Class BitmapFileheader

    // Class BitmapInfo

    // Class BitmapInfoheader

    // Class RgbQuad

    // Class Column

    // Class ZlibData

    // Class InternalIterator

    // Class PrimitiveIterator

    // Class Iterator

    // Class Iterator

    // Class Entry

    // Class Concept

    // Class Model

    // Class Concept

    // Class Model

    // Class Matrix

    // Class Rotate

    // Class Scale

    // Class Skew

    // Class Transformation

    // Class Translate

    // Class Concept

    // Class Model

    // Class Column
    {"void ::genesis::utils::Table::Column::shrink_width ()", "Shrinks the column width to the minmal width that suffices to fit in all values of the column (i.e., both data and label).\n\nThe column keeps track of its needed minimal width when just adding data. Thus, this function is only neccessary to call once the width was changed manually or if the label or a data value have been changed after being added."},
    {"void ::genesis::utils::Table::Column::width (size_t value)", "Set the width of this column.\n\nIf the new value is smaller than the current one, nothing happens. The width can only grow, or be set to the minimal possible value using shrink_width(). This ensures that all text fits within the column."},

    // Class Binder

    // Class Line

    // Class LabeledTick

    // Class DigestType >

    // Class DigestType >

    // Class DigestType >


    // Functions
    {"std::vector< size_t > ::genesis::utils::sort_indices (RandomAccessIterator first, RandomAccessIterator last)", "Get the indices to the sorted order of the given range.\n\nThis function returns a list of indices into the given range, so that their order gives the sorted content of the elements in [ first, last ), using std::less for comparisons.For example, for( auto i: sort_indices(v) ) {\n    cout << *( first + i ) << endl;\n}\noutputs the elements in the range in sorted order, without actually moving any elements in the range. This is useful if the same sorting order needs to be applied to some other container.There is also an overload of this function that takes an additional parameter comparator. It can be used to specify the function for comparing two values of the range.Furthermore, there are variants that use std::stable_sort instead, see stable_sort_indices()."},
    {"double ::genesis::utils::spearmans_rank_correlation_coefficient (RandomAccessIteratorA first_a, RandomAccessIteratorA last_a, RandomAccessIteratorB first_b, RandomAccessIteratorB last_b)", "Calculate Spearman's Rank Correlation Coefficient between two ranges of double.\n\nBoth ranges need to have the same length. Then, the function calculates Spearmans's Rho between the pairs of entries of both vectors. Ranking is done via fractional ranking. Pairs of entries which contain non-finite values are skipped."},
    {"double ::genesis::utils::spearmans_rank_correlation_coefficient (std::vector< double > const & vec_a, std::vector< double > const & vec_b)", "Calculate Spearman's Rank Correlation Coefficient between the entries of two vectors.\n\nBoth ranges need to have the same length. Then, the function calculates Spearmans's Rho between the pairs of entries of both vectors. Ranking is done via fractional ranking. Pairs of entries which contain non-finite values are skipped."},
    {"std::vector< std::string > ::genesis::utils::split (std::string const & string, std::function< size_t(std::string const &, size_t)> find_pos, size_t advance_by, const bool trim_empty)", "Local function that does the work for the split cuntions."},
    {"std::vector< std::string > ::genesis::utils::split (std::string const & str, std::string const & delimiters=\" \", const bool trim_empty=true)", "Spilt a string into parts, given a delimiters set of chars.\n\nThe string is split using any of the chars in delimiters and returned as a vector of strings. If trim_empty is set, empty strings resulting from adjacent delimiter chars are excluded from the output."},
    {"std::vector< std::string > ::genesis::utils::split (std::string const & str, std::function< bool(char)> delimiter_predicate, const bool trim_empty=true)", "Spilt a string into parts, given a delimiter_predicate that returns true for delimiters chars.\n\nThe string is split using any of the chars for which delimiter_predicate is true, and returned as a vector of strings. If trim_empty is set, empty strings resulting from adjacent delimiter chars are excluded from the output."},
    {"std::vector< std::string > ::genesis::utils::split_at (std::string const & str, std::string const & delimiter, const bool trim_empty=true)", "Spilt a string into parts, given a delimiter string.\n\nThe string is split where the whole delimiter string is found, and returned as a vector of strings. If trim_empty is set, empty strings resulting from adjacent delimiters are excluded from the output."},
    {"std::vector< size_t > ::genesis::utils::split_range_list (std::string const & str)", "Split a string containing positive interger numbers into its parts and resolve ranges.\n\nFor example, the string 1, 3, 5-7, 10 results in a vector of all listed numbers and the ranges in between, that is 1, 3, 5, 6, 7, 10. Whitespace is ignored; the range is sorted."},
    {"std::vector< size_t > ::genesis::utils::stable_sort_indices (RandomAccessIterator first, RandomAccessIterator last, Comparator comparator)", "Get the indices to the stable sorted order of the given range.\n\nThis function returns a list of indices into the given range, so that their order gives the stable sorted content of the elements in [ first, last ), using std::less for comparisons.For example, for( auto i: stable_sort_indices(v) ) {\n    cout << *( first + i ) << endl;\n}\noutputs the elements in the range in stable sorted order, without actually moving any elements in the range. This is useful if the same sorting order needs to be applied to some other container.There is also an overload of this function that takes an additional parameter comparator. It can be used to specify the function for comparing two values of the range.Furthermore, there are variants that use normal std::sort instead, see sort_indices()."},
    {"std::vector< size_t > ::genesis::utils::stable_sort_indices (RandomAccessIterator first, RandomAccessIterator last)", "Get the indices to the stable sorted order of the given range.\n\nThis function returns a list of indices into the given range, so that their order gives the stable sorted content of the elements in [ first, last ), using std::less for comparisons.For example, for( auto i: stable_sort_indices(v) ) {\n    cout << *( first + i ) << endl;\n}\noutputs the elements in the range in stable sorted order, without actually moving any elements in the range. This is useful if the same sorting order needs to be applied to some other container.There is also an overload of this function that takes an additional parameter comparator. It can be used to specify the function for comparing two values of the range.Furthermore, there are variants that use normal std::sort instead, see sort_indices()."},
    {"std::vector< MeanStddevPair > ::genesis::utils::standardize_cols (Matrix< double > & data, bool scale_means=true, bool scale_std=true)", "Standardize the columns of a Matrix by subtracting the mean and scaling to unit variance.\n\nThe function performs a column-wise z-transformation on the given data.The function returns a vector containing the mean and standard deviation of the columns before standardization, see MeanStddevPair. If both scale_means and scale_std are set to false, the original data is not manipulated, while the returned vector still contains the means and standard deviations. See also matrix_col_mean_stddev().\n\ndata\n\n\nInput data Matrix; standardizing is done inline. \n\n\n\nscale_means\n\n\nIf true (default), center the data by subtracting the mean per column. \n\n\n\nscale_std\n\n\nIf true (default), scale the data to unit variance (or equivalently, unit standard deviation) per column. \n\n\nVector containing the mean and standard deviation for each column before standardization."},
    {"std::vector< MeanStddevPair > ::genesis::utils::standardize_rows (Matrix< double > & data, bool scale_means=true, bool scale_std=true)", "Standardize the rows of a Matrix by subtracting the mean and scaling to unit variance.\n\nThe function performs a row-wise z-transformation on the given data.The function returns a vector containing the mean and standard deviation of the rows before standardization, see MeanStddevPair. If both scale_means and scale_std are set to false, the original data is not manipulated, while the returned vector still contains the means and standard deviations. See also matrix_row_mean_stddev().\n\ndata\n\n\nInput data Matrix; standardizing is done inline. \n\n\n\nscale_means\n\n\nIf true (default), center the data by subtracting the mean per column. \n\n\n\nscale_std\n\n\nIf true (default), scale the data to unit variance (or equivalently, unit standard deviation) per column. \n\n\nVector containing the mean and standard deviation for each column before standardization."},
    {"bool ::genesis::utils::starts_with (std::string const & text, std::string const & start)", "Return whether a string starts with another string."},
    {"Matrix< double > ::genesis::utils::sums_of_squares_and_cross_products_matrix (Matrix< double > const & data)", "Calculate the Sums of Squares and Cross Products Matrix (SSCP Matrix)."},
    {"std::string ::genesis::utils::svg_arc (double center_x, double center_y, double radius, double start_angle, double end_angle)", "Create an arc to use in an SvgPath.\n\nExample: SvgPath(\n    { svg_arc( 0, 0, 10, start_a, end_a ) },\n    stroke\n);\nThe angles are measured in radians."},
    {"std::string ::genesis::utils::tail (std::string const & text, size_t lines)", "Return the last lines of the text."},
    {"std::string ::genesis::utils::to_lower (std::string const & str)", "Return an all-lowercase copy of the given string, locale-aware."},
    {"char ::genesis::utils::to_lower_ascii (char c)", "Return the lower case of a given char, ascii-only."},
    {"std::string ::genesis::utils::to_lower_ascii (std::string const & str)", "Return an all-lowercase copy of the given string, ascii-only."},
    {"void ::genesis::utils::to_lower_ascii_inplace (std::string & str)", "Turn the given string to all-lowercase, ascii-only."},
    {"void ::genesis::utils::to_lower_inplace (std::string & str)", "Turn the given string to all-lowercase, locale-aware."},
    {"std::string ::genesis::utils::to_nucleic_acids (TwobitVector const & vec)", "Turn a TwobitVector into its string representation of nucleic acids."},
    {"std::string ::genesis::utils::to_string (T const & v)", "Return a string representation of a given value.\n\nThis function template is a drop-in replacement for std::to_string, with the difference that it treats floating point numbers more nicely: Instead of printing a fixed amount of digits, it only prints digits without trailing zeros.If you also want to round the value, or need more precision, see to_string_precise() and to_string_rounded().As it uses operator << on the given value, it is suitable for any class or value for which this stream operator is available. Thus, this function can also be used for conveniently returning a string where otherwise some stream operations would have been necessary."},
    {"std::string ::genesis::utils::to_string_leading_zeros (size_t value, size_t length=6)", "Return a string representation of a size_t value with a fixed length, that is, by adding leading zeros.\n\nIf value is already longer than length, the result will also be longer."},
    {"std::string ::genesis::utils::to_string_precise (double value, int precision=6)", "Return a precise string representation of the input value, using the provided precision value (determining its decimal places).\n\nThis function rounds the value to the given precision, and then returns its string representation with possible trailing zeros. Thus, it uses fixed precision. This is useful for e.g., output in a table format.For a version of this function that truncates trailing zeros, see to_string_rounded(). Also, see to_string() if you simply want to output a string representation of a double."},
    {"std::string ::genesis::utils::to_string_rounded (double value, int precision=6)", "Return a string representation of the input value, using the provided precision value (determining its decimal places) to round, and truncate trailing zeros.\n\nThis function rounds the value to the given precision, and then returns its string representation without trailing zeros. This is useful for output that keeps a certain amount of significant decimal digits, while making the output as short as possible.If you want to round, but also keep trailing zeros, see to_string_precise(). Also, see to_string() if you simply want to output a string representation of a double."},
    {"std::string ::genesis::utils::to_upper (std::string const & str)", "Return an all-uppercase copy of the given string, locale-aware."},
    {"char ::genesis::utils::to_upper_ascii (char c)", "Return the upper case of a given char, ascii-only."},
    {"std::string ::genesis::utils::to_upper_ascii (std::string const & str)", "Return an all-uppercase copy of the given string, ascii-only."},
    {"void ::genesis::utils::to_upper_ascii_inplace (std::string & str)", "Turn the given string to all-uppercase, ascii-only."},
    {"void ::genesis::utils::to_upper_inplace (std::string & str)", "Turn the given string to all-uppercase, locale-aware."},
    {"TwobitVector::ValueType ::genesis::utils::translate_from_nucleic_acid (char site)", "Translate a char into TwobitVector::ValueType.\n\nValid chars are A, C, G, T, and their lower case variants."},
    {"char ::genesis::utils::translate_to_nucleic_acid (TwobitVector::ValueType value)", "Translate a TwobitVector::ValueType into its char representation.\n\nThis gives one of the values A, C, G and T."},
    {"size_t ::genesis::utils::triangular_index (size_t i, size_t j, size_t n)", "Given indices i and j in a quadratic Matrix, find the corresponding linear index.\n\nSee triangular_indices() for the opposite function, which also explains the details, and triangular_size() to calculate the maximal k that will occur in a trian Matrix of a given size n.\n\ni\nj\n\n\nIndices of the Matrix for which to calculate the linear index k. \n\n\n\nn\n\n\nSize of the quadratic Matrix, i.e., the row/column length. \n\n\nLinear index k for the given i and j."},
    {"std::pair< size_t, size_t > ::genesis::utils::triangular_indices (size_t k, size_t n)", "Given a linear index in a upper triangular Matrix, find the corresponding Matrix indices.\n\nGiven an upper triangle Matrix of size n == 5 0  k0  k1  k2  k3\n0   0  k4  k5  k6\n0   0   0  k7  k8\n0   0   0   0  k9\n0   0   0   0   0\nand given a k (like above), find the corresponding indices i and j for this k, e.g., k == 0 --> i == 0, j == 1\nk == 5 --> i == 1, j == 3\nk == 9 --> i == 3, j == 4\n...\nBecause the calculation involves solving triangular numbers, the function internally operates on double values. This is a bit smelly, but seems to work (tested with n == 100,000).See also triangular_index() for the opposite function, and triangular_size() to calculate the maximal k that will occur in a trian Matrix of a given size n.\n\nk\n\n\nLinear index in the upper triangle of a quadratic Matrix. \n\n\n\nn\n\n\nSize of the quadratic Matrix, i.e., the row/column length. \n\n\nPair ( i, j ) of the indices for the given k."},
    {"size_t ::genesis::utils::triangular_size (size_t n)", "Calculate the number of linear indices needed for a triangular Matrix of size n.\n\nGiven an upper triangle Matrix of size n == 5 0  k0  k1  k2  k3\n0   0  k4  k5  k6\n0   0   0  k7  k8\n0   0   0   0  k9\n0   0   0   0   0\nwe need 10 indices k == 0..9 to linearly describe the positions in the triangle. This function returns this number of indices for a given n.See also triangular_indices() for calculating the Matrix indices i and j for a given k.\n\nn\n\n\nSize of the quadratic Matrix, i.e., the row/column length. \n\n\nNumber of needed linear indices k to describe a triangle of the Matrix."},
    {"void ::genesis::utils::tridiagonal_ql_algorithm (Matrix< double > & data, TridiagonalDecompositionData & tri, size_t max_iterations=1000)", "Reduce a symmetric matrix to a symmetric tridiagonal matrix.\n\nUses the data and the intermediate result after executing reduce_to_tridiagonal_matrix() in order to run the algorithm. See there for details.Both parameters are modified during the algorithm. After it is finished, tri.eigenvalues contains the eigenvalus and data the associated eigenvectors of the original data.The implementation of this function is largely borrowed from http://www.classification-society.org/csna/mda-sw/pca.c published as Public Domain by Fionn Murtagh.\n\ndata\n\n\nInput data matrix. Operations are performed inline, that is, the matrix is changed during execution of the function. \n\n\n\ntri\n\n\nTridiagonal matrix coming from reduce_to_tridiagonal_matrix(). \n\n\n\nmax_iterations\n\n\nMaximum number of iterations to perform, default is 1000. If set to 0, the algorithm continues until convergence. As convergence is not given for all data, this might result in an infinite loop."},
    {"std::string ::genesis::utils::trim (std::string const & s, std::string const & delimiters)", "Return a copy of the input string, with trimmed white spaces."},
    {"std::string ::genesis::utils::trim_left (std::string const & s, std::string const & delimiters)", "Return a copy of the input string, with right trimmed white spaces."},
    {"std::string ::genesis::utils::trim_right (std::string const & s, std::string const & delimiters)", "Return a copy of the input string, with left trimmed white spaces."},
    {"std::string ::genesis::utils::xml_deescape (std::string const & txt)", "De-escape special XML characters."},
    {"std::string ::genesis::utils::xml_escape (std::string const & txt)", "Escape special XML characters."},
    {"const XmlComment * ::genesis::utils::xml_value_to_comment (const XmlValue * v)", "Converts a pointer to an XmlValue to XmlComment if appropriate.\n\nThrows if the dynamic type of the object is not actually an XmlComment object."},
    {"const XmlElement * ::genesis::utils::xml_value_to_element (const XmlValue * v)", "Converts a pointer to an XmlValue to XmlElement if appropriate.\n\nThrows if the dynamic type of the object is not actually an XmlElement object."},
    {"const XmlMarkup * ::genesis::utils::xml_value_to_markup (const XmlValue * v)", "Converts a pointer to an XmlValue to XmlMarkup if appropriate.\n\nThrows if the dynamic type of the object is not actually an XmlMarkup object."},
    {"std::string ::genesis::utils::file_path (std::string const & filename)", "Return the path leading to a file.\n\nDoes not resolve the path. Simply splits at the last directory separator. If there is no directory separator, it returns an empty string."},
    {"std::string ::genesis::utils::file_read (std::string const & filename)", "Return the contents of a file as a string.\n\nIf the file is not readable, the function throws std::runtime_error."},
    {"size_t ::genesis::utils::file_size (std::string const & filename)", "Return the size of a file."},
    {"void ::genesis::utils::file_write (std::string const & content, std::string const & filename)", "Write the content of a string to a file.\n\nIf the file cannot be written to, the function throws an exception. Also, by default, if the file already exists, an exception is thrown. See Options::allow_file_overwriting() to change this behaviour."},
    {"std::pair< std::vector< double >, std::vector< double > > ::genesis::utils::finite_pairs (ForwardIteratorA first_a, ForwardIteratorA last_a, ForwardIteratorB first_b, ForwardIteratorB last_b)", "Helper function that cleans two ranges of double of the same length from non-finite values.\n\nThis function is used for cleaning data input. It iterates both same-length ranges in parallel and copies pairs elements to the two result vectors (one for each range), if both values are finite. The result vectors thus have equal size."},
    {"double ::genesis::utils::fisher_transformation (double correlation_coefficient)", "Apply Fisher z-transformation to a correlation coefficient.\n\nThe coefficient can be calculated with pearson_correlation_coefficient() or spearmans_rank_correlation_coefficient() and has to be in range [ -1.0, 1.0 ].There is also a version of this function for a vector of coefficients. See also matrix_col_pearson_correlation_coefficient(), matrix_row_pearson_correlation_coefficient(), matrix_col_spearmans_rank_correlation_coefficient() and matrix_row_spearmans_rank_correlation_coefficient() for matrix versions."},
    {"std::vector< double > ::genesis::utils::fisher_transformation (std::vector< double > const & correlation_coefficients)", "Apply Fisher z-transformation to a vector of correlation coefficients.\n\nSee fisher_transformation( double ) for details."},
    {"TwobitVector ::genesis::utils::from_nucleic_acids (std::string const & sequence)", "Turn a string of nucleic acids into a TwobitVector."},
    {"double ::genesis::utils::geo_distance (GeoCoordinate const & c1, GeoCoordinate const & c2)", "Calculate the distance (in km) between two points on Earth.\n\nUses the Haversine formula. See convert_geo_coordinate() for a conversion function for geographical coordinates."},
    {"std::string ::genesis::utils::get_attribute_string (Style const & s)", "Internal helper function that returns the attribute string of a Style based on its properties."},
    {"static std::array< std::pair< std::string, std::string >, 17 >::const_iterator ::genesis::utils::get_background_color_iterator (std::string name)", "Internal helper function that returns an iterator into the background color list."},
    {"NamedColorList::const_iterator ::genesis::utils::get_color_list_iterator_ (NamedColorList const & list, std::string name)", "Internal helper function.\n\nReturns an iterator into the vector if the given name is a named color or an iterator to the end of the color map if it is not a named color."},
    {"static std::array< std::pair< std::string, std::string >, 17 >::const_iterator ::genesis::utils::get_foreground_color_iterator (std::string name)", "Internal helper function that returns an iterator into the foreground color list."},
    {"Color ::genesis::utils::gradient (std::map< double, Color > const & ranges, double value)", "Returns a Color that is created using a color gradient.\n\nThe function takes a color gradient in form of a map from double to Color. The keys in the map are offset positions (stops) with specific Colors assigned to them. An arbitrary number of keys in between these boundaries is allowed.Each key is associated with a Color value, which indicates the color at that position.Example: // Prepare gradient ranges.\nauto ranges = std::map<double, Color>();\nranges[ 0.0 ] = Color( 0.0, 1.0, 0.0 );\nranges[ 0.5 ] = Color( 1.0, 1.0, 0.0 );\nranges[ 1.0 ] = Color( 1.0, 0.0, 0.0 );\n\n// Get color at 30% of the green-yellow-red gradient.\nColor c = gradient( ranges, 0.3 );\nThis map defines the same gradient that is used for heat_gradient. The range boundaries do not have to be [ 0.0, 1.0 ]. They can be set to any range that is needed to reflect the range of possible values.The second parameter of this function then takes the position at which the gradient is evaluated. Values outside of the interval that is defined by the range are set to the closest interval border value.For example, given the range map above, a value of 0.0 gives green; 0.5 gives yellow; 1.0 gives red; values in between are interpolated linearily."},
    {"std::string ::genesis::utils::hash_from_file_hex (std::string const & filename, HashingFunctions hash_fct)", "Calcualte the hash of a file, using a given hashing function, and return its hex representation as a string.\n\nSee HashingFunctions for the list of available hashing functions.hash_from_string_hex() hash_from_stream_hex()"},
    {"std::string ::genesis::utils::hash_from_stream_hex (std::istream & is, HashingFunctions hash_fct)", "Calcualte the hash of an input stream, using a given hashing function, and return its hex representation as a string.\n\nSee HashingFunctions for the list of available hashing functions.hash_from_file_hex() hash_from_string_hex()"},
    {"std::string ::genesis::utils::hash_from_string_hex (std::string const & input, HashingFunctions hash_fct)", "Calcualte the hash of a string, using a given hashing function, and return its hex representation as a string.\n\nSee HashingFunctions for the list of available hashing functions.hash_from_file_hex() hash_from_stream_hex()"},
    {"std::string ::genesis::utils::head (std::string const & text, size_t lines)", "Return the first lines of the text."},
    {"Color ::genesis::utils::heat_gradient (double percentage)", "Return a Color that represents a heat gradient for a given percentage value.\n\nGiven a percentage value in the range of [ 0.0, 1.0], the functions represents the heat of that value. For 0.0, the heat gradient value is green, for 0.5 yellow and for 1.0 red. The values in between are interpolated linearily."},
    {"std::string ::genesis::utils::indent (std::string const & text, std::string const & indentation=\"    \")", "Indent each line of text with indentation and return the result.\n\nBy default, four spaces are used to indent. Whether the text ends with a new line or not is not changed. Any trailing indentation chars are trimmed, in order to not have trailing whitespaces in the result (except for the new line, if the text ends in one)."},
    {"double ::genesis::utils::index_of_dispersion (MeanStddevPair const & ms)", "Calculate the index of dispersion.\n\nThe index of dispersion, also known as the dispersion index, coefficient of dispersion, relative variance, variance-to-mean ratio (VMR) or Fano factor, is defined as the ratio of the variance to the mean. Variance is the square of the standard deviation. See mean_stddev() to calcualte those values. See https://en.wikipedia.org/wiki/Index_of_dispersion for details."},
    {"std::vector< double > ::genesis::utils::index_of_dispersion (std::vector< MeanStddevPair > const & ms)", "Calculate the index of dispersion.\n\nThe index of dispersion, also known as the dispersion index, coefficient of dispersion, relative variance, variance-to-mean ratio (VMR) or Fano factor, is defined as the ratio of the variance to the mean. Variance is the square of the standard deviation. See mean_stddev() to calcualte those values. See https://en.wikipedia.org/wiki/Index_of_dispersion for details."},
    {"std::vector< T >::iterator ::genesis::utils::insert_sorted (std::vector< T > & vec, T const & item)", "Insert into a vector vec, sorted by the value of the item. The vector must already be sorted."},
    {"std::vector< T >::iterator ::genesis::utils::insert_sorted (std::vector< T > & vec, T const & item, Pred pred)", "Insert into a vector vec, sorted by the value of the item, using a predicate. The vector must already be sorted according to the predicate."},
    {"size_t ::genesis::utils::int_pow (size_t base, size_t exp)", "Calculate the power base^exp for positive integer values.\n\nRemark: This overflows quite easily. The function does not check whether the desired power actually fits within size_t. Use is_valid_int_pow() to check for this first.Rationale for this function: One could argue that int powers are not really useful, particularly because of the fast overflow. However, using doubles leads to rounding errors, at least for bigger numbers. So, within the valid range, this function is more accurate. Also, it is faster."},
    {"Color ::genesis::utils::interpolate (Color const & color1, Color const & color2, double fraction)", "Linearily interpolate between two Colors."},
    {"bool ::genesis::utils::is_color_name (std::string const & name)", "Return true if the name represents one of the named colors offered by genesis, which is (currently) a shortcut for is_web_color_name() and is_xkcd_color_name()."},
    {"bool ::genesis::utils::is_dir (std::string const & path)", "Return true iff the provided path is a directory.\n\nInternally, this function simply return the value of dir_exists(), as this already does the needed check. Thus, it is an alias."},
    {"bool ::genesis::utils::is_file (std::string const & path)", "Return true iff the provided path is a file.\n\nInternally, this function simply return the value of file_exists(), as this already does the needed check. Thus, it is an alias."},
    {"bool ::genesis::utils::is_strict_subset (Bitvector const & sub, Bitvector const & super)", "Strict subset."},
    {"bool ::genesis::utils::is_strict_superset (Bitvector const & super, Bitvector const & sub)", "Strict superset."},
    {"bool ::genesis::utils::is_subset (Bitvector const & sub, Bitvector const & super)", "Subset or equal."},
    {"bool ::genesis::utils::is_superset (Bitvector const & super, Bitvector const & sub)", "Superset or equal."},
    {"bool ::genesis::utils::is_valid_filname (std::string const & filename)", "Check whether a file name is valid.\n\nValidating filenames depends on the operating system and file system of the disk. Thus, this is usually not an easy task. This function only checks some basics and is meant to catch the most common problems.The function is meant to be called on the file name itself, without the directory path leading to it. File extensions are allowed. Thus, you might need to call file_basename() before in order to get the file name without the path.Invalid filenames are:\nThose with spaces at the beginning or end, or only consisting of spaces (or empty).Those which contain any of the chars < > : \" \\ / | ? *.Those which contain any non-printable character, as determined via isprint().\nThis might be too converative for some system, or allow too much for others. It however should return true for filenames that work on most systems."},
    {"bool ::genesis::utils::is_valid_int_pow (size_t base, size_t exp)", "Return whether the given power can be stored within a size_t.\n\nUse int_pow() to calculate the actual value of the power."},
    {"bool ::genesis::utils::is_web_color_name (std::string const & name)", "Return true iff the given name is a named web color.\n\nNames are filtered so that spaces, underscores and the letter case are ignored."},
    {"bool ::genesis::utils::is_xkcd_color_name (std::string const & name)", "Return true iff the given name is a named xkcd color.\n\nNames are filtered so that spaces, underscores and the letter case are ignored. See color_from_name_xkcd() for details on this color list."},
    {"std::string ::genesis::utils::join (T const & v, std::string const & delimiter)", "Return a string where the elements of a container v are joined using the string delimiter in between them.\n\nThe container is iterated via its range based for loop, thus it needs to have begin() and end() functions.For turning the elements of the container into a string, their operator << is used. Thus, this function can used with all types that support this operator."},
    {"long ::genesis::utils::logging_progress_value (long value=-1)", "Hack function to make sure that the value arugment in LOG_PROG is only evaluated once.\n\nWithout this function, LOG_PROG would include two appearances of its variable value, which means that a statement like LOG_PROG(++i, n) << \"of progress.\";\nwould lead to a double evaluation of the increment statement ++i. That is not intended, thus we need this hack function."},
    {"std::unique_ptr< T > ::genesis::utils::make_unique (Args &&... args)", "Returns a std::unique_ptr for a given type.\n\nSince this is not available in C++11, we need our own implementation. It is following http://herbsutter.com/gotw/_102/"},
    {"Matrix< T > ::genesis::utils::matrix_addition (Matrix< A > const & a, Matrix< B > const & b)", "Calculate the element-wise sum of two Matrices.\n\nThe two matrices need to have the same dimensions."},
    {"Matrix< T > ::genesis::utils::matrix_addition (Matrix< A > const & matrix, B const & scalar)", "Calculate the element-wise sum of a Matrix and a scalar."},
    {"std::vector< MeanStddevPair > ::genesis::utils::matrix_col_mean_stddev (Matrix< double > const & data, double epsilon=-1.0)", "Calcualte the column-wise mean and standard deviation of a Matrix.\n\nIf the resulting standard deviation is below the given epsilon (e.g, 0.0000001), it is \"corrected\" to be 1.0 instead. This is an inelegant (but usual) way to handle near-zero values, which for some use cases would cause problems like a division by zero later on. By default, epsilon is -1.0, which deactivates this check - a standard deviation can never be below 0.0.See also matrix_row_mean_stddev() and matrix_mean_stddev()."},
    {"std::vector< MinMaxPair< T > > ::genesis::utils::matrix_col_minmax (Matrix< T > const & data)", "Calculate the column-wise min and max values of a Matrix.\n\nSee also matrix_row_minmax() and matrix_minmax()."},
    {"double ::genesis::utils::matrix_col_pearson_correlation_coefficient (Matrix< double > const & mat1, size_t col1, Matrix< double > const & mat2, size_t col2)", "Calculate the Pearson Correlation Coefficient between two columns of two Matrices.\n\nBoth Matrices need to have the same number of rows. Then, the function calculates the PCC between column col1 of Matrix mat1 and column col2 of Matrix mat2."},
    {"double ::genesis::utils::matrix_col_spearmans_rank_correlation_coefficient (Matrix< double > const & mat1, size_t col1, Matrix< double > const & mat2, size_t col2)", "Calculate Spearman's Rank Correlation Coefficient between two columns of two Matrices.\n\nBoth Matrices need to have the same number of rows. Then, the function calculates Spearman's Rho between column col1 of Matrix mat1 and column col2 of Matrix mat2."},
    {"std::vector< T > ::genesis::utils::matrix_col_sums (Matrix< T > const & data)", "Calculate the sum of each column and return the result as a vector.\n\nSee also matrix_row_sums() and matrix_sum()."},
    {"bool ::genesis::utils::matrix_is_symmetric (Matrix< T > const & data)", "Return whether a Matrix is symmetric, i.e., whether it is square and m[ i, j ] == m[ j, i ] holds for all entries."},
    {"MeanStddevPair ::genesis::utils::matrix_mean_stddev (Matrix< double > const & data, double epsilon=-1.0)", "Calcualte the mean and standard deviation of all elements in a Matrix.\n\nIf the resulting standard deviation is below the given epsilon (e.g, 0.0000001), it is \"corrected\" to be 1.0 instead. This is an inelegant (but usual) way to handle near-zero values, which for some use cases would cause problems like a division by zero later on. By default, epsilon is -1.0, which deactivates this check - a standard deviation can never be below 0.0.See also matrix_row_mean_stddev() and matrix_col_mean_stddev()."},
    {"MinMaxPair< T > ::genesis::utils::matrix_minmax (Matrix< T > const & data)", "Calculate the min and max values of a Matrix.\n\nSee also matrix_col_minmax() and matrix_row_minmax()."},
    {"Matrix< T > ::genesis::utils::matrix_multiplication (Matrix< A > const & a, Matrix< B > const & b)", "Calculate the product of two Matrices.\n\nThe two matrices need to have fitting dimensions, i.e., a[ l, m ] x b[ m, n ], which results in a Matrix of dimensions r[ l, n ]."},
    {"std::vector< T > ::genesis::utils::matrix_multiplication (std::vector< A > const & a, Matrix< B > const & b)", "Calculate the product of a vector a with a Matrices b, as if the vector was a Matrix with only one row.\n\nThus, the two arguments need to have fitting dimensions, i.e., a[ m ] x b[ m, n ]. The resulting vector has size n, which represent the columns of the result Matrix."},
    {"std::vector< T > ::genesis::utils::matrix_multiplication (Matrix< A > const & a, std::vector< B > const & b)", "Calculate the product of a Matrices a with a vector b, as if the vector was a Matrix with only one column.\n\nThus, the two arguments need to have fitting dimensions, i.e., a[ l, m ] x b[ m ]. The resulting vector has size l, which represent the rows of the result Matrix."},
    {"Matrix< T > ::genesis::utils::matrix_multiplication (Matrix< A > const & matrix, B const & scalar)", "Calculate the element-wise multiplication of a Matrix and a scalar."},
    {"Quartiles ::genesis::utils::matrix_quartiles (Matrix< double > const & data)", "Calculate the Quartiles of the elmements in Matrix of double."},
    {"std::vector< MeanStddevPair > ::genesis::utils::matrix_row_mean_stddev (Matrix< double > const & data, double epsilon=-1.0)", "Calcualte the row-wise mean and standard deviation of a Matrix.\n\nIf the resulting standard deviation is below the given epsilon (e.g, 0.0000001), it is \"corrected\" to be 1.0 instead. This is an inelegant (but usual) way to handle near-zero values, which for some use cases would cause problems like a division by zero later on. By default, epsilon is -1.0, which deactivates this check - a standard deviation can never be below 0.0.See also matrix_col_mean_stddev() and matrix_mean_stddev()."},
    {"std::vector< MinMaxPair< T > > ::genesis::utils::matrix_row_minmax (Matrix< T > const & data)", "Calculate the row-wise min and max values of a Matrix.\n\nSee also matrix_col_minmax() and matrix_minmax()."},
    {"double ::genesis::utils::matrix_row_pearson_correlation_coefficient (Matrix< double > const & mat1, size_t row1, Matrix< double > const & mat2, size_t row2)", "Calculate the Pearson Correlation Coefficient between two row of two Matrices.\n\nBoth Matrices need to have the same number of columns. Then, the function calculates the PCC between row row1 of Matrix mat1 and row row2 of Matrix mat2."},
    {"double ::genesis::utils::matrix_row_spearmans_rank_correlation_coefficient (Matrix< double > const & mat1, size_t row1, Matrix< double > const & mat2, size_t row2)", "Calculate Spearman's Rank Correlation Coefficient between two row of two Matrices.\n\nBoth Matrices need to have the same number of columns. Then, the function calculates Spearman's Rho between row row1 of Matrix mat1 and row row2 of Matrix mat2."},
    {"std::vector< T > ::genesis::utils::matrix_row_sums (Matrix< T > const & data)", "Calculate the sum of each row and return the result as a vector.\n\nSee also matrix_col_sums() and matrix_sum()."},
    {"Matrix< T > ::genesis::utils::matrix_sort_by_col_sum_symmetric (Matrix< T > const & data)", "Sort rows and columns of a Matrix by the sum or the columns.\n\nThis is an operation for square matrices: It takes the row sum as sorting criterion, and sorts the rows and the columns according to that order. This is mostly useful for symmetric matrices, where m[ i, j ] == m[ j, i ]. In those cases, the sorting is stable with respect to the symmetry.See also matrix_sort_by_row_sum_symmetric(). In case of symmetric matrices, it should yield the same Matrix."},
    {"Matrix< T > ::genesis::utils::matrix_sort_by_row_sum_symmetric (Matrix< T > const & data)", "Sort rows and columns of a Matrix by the sum or the rows.\n\nThis is an operation for square matrices: It takes the row sum as sorting criterion, and sorts the rows and the columns according to that order. This is mostly useful for symmetric matrices, where m[ i, j ] == m[ j, i ]. In those cases, the sorting is stable with respect to the symmetry.See also matrix_sort_by_col_sum_symmetric(). In case of symmetric matrices, it should yield the same Matrix."},
    {"Matrix< T > ::genesis::utils::matrix_sort_diagonal_symmetric (Matrix< T > const & data)", "Sort a Matrix so that the highest entries are on the diagonal.\n\nThe Matrix is sorted by moving the row and col with the highest entry to [ 0, 0 ], and then applying this operation to the rest of the matrix (that is, excluding the first row and col) iteratievly. The Matrix does not have to be symmetrical, but sorting keeps rows and columns intact."},
    {"Matrix< T > ::genesis::utils::matrix_subtraction (Matrix< A > const & a, Matrix< B > const & b)", "Calculate the element-wise difference of two Matrices.\n\nThe two matrices need to have the same dimensions."},
    {"T ::genesis::utils::matrix_sum (Matrix< T > const & data)", "Calculate the sum of all elements in a Matrix.\n\nSee also matrix_col_sums() and matrix_row_sums()."},
    {"void ::genesis::utils::matrix_swap_cols (Matrix< T > & data, size_t col_a, size_t col_b)", "Swap (interchange) two columns of a Matrix, given their indices."},
    {"void ::genesis::utils::matrix_swap_rows (Matrix< T > & data, size_t row_a, size_t row_b)", "Swap (interchange) two rows of a Matrix, given their indices."},
    {"Matrix< T > ::genesis::utils::matrix_transpose (Matrix< T > const & data)", "Transpose a Matrix."},
    {"double ::genesis::utils::mean (const Histogram & h)", "Compute the bin-weighted arithmetic mean.\n\nThe histogram is regarded as a probability distribution. Negative bin values are ignored for the purposes of this calculation. The accuracy of the result is limited by the bin width."},
    {"MeanStddevPair ::genesis::utils::mean_stddev (ForwardIterator first, ForwardIterator last, double epsilon=-1.0)", "Calculate the mean and standard deviation of a range of double elements.\n\nThe iterators first and last need to point to a range of double. The function then calculates the mean and standard deviation of all elements in the range that are finite. If none are, or if the range is empty, both returned values are 0.0.If the resulting standard deviation is below the given epsilon (e.g, 0.0000001), it is \"corrected\" to be 1.0 instead. This is an inelegant (but usual) way to handle near-zero values, which for some use cases would cause problems like a division by zero later on. By default, epsilon is -1.0, which deactivates this check - a standard deviation can never be below 0.0."},
    {"MeanStddevPair ::genesis::utils::mean_stddev (std::vector< double > const & vec, double epsilon=-1.0)", "Calculate the mean and standard deviation of a vector of double elements.\n\nSee mean_stddev( ForwardIterator first, ForwardIterator last, double epsilon ) for details."},
    {"double ::genesis::utils::median (RandomAccessIterator first, RandomAccessIterator last, size_t l, size_t r)", "Helper function to get the median in between a range. Both l and r are inclusive."},
    {"double ::genesis::utils::median (RandomAccessIterator first, RandomAccessIterator last)", "Calculate the median value of a range of double.\n\nThe range has to be sorted, otherwise an exception is thrown."},
    {"double ::genesis::utils::median (std::vector< double > const & vec)", "Calculate the median value of a vector of double.\n\nThe vector has to be sorted."},
    {"std::vector< MinMaxPair< double > > ::genesis::utils::normalize_cols (Matrix< double > & data)", "Normalize the columns of a Matrix so that all values are in the range [ 0.0, 1.0 ].\n\nThe Matrix is manipulated inline. For each column, the new values of the Matrix are calculated as $ x_{new} = \\frac{ x - x_{min} }{ x_{max} - x_{min} } $.The function returns a vector containing the min and max values of the columns before normalization, see matrix_col_minmax().\n\ndata\n\n\nInput data Matrix; normalization is done inline. \n\n\nVector containing the min and max values for each column before normalization."},
    {"std::vector< MinMaxPair< double > > ::genesis::utils::normalize_rows (Matrix< double > & data)", "Normalize the rows of a Matrix so that all values are in the range [ 0.0, 1.0 ].\n\nThe Matrix is manipulated inline. For each row, the new values of the Matrix are calculated as $ x_{new} = \\frac{ x - x_{min} }{ x_{max} - x_{min} } $.The function returns a vector containing the min and max values of the rows before normalization, see matrix_row_minmax().\n\ndata\n\n\nInput data Matrix; normalization is done inline. \n\n\nVector containing the min and max values for each row before normalization."},
    {"bool ::genesis::utils::operator& (SkipWhitespace lhs, SkipWhitespace rhs)", "And-operator to check whether a SkipWhitespace is set.\n\nTypical usage: SkipWhitespace option;\nif( option & SkipWhitespace::kTrailing ) {\n    // Do stuff...\n}\nSee SkipWhitespace for more information."},
    {"bool ::genesis::utils::operator< (JsonDocument::const_reference lhs, JsonDocument::const_reference rhs)", "Compares whether one JSON value lhs is less than another JSON value rhs according to the following rules:\nIf lhs and rhs have the same type, the values are compared using the default < operator.Integer and floating-point numbers are automatically converted before comparisonIn case lhs and rhs have different types, the values are ignored and the order of the types is considered, see operator<(const JsonDocument::ValueType, const JsonDocument::ValueType). %"},
    {"bool ::genesis::utils::operator< (const JsonDocument::ValueType lhs, const JsonDocument::ValueType rhs)", "Returns an ordering that is similar to Python:\norder: null < boolean < number < object < array < stringfurthermore, each type is not smaller than itself %"},
    {"bool ::genesis::utils::operator== (JsonDocument::const_reference lhs, JsonDocument::const_reference rhs)", "Compares two JSON values for equality according to the following rules:\nTwo JSON values are equal if (1) they are from the same type and (2) their stored values are the same.Integer and floating-point numbers are automatically converted before comparison. Floating-point numbers are compared indirectly: two floating-point numbers f1 and f2 are considered equal if neither f1 > f2 nor f2 > f1 holds.Two JSON null values are equal. %"},
    {"std::istream & ::genesis::utils::operator>> (std::istream & in, Bitvector & bv)", "Extraction operator that inputs a Bitvector from a string of '0's and '1's, and stops at the first char that is not '0' or '1'."},
    {"T ::genesis::utils::parse_float (utils::InputStream & source)", "Read a floating point number from a stream and return it.\n\nThe number is expected to be in the following format: [+-][123][.456][eE[+-]789]\nThe function stops reading at the first non-fitting digit. It throws an std::overflow_error or underflow_error in case that the exponent (the part after the 'E') does not fit into integer value range."},
    {"T ::genesis::utils::parse_integer (utils::InputStream & source)", "Alias for parse_signed_integer()."},
    {"std::string ::genesis::utils::parse_number_string (utils::InputStream & source)", "Read a general number string from an input stream.\n\nThe function reads from the input as long as it is a valid number of the format [+-][123][.456][eE[+-]789]\nand returns this string. This is useful for intermediately parsing a number and then checking whether it is valid. Use parse_float() to turn such a number string into an actual float/double."},
    {"std::string ::genesis::utils::parse_quoted_string (utils::InputStream & source, bool use_escapes=true, bool use_twin_quotes=false, bool include_qmarks=false)", "Read a string in quotation marks from a stream and return it.\n\nThe first char of the stream is considered to be the opening quotation mark. Everything up until the closing quotation mark (the same char again, whatever it is) is then read. The stream is then pointing to the char right after the closing quotation mark.If the string ends prematurely, i.e., without the closing quotation mark, or right after a backslash if use_escapes is used, the function throws an std::runtime_error.\n\nsource\n\n\nStream to read from.\n\n\n\nuse_escapes\n\n\nIf this optional parameter is set to true, chars preceeded by a backslash \\ are considered to be \"escaped\". If the char following the backslash is any of r, n or t, it is turned into its respective white space equivalent, while all other chars are copied verbatim to the return string. Thus, by escaping it, a the string can also include the quotation mark itself. Default of this parameter is true.\n\n\n\nuse_twin_quotes\n\n\nIf this optional parameter is set to true, the quotation mark itself can be escaped using two consecutive quotation marks. This works in addition to escaping it with a backslash (when use_escapes is used).\n\n\n\ninclude_qmarks\n\n\nThe optional parameter include_qmarks demtermines whether the quotation marks are included in the output or not. Default is false."},
    {"T ::genesis::utils::parse_signed_integer (utils::InputStream & source)", "Read a signed integer from a stream and return it.\n\nThe function expects a sequence of digits, possibly with a leading + or -. The first char after that has to be a digit, otherwise the function throws std::runtime_error. It stops reading at the first non-digit. In case the value range is too small, the function throws std::overflow_error, or underflow_error, respectively."},
    {"T ::genesis::utils::parse_unsigned_integer (utils::InputStream & source)", "Read an unsigned integer from a stream and return it.\n\nThe function expects a sequence of digits. The current char in the stream has to be a digit, otherwise the function throws std::runtime_error. It stops reading at the first non-digit. In case the value range is too small, the function throws std::overflow_error."},
    {"bool ::genesis::utils::path_exists (std::string const & path)", "Return whether a path exists, i.e., is a file or directory."},
    {"double ::genesis::utils::pearson_correlation_coefficient (ForwardIteratorA first_a, ForwardIteratorA last_a, ForwardIteratorB first_b, ForwardIteratorB last_b)", "Calculate the Pearson Correlation Coefficient between two ranges of double.\n\nBoth ranges need to have the same length. Then, the function calculates the PCC between the pairs of entries of both ranges. It skipes entries where any of the two values is not finite.If each pair of entries in the ranges contains at leat one non-finite value, that is, if there are no pairs of finite values, a quiet_NaN is returned. Furtheremore, if one of the ranges has a standard deviation of 0.0, e.g., because all its entries are 0.0 themselves, a division by 0 occurs, leading to a NaN as well."},
    {"double ::genesis::utils::pearson_correlation_coefficient (std::vector< double > const & vec_a, std::vector< double > const & vec_b)", "Calculate the Pearson Correlation Coefficient between the entries of two vectors.\n\nBoth ranges need to have the same length. Then, the function calculates the PCC between the pairs of entries of both ranges. It skipes entries where any of the two values is not finite.If each pair of entries in the ranges contains at leat one non-finite value, that is, if there are no pairs of finite values, a quiet_NaN is returned. Furtheremore, if one of the ranges has a standard deviation of 0.0, e.g., because all its entries are 0.0 themselves, a division by 0 occurs, leading to a NaN as well."},
    {"PcaData ::genesis::utils::principal_component_analysis (Matrix< double > const & data, size_t components=0, PcaStandardization standardization)", "Perfom a Principal Component Analysis on a given data Matrix.\n\nPrincipal Components Analysis or the Karhunen-Loeve expansion is a classical method for dimensionality reduction or exploratory data analysis. One reference among many is: F. Murtagh and A. Heck, Multivariate Data Analysis, Kluwer Academic, Dordrecht, 1987.\n\ndata\n\n\nMatrix with the data, samples in rows, features in columns. \n\n\n\ncomponents\n\n\nIntended number of PCA components to calculate. If 0 (default), all PCA components are calculated, i.e., as many components as data has columns. \n\n\n\nstandardization\n\n\nIndicate the standardization algorithm to perfom on the data before calculating the PCA components, see PcaStandardization. \n\n\nA struct that contains the eigenvalues and corresponding eigenvectors (i.e., the PCA components), and a Matrix with the projected data. See PcaData for details."},
    {"void ::genesis::utils::print (std::ostream & out, Matrix< T > const & matrix, size_t rows=10, size_t cols=10)", "Print a Matrix to an out stream. See print( Matrix<T> const&, size_t, size_t ) for details."},
    {"std::string ::genesis::utils::print (Matrix< T > const & matrix, size_t rows=10, size_t cols=10)", "Print a Matrix to a std::string.\n\nIf rows == 0, all rows are printed. Otherwise, only the given number of rows is printed, followed by an ellipsis (...). The same applies to the columns, using cols.See also print( std::ostream&, Matrix<T> const&, size_t, size_t )."},
    {"double ::genesis::utils::quartile_coefficient_of_dispersion (Quartiles const & q)", "Calculate the quartile_coefficient_of_dispersion.\n\nThe quartile coefficient of dispersion is defined as ( Q3 - Q1 ) / ( Q3 + Q1 ). See quartiles() to caculate those values. See https://en.wikipedia.org/wiki/Quartile_coefficient_of_dispersion for details."},
    {"std::vector< double > ::genesis::utils::quartile_coefficient_of_dispersion (std::vector< Quartiles > const & q)", "Calculate the quartile_coefficient_of_dispersion.\n\nThe quartile coefficient of dispersion is defined as ( Q3 - Q1 ) / ( Q3 + Q1 ). See quartiles() to caculate those values. See https://en.wikipedia.org/wiki/Quartile_coefficient_of_dispersion for details."},
    {"Quartiles ::genesis::utils::quartiles (std::vector< double > const & vec)", "Calculate the Quartiles of a vector of double.\n\nThe vector has to be sorted."},
    {"std::vector< size_t > ::genesis::utils::ranking_dense (RandomAccessIterator first, RandomAccessIterator last)", "Return the ranking of the values in the given range, using Dense ranking (\"1223\" ranking).\n\nSee https://en.wikipedia.org/wiki/Ranking for details.ranking_standard(), ranking_modified(), ranking_ordinal(), ranking_fractional() for other ranking methods."},
    {"std::vector< size_t > ::genesis::utils::ranking_dense (std::vector< double > const & vec)", "Return the ranking of the values in the given range, using Dense ranking (\"1223\" ranking).\n\nSee https://en.wikipedia.org/wiki/Ranking for details.ranking_standard(), ranking_modified(), ranking_ordinal(), ranking_fractional() for other ranking methods."},
    {"std::vector< double > ::genesis::utils::ranking_fractional (std::vector< double > const & vec)", "Return the ranking of the values in the given range, using Fractional ranking (\"1 2.5 2.5 4\" ranking).\n\nSee https://en.wikipedia.org/wiki/Ranking for details. This is the only raking method that returns float values instead of integer values.ranking_standard(), ranking_modified(), ranking_dense(), ranking_ordinal() for other ranking methods."},
    {"std::vector< double > ::genesis::utils::ranking_fractional (RandomAccessIterator first, RandomAccessIterator last)", "Return the ranking of the values in the given range, using Fractional ranking (\"1 2.5 2.5 4\" ranking).\n\nSee https://en.wikipedia.org/wiki/Ranking for details. This is the only raking method that returns float values instead of integer values.ranking_standard(), ranking_modified(), ranking_dense(), ranking_ordinal() for other ranking methods."},
    {"std::vector< size_t > ::genesis::utils::ranking_modified (RandomAccessIterator first, RandomAccessIterator last)", "Return the ranking of the values in the given range, using Modified competition ranking (\"1334\" ranking).\n\nSee https://en.wikipedia.org/wiki/Ranking for details.ranking_standard(), ranking_dense(), ranking_ordinal(), ranking_fractional() for other ranking methods."},
    {"std::vector< size_t > ::genesis::utils::ranking_modified (std::vector< double > const & vec)", "Return the ranking of the values in the given range, using Modified competition ranking (\"1334\" ranking).\n\nSee https://en.wikipedia.org/wiki/Ranking for details.ranking_standard(), ranking_dense(), ranking_ordinal(), ranking_fractional() for other ranking methods."},
    {"std::vector< size_t > ::genesis::utils::ranking_ordinal (RandomAccessIterator first, RandomAccessIterator last)", "Return the ranking of the values in the given range, using Ordinal ranking (\"1234\" ranking).\n\nSee https://en.wikipedia.org/wiki/Ranking for details.ranking_standard(), ranking_modified(), ranking_dense(), ranking_fractional() for other ranking methods."},
    {"std::vector< size_t > ::genesis::utils::ranking_ordinal (std::vector< double > const & vec)", "Return the ranking of the values in the given range, using Ordinal ranking (\"1234\" ranking).\n\nSee https://en.wikipedia.org/wiki/Ranking for details.ranking_standard(), ranking_modified(), ranking_dense(), ranking_fractional() for other ranking methods."},
    {"std::vector< size_t > ::genesis::utils::ranking_standard (RandomAccessIterator first, RandomAccessIterator last)", "Return the ranking of the values in the given range, using Standard competition ranking (\"1224\" ranking).\n\nSee https://en.wikipedia.org/wiki/Ranking for details.ranking_modified(), ranking_dense(), ranking_ordinal(), ranking_fractional() for other ranking methods."},
    {"std::vector< size_t > ::genesis::utils::ranking_standard (std::vector< double > const & vec)", "Return the ranking of the values in the given range, using Standard competition ranking (\"1224\" ranking).\n\nSee https://en.wikipedia.org/wiki/Ranking for details.ranking_modified(), ranking_dense(), ranking_ordinal(), ranking_fractional() for other ranking methods."},
    {"char ::genesis::utils::read_char_or_throw (InputStream & source, char criterion, SkipWhitespace skip_ws)", "Lexing function that reads a single char from the stream and checks whether it equals the provided one.\n\nIf not, the function throws std::runtime_error. The stream is advanced by one position and the char is returned. For a similar function that checks the value of the current char but does not advance in the stream, see affirm_char_or_throw().Using the parameter skip_ws, it is possible to skip leading and/or trailing whitespaces before/after treating the criterion char. See SkipWhitespace for more information."},
    {"char ::genesis::utils::read_char_or_throw (InputStream & source, std::function< bool(char)> criterion, SkipWhitespace skip_ws)", "Lexing function that reads a single char from the stream and checks whether it fulfills the provided criterion.\n\nIf not, the function throws std::runtime_error. The stream is advanced by one position and the char is returned. For a similar function that checks the value of the current char but does not advance in the stream, see affirm_char_or_throw().Using the parameter skip_ws, it is possible to skip leading and/or trailing whitespaces before/after treating the criterion char. See SkipWhitespace for more information."},
    {"std::string ::genesis::utils::read_to_end_of_line (InputStream & source)", "Lexing function that reads until the end of the line (i.e., to the new line char), and returns the read chars (excluding the new line char).\n\nThe stream is left at the new line char. If the stream is already at its last line, this function reads to the end of the stream."},
    {"std::string ::genesis::utils::read_until (InputStream & source, char criterion)", "Lexing function that reads from the stream until its current char equals the provided one. The read chars are returned."},
    {"std::string ::genesis::utils::read_until (InputStream & source, std::function< bool(char)> criterion)", "Lexing function that reads from the stream until its current char fulfills the provided criterion. The read chars are returned."},
    {"std::string ::genesis::utils::read_while (InputStream & source, char criterion)", "Lexing function that reads from the stream while its current char equals the provided one. The read chars are returned."},
    {"std::string ::genesis::utils::read_while (InputStream & source, std::function< bool(char)> criterion)", "Lexing function that reads from the stream while its current char fulfills the provided criterion. The read chars are returned."},
    {"TridiagonalDecompositionData ::genesis::utils::reduce_to_tridiagonal_matrix (Matrix< double > & data)", "Triangular decomposition of a symmetric matrix.\n\nThis function performs an intermediate step that is usually followed by an execution of the tridiagonal_ql_algorithm().It uses the Householder reduction of matrix a to tridiagonal form, according to Martin et al., Num. Math. 11, 181-195, 1968.\nRef: Smith et al., Matrix Eigensystem Routines -- EISPACK Guide\nSpringer-Verlag, 1976, pp. 489-494.\nW H Press et al., Numerical Recipes in C, Cambridge U P, 1988, pp. 373-374.\nThere, the function is called tred2().The implementation of this function is largely borrowed from http://www.classification-society.org/csna/mda-sw/pca.c published as Public Domain by Fionn Murtagh.\n\ndata\n\n\nInput data matrix. Operations are performed inline, that is, the matrix is changed during execution of the function."},
    {"std::string ::genesis::utils::repeat (std::string const & word, size_t times)", "Take a string and repeat it a given number of times."},
    {"std::string ::genesis::utils::replace_all (std::string const & text, std::string const & search, std::string const & replace)", "Return a copy of a string, where all occurrences of a search string are replaced by a replace string."},
    {"std::string ::genesis::utils::replace_all_chars (std::string const & text, std::string const & search_chars, char replace)", "Replace all occurrences of the search_chars in text by the replace char."},
    {"Color ::genesis::utils::resolve_color_string (std::string const & color_str)", "Resolve a string representing a color.\n\nThe string can either be a hex color as accepted by color_to_hex(), e.g., \"#003366[ff]\", or one of the named colors, see is_color_name() and color_from_name()."},
    {"double ::genesis::utils::round_to (double x, size_t accuracy_order)", "Retun the value of x, rounded to the decimal digit given by accuracy_order."},
    {"std::string ::genesis::utils::sanitize_filname (std::string const & filename)", "Remove or replace all invalid parts of a filename.\n\nSimilar to is_valid_filname(), this function is not meant to be an ultimate solution to valid filenames. See there for details.The function is meant to be called on the file name itself, without the directory path leading to it. File extensions are allowed. Thus, you might need to call file_basename() before in order to get the file name without the path.This function does the following:\nAll non-printable characters are removed.Spaces at the beginning and end are removed.All invalid chars are replaced by an underscore. See is_valid_filname() for a list of those chars.\nIf after this procedure the filename is empty, an exception is thrown. This is meant to save the user from checking this, or from running into trouble when trying to write to this \"file\" - because an empty filename will point to a directory name."},
    {"std::string ::genesis::utils::sanitize_geo_coordinate (std::string const & coordinate, bool two_components=true)", "Replace non-ascii symbols used in geographic coordinates by their ascii equivalents.\n\nThe function replaces symbols such as degrees, primes, double primes by simple letters ('dms') that serve the same function.Furthermore, if two_components is true (default), the function assumes that the given coordinate contains two components (North/South and East/West). In that case, if there is exaclty one comma in the input, it is replaced by a slash. This is meant to avoid ambiguity in parsing of a coordinate that uses commas as decimal separator. Hence, when sanitizing a coordinate with only one component, two_components needs to be set to false in order to avoid replacing a single decimal separator comma by a slash."},
    {"std::vector< size_t > ::genesis::utils::select_without_replacement (size_t k, size_t n)", "Select k many unique numbers out of the range [ 0, n ).\n\nIn other words, select k numbers out of the sequence of n numbers, without replacement.The implementation is based on Algorithm 3.4.2S of Knuth's book Seminumeric Algorithms.\n\nk\n\n\nDesired sample size. \n\n\n\nn\n\n\nTotal population size. \n\n\nList of k unique numbers out of the range [ 0, n )."},
    {"double ::genesis::utils::sigma (const Histogram & h)", "Compute the bin-weighted standard deviation.\n\nThe histogram is regarded as a probability distribution. Negative bin values are ignored for the purposes of this calculation. The accuracy of the result is limited by the bin width."},
    {"constexpr int ::genesis::utils::signum (T x, std::false_type )", "Implementation of signum(T x) for unsigned types. See there for details."},
    {"constexpr int ::genesis::utils::signum (T x, std::true_type )", "Implementation of signum(T x) for signed types. See there for details."},
    {"constexpr int ::genesis::utils::signum (T x)", "Get the sign of a value, which is either -1, 0, or 1.\n\nWorks for all numerical types. We use two tagged implementations for signed and unsigned types in order to avoid compiler warnings. See http://stackoverflow.com/questions/1903954/is-there-a-standard-sign-function-signum-sgn-in-c-c for details."},
    {"void ::genesis::utils::skip_to_end_of_line (InputStream & source)", "Lexing function that advances the stream to the end of the line, i.e., to the new line char.\n\nIf the stream is already at its last line, this function moves to the end of the stream."},
    {"void ::genesis::utils::skip_until (InputStream & source, char criterion)", "Lexing function that advances the stream until its current char equals the provided one."},
    {"void ::genesis::utils::skip_until (InputStream & source, std::function< bool(char)> criterion)", "Lexing function that advances the stream until its current char fulfills the provided criterion."},
    {"void ::genesis::utils::skip_while (InputStream & source, char criterion)", "Lexing function that advances the stream while its current char equals the provided one."},
    {"void ::genesis::utils::skip_while (InputStream & source, std::function< bool(char)> criterion)", "Lexing function that advances the stream while its current char fulfills the provided criterion."},
    {"std::vector< size_t > ::genesis::utils::sort_indices (RandomAccessIterator first, RandomAccessIterator last, Comparator comparator)", "Get the indices to the sorted order of the given range.\n\nThis function returns a list of indices into the given range, so that their order gives the sorted content of the elements in [ first, last ), using std::less for comparisons.For example, for( auto i: sort_indices(v) ) {\n    cout << *( first + i ) << endl;\n}\noutputs the elements in the range in sorted order, without actually moving any elements in the range. This is useful if the same sorting order needs to be applied to some other container.There is also an overload of this function that takes an additional parameter comparator. It can be used to specify the function for comparing two values of the range.Furthermore, there are variants that use std::stable_sort instead, see stable_sort_indices()."},
    {"constexpr T ::genesis::utils::abs_diff (T const & lhs, T const & rhs)", "Calculate the absolute differenence between two values.\n\nThis function is particularly useful for unsigned types, as subtracting them and then using std::abs() does not work for them."},
    {"void ::genesis::utils::affirm_char_or_throw (InputStream & source, char criterion, SkipWhitespace skip_ws)", "Lexing function that checks whether the current char from the stream equals the provided one.\n\nIf not, the function throws std::runtime_error. The stream is not advanced (i.e., it stays at its current position). For a similar function that reads (i.e., also advances) the current char from the stream, see read_char_or_throw().Using the parameter skip_ws, it is possible to skip leading and/or trailing whitespaces before/after treating the criterion char. See SkipWhitespace for more information."},
    {"void ::genesis::utils::affirm_char_or_throw (InputStream & source, std::function< bool(char)> criterion, SkipWhitespace skip_ws)", "Lexing function that checks whether the current char from the stream fulfills the provided criterion.\n\nIf not, the function throws std::runtime_error. The stream is not advanced (i.e., it stays at its current position). For a similar function that reads (i.e., also advances) the current char from the stream, see read_char_or_throw().Using the parameter skip_ws, it is possible to skip leading and/or trailing whitespaces before/after treating the criterion char. See SkipWhitespace for more information."},
    {"bool ::genesis::utils::almost_equal_relative (double lhs, double rhs, double max_rel_diff=std::numeric_limits< double >::epsilon())", "Check whether two doubles are almost equal, using a relative epsilon to compare them."},
    {"std::string ::genesis::utils::bitstring (TwobitVector const & vec)", "Return a string with a bit-representation of a TwobitVector.\n\nIt returns the words of the vector with bits in the order of the underlying integer type. This is mainly useful for debugging and testing."},
    {"std::string ::genesis::utils::bitstring (TwobitVector::WordType const & vec)", "Return a string with a bit-representation of a TwobitVector::WordType.\n\nIt returns the word with bits in the order of the underlying integer type. This is mainly useful for debugging and testing."},
    {"Bitvector ::genesis::utils::bitwise_and (Bitvector const & lhs, Bitvector const & rhs)", "Take the bitwise and of two Bitvectors of potentially different size.\n\nThe function is the same as normal and, but operates only on the number of bits of the shorter Bitvector, that is, it operates on bits [ 0 , m ) with m = min( lhs.size(), rhs.size() )."},
    {"Bitvector ::genesis::utils::bitwise_or (Bitvector const & lhs, Bitvector const & rhs)", "Take the bitwise or of two Bitvectors of potentially different size.\n\nThe function is the same as normal or, but operates only on the number of bits of the shorter Bitvector, that is, it operates on bits [ 0 , m ) with m = min( lhs.size(), rhs.size() )."},
    {"Bitvector ::genesis::utils::bitwise_xor (Bitvector const & lhs, Bitvector const & rhs)", "Take the bitwise xor of two Bitvectors of potentially different size.\n\nThe function is the same as normal xor, but operates only on the number of bits of the shorter Bitvector, that is, it operates on bits [ 0 , m ) with m = min( lhs.size(), rhs.size() )."},
    {"bool ::genesis::utils::char_is_digit (const char c)", "Return whether a char is a digit (0-9)."},
    {"bool ::genesis::utils::char_is_number_part (char const c)", "Return whether a char is valid in a number, i.e., a digit, a dot, plus, minus, or 'e'/'E'."},
    {"bool ::genesis::utils::char_is_sign (const char c)", "Return whether a char is a sign (+-)."},
    {"bool ::genesis::utils::char_match_ci (const char c1, const char c2)", "Return whether two chars are the same, case insensitive."},
    {"std::string ::genesis::utils::char_to_hex (char c, bool full=false)", "Return the hex representation of a char.\n\nBy default, just the two-byte hex presentation is returned (e.g., 4e for N). If full is true, a text-representation is returned instead, using the form 'N' (0x4e)\ninstead."},
    {"double ::genesis::utils::coefficient_of_variation (MeanStddevPair const & ms)", "Calculate the index of dispersion.\n\nThe coefficient of variation (CV), also known as the relative standard deviation (RSD), is defined as the ratio of the standard deviation to the mean. See mean_stddev() to calcualte those values. See https://en.wikipedia.org/wiki/Coefficient_of_variation for details."},
    {"std::vector< double > ::genesis::utils::coefficient_of_variation (std::vector< MeanStddevPair > const & ms)", "Calculate the index of dispersion.\n\nThe coefficient of variation (CV), also known as the relative standard deviation (RSD), is defined as the ratio of the standard deviation to the mean. See mean_stddev() to calcualte those values. See https://en.wikipedia.org/wiki/Coefficient_of_variation for details."},
    {"Color ::genesis::utils::color_from_bytes (unsigned char r, unsigned char g, unsigned char b, unsigned char a)", "Create a Color given three or four values in the range [ 0, 255 ] for each of the components red, green and blue, and optionally alpha."},
    {"Color ::genesis::utils::color_from_hex (std::string const & hex_color, std::string const & prefix=\"#\")", "Create a Color given a hex color string in the format \"#003366[ff]\".\n\nThe hash sign in the beginning can be replaced by any given prefix. If the string is not correctly formatted, an std::invalid_argument exception is thrown. If the string contains only RGB, alpha is set to 1.0."},
    {"Color ::genesis::utils::color_from_name (std::string const & name)", "Return the color represented by the given name, which is (currently) a shortcut for color_from_name_web() and color_from_name_xkcd()."},
    {"Color ::genesis::utils::color_from_name_web (std::string const & name)", "Retrieve a named web color by name.\n\nNames are filtered so that spaces, underscores and the letter case are ignored. If the color name does not exist, an std::invalid_argument exception is thrown."},
    {"Color ::genesis::utils::color_from_name_xkcd (std::string const & name)", "Retrieve a named xkcd color by name.\n\nNames are filtered so that spaces, underscores and the letter case are ignored. If the color name does not exist, an std::invalid_argument exception is thrown.The colors are taken from an [https://xkcd.com/](xkcd) color survey. They were published under Public Domain, http://creativecommons.org/publicdomain/zero/1.0/. See https://xkcd.com/color/rgb/ and https://blog.xkcd.com/2010/05/03/color-survey-results/ for details. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_accent ()", "Color palette accent.\n\nProvides a color palette with 8 colors, 4 pale and 4 saturated, for use with qualitative/categorical data.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_blues ()", "Color palette blues.\n\nProvides a sequential blue color palette of increasing saturation.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_brbg ()", "Color palette brbg.\n\nProvides a diverging color palette with brown low, white middle, and blue-green high.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_bugn ()", "Color palette bugn.\n\nProvides a sequential blue-green color palette of increasing saturation.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_bupu ()", "Color palette bupu.\n\nProvides a sequential blue-purple color palette of increasing saturation.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_bupubk ()", "Color Palette bupubk.\n\nProvides a sequential blue color palette of light blue, purple and black. Particularly useful for visualizing trees, as the light blue is still visible when used to color branches."},
    {"std::vector< Color > const & ::genesis::utils::color_list_dark2 ()", "Color palette dark2.\n\nProvides a color palette with 8 dark colors based on color_list_set2() for use with qualitative/categorical data.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_gnbu ()", "Color palette gnbu.\n\nProvides a sequential green-blue color palette of increasing saturation.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_greens ()", "Color palette greens.\n\nProvides a sequential green color palette of increasing saturation.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_greys ()", "Color palette greys.\n\nProvides a sequential grey color palette of increasing saturation.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_inferno ()", "Color palette inferno.\n\nThis Matplotlib color palette is adapted from https://github.com/BIDS/colormap. New matplotlib colormaps by Nathaniel J. Smith, Stefan van der Walt, and Eric Firing. The colormaps are released under the CC0 license / public domain dedication. See https://creativecommons.org/publicdomain/zero/1.0/ for the license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_magma ()", "Color palette magma.\n\nThis Matplotlib color palette is adapted from https://github.com/BIDS/colormap. New matplotlib colormaps by Nathaniel J. Smith, Stefan van der Walt, and Eric Firing. The colormaps are released under the CC0 license / public domain dedication. See https://creativecommons.org/publicdomain/zero/1.0/ for the license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_oranges ()", "Color palette oranges.\n\nProvides a sequential orange color palette of increasing saturation.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_orrd ()", "Color palette orrd.\n\nProvides a sequential orange-red color palette of increasing saturation.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_paired ()", "Color palette paired.\n\nProvides a color palette with 12 colors in 6 pairs for use with qualitative/categorical data.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_pastel1 ()", "Color palette pastel1.\n\nProvides a color palette with 9 colors based on color_list_set1() for use with qualitative/categorical data.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_pastel2 ()", "Color palette pastel2.\n\nProvides a color palette with 9 colors based on color_list_set2() for use with qualitative/categorical data.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_piyg ()", "Color palette piyg.\n\nProvides a diverging color palette with pink low, white middle, and yellow-green high.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_plasma ()", "Color palette plasma.\n\nThis Matplotlib color palette is adapted from https://github.com/BIDS/colormap. New matplotlib colormaps by Nathaniel J. Smith, Stefan van der Walt, and Eric Firing. The colormaps are released under the CC0 license / public domain dedication. See https://creativecommons.org/publicdomain/zero/1.0/ for the license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_prgn ()", "Color palette prgn.\n\nProvides a diverging color palette with purple low, white middle, and green high.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_pubu ()", "Color palette pubu.\n\nProvides a sequential purple-blue color palette of increasing saturation.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_pubugn ()", "Color palette pubugn.\n\nProvides a sequential purple-blue-green color palette of increasing saturation.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_puor ()", "Color palette puor.\n\nProvides a diverging color palette with orange low, white middle, and purple high.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_purd ()", "Color palette purd.\n\nProvides a sequential purple-red color palette of increasing saturation.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_purples ()", "Color palette purples.\n\nProvides a sequential purple color palette of increasing saturation.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_rdbu ()", "Color palette rdbu.\n\nProvides a diverging color palette with red low, white middle, and blue high.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_rdgy ()", "Color palette rdgy.\n\nProvides a diverging color palette with red low, white middle, and grey high.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_rdpu ()", "Color palette rdpu.\n\nProvides a sequential red-purple color palette of increasing saturation.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_rdylbu ()", "Color palette rdylbu.\n\nProvides a diverging color palette with red low, pale yellow middle, and blue high.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_rdylgn ()", "Color palette rdylgn.\n\nProvides a diverging color palette with red low, pale yellow middle, and green high.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_reds ()", "Color palette reds.\n\nProvides a sequential red color palette of increasing saturation.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_set1 ()", "Color palette set1.\n\nProvides a color palette with 9 easy-to-name colors for use with qualitative/categorical data.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_set2 ()", "Color palette set2.\n\nProvides a color palette with 8 hard-to-name colors for use with qualitative/categorical data.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_set3 ()", "Color palette set3.\n\nProvides a color palette with 12 colors for use with qualitative/categorical data. The colors are more saturated than the Pastels but less so than set2().Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_spectral ()", "Color palette spectral.\n\nProvides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_viridis ()", "Color palette viridis.\n\nThis Matplotlib color palette is adapted from https://github.com/BIDS/colormap. New matplotlib colormaps by Nathaniel J. Smith, Stefan van der Walt, and Eric Firing. The colormaps are released under the CC0 license / public domain dedication. See https://creativecommons.org/publicdomain/zero/1.0/ for the license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_ylgn ()", "Color palette ylgn.\n\nProvides a sequential yellow-green color palette of increasing saturation.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_ylgnbu ()", "Color palette ylgnbu.\n\nProvides a sequential yellow-green-blue color palette of increasing saturation.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_ylorbr ()", "Color palette ylorbr.\n\nProvides a sequential yellow-orange-brown color palette of increasing saturation.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::vector< Color > const & ::genesis::utils::color_list_ylorrd ()", "Color palette ylorrd.\n\nProvides a sequential yellow-orange-red color palette of increasing saturation.Provides a diverging rainbow color palette with red low, pale yellow middle, and blue high.This ColorBrewer color palette is adapted from https://github.com/axismaps/colorbrewer and https://github.com/Gnuplotting/gnuplot-palettes by converting the colors to RGB double values. The original ColorBrewer color specifications and designs were developed by Cynthia Brewer (http://colorbrewer.org/), while their gnuplot equivalets are authored by Anna Schneider, and published under the Apache-2.0 license. See also our Acknowledgements."},
    {"std::string ::genesis::utils::color_to_hex (Color const & c, std::string const & prefix=\"#\", bool uppercase=false, bool with_alpha=false)", "Return a hex string representation of a Color in the format \"#003366[ff]\".\n\nThe hash sign in the beginning can be replaced by any given prefix. If uppercase is set to true, any outputted alphabetical chars (that is, A to F for hex strings) are uppercase. if with_alpha is set to true, two additional hex digits are printed for the alpha channel."},
    {"bool ::genesis::utils::contains (const C & v, const T & x)", "Returns whether a container object has a certain element.\n\nThe usage of std::find just to check for presence of a certain item is a bit cumbersome. This template simply takes any container and a value and returns true iff the value is present in the container."},
    {"bool ::genesis::utils::contains_ci (std::vector< std::string > const & haystack, std::string const & needle)", "Return whether a vector of strings contains a given string, case insensitive."},
    {"GeoCoordinate ::genesis::utils::convert_geo_coordinate (std::string const & latitude, std::string const & longitude)", "Parse strings of geographic coordinates.\n\nThis is the same as convert_geo_coordinate( std::string const& ), with the only different being that the two components (NW and EW) are given separately. See there for details."},
    {"GeoCoordinate ::genesis::utils::convert_geo_coordinate (std::string const & coordinate)", "Parse a string of geographic coordinates.\n\nThe function accepts many different formats for geographical coordinates. Some exemplary valid cases:\n50d4m17.698N 14d24m2.826E40:26:46N,79:56:55W40:26:46.302N 179:56:55.903W4959'56.948\"N, 1548'22.989\"E50d4m17.698N 14d24m2.826E49.9991522N, 150.8063858E402647N 795836W40d 26 47 N 79d 58 36 W40.446195N 79.948862W40,446195 79,94886240 26.7717 / -79 56.9317240.446195, -79.948862N 49 59.94913', E 15 48.38315'\nThe hemispheres can be given as [NS] for the first component and [EW] for the second, and can either preceed or follow the numeric values. Degrees, Minutes and Seconds can be separated by the letters [dms], by degree (), prime (), single quotation mark ('), double prime (), double quoation mark (\"), or by colons (:), respectively. The two components (NS and EW) can be separated by comma (,) or slash (/).There are some caveats: The hemisphere strings (NESW) have to be in capitial letters, while the letters used for degrees, minute and seconds (dms) have to be lower case. This constraint avoids ambiguity between seconds (s) and south (S). Also, either the decimal separator can be a comma, or the separator between components, but not both. This again avoids ambiguity while parsing."},
    {"double ::genesis::utils::convert_single_geo_coordinate (std::string const & h1, std::string const & d, std::string const & m, std::string const & s, std::string const & h2, GeoCoordinateComponent component)", "Local helper function that takes parts of the regex matches and converts them to double.\n\nThe strings h1, d, m, s and h2 are the matches of the regex. The parameter component is the hemisphere of this coordinate component, NS or EW, which is determined by whether the matches are the first or the second component of the coordinate."},
    {"std::vector< Color > ::genesis::utils::convert_to_palette_ (NamedColorList const & list)", "Local helper function to convert a list of byte colors into a proper Color vector."},
    {"Matrix< double > ::genesis::utils::correlation_matrix (Matrix< double > const & data)", "Calculate the correlation Matrix of a given data Matrix.\n\nThis is done by standardizing the mean and variance of the given data and then calculating the sums_of_squares_and_cross_products_matrix()."},
    {"size_t ::genesis::utils::count_substring_occurrences (std::string const & str, std::string const & sub)", "Return the number of (possibly overlapping) occurrences of a substring in a string."},
    {"Matrix< double > ::genesis::utils::covariance_matrix (Matrix< double > const & data)", "Calculate the covariance Matrix of a given data Matrix.\n\nThis is done by standardizing the mean of the given data and then calculating the sums_of_squares_and_cross_products_matrix()."},
    {"std::string ::genesis::utils::current_date ()", "Returns the current date as a string in the format \"2014-12-31\"."},
    {"std::string ::genesis::utils::deescape (std::string const & text)", "Return a string where backslash-escaped characters are transformed into their respective string form.\n\nAll occurrences of backslash + char in the string are de-escaped. That is, all \\n, \\t and \\r are turned into their respective control sequences, while all other chars folloing a backslash are translated into the char itself (so that e.g., quotation marks or backslashes themself can be escaped).Also see deescape( char c )."},
    {"std::string ::genesis::utils::current_time ()", "Returns the current time as a string in the format \"13:37:42\"."},
    {"char ::genesis::utils::deescape (char c)", "Return the de-escaped char for a backslash-escaped char.\n\nThe function takes the char that follows a backslash in an escaped string and returns its de-escaped char. That is, n is turned into a new line (\\n), t is turned into a tab (\\t) and r is turned into a carrier return (\\r). All other chars (e.g., quotation marks or the backslash itself) are simply returned as-is."},
    {"void ::genesis::utils::dir_create (std::string const & path, bool with_parents=true)", "Create a directory.\n\nIf the directory already exists, nothing happens. If the path exists, but is not a directory, a std::runtime_error is thrown. If the creation fails for some other reason, also a std::runtime_error is thrown."},
    {"bool ::genesis::utils::dir_exists (std::string const & dir)", "Return true iff the directory exists."},
    {"std::vector< std::string > ::genesis::utils::dir_list_contents (std::string const & dir, bool full_path=false, std::string const & regex=\"\")", "Get a list of files and directories in a directory.\n\nIf full_path is set to true, the path of the provided dir is prepended to the resulting list. If a non-empy regex is provided, file names are filtered by this regular expression.If the directory is not readable, the function throws std::runtime_error."},
    {"std::vector< std::string > ::genesis::utils::dir_list_directories (std::string const & dir, bool full_path=false, std::string const & regex=\"\")", "Get a list of directories in a directory.\n\nBehaves the same as dir_list_contents(), except tat only directories are listed (i.e., no files). See there for an explanation of the arguments."},
    {"std::vector< std::string > ::genesis::utils::dir_list_files (std::string const & dir, bool full_path=false, std::string const & regex=\"\")", "Get a list of files in a directory.\n\nBehaves the same as dir_list_contents(), except tat only files are listed (i.e., no directories). See there for an explanation of the arguments."},
    {"std::string ::genesis::utils::dir_normalize_path (std::string const & path)", "Normalize a dir name, i.e., make sure that the given path ends with exaclty one slash."},
    {"bool ::genesis::utils::ends_with (std::string const & text, std::string const & ending)", "Return whether a string ends with another string."},
    {"bool ::genesis::utils::equals_ci (std::string const & lhs, std::string const & rhs)", "Compare two strings case insensitive."},
    {"void ::genesis::utils::erase_if (Container & c, UnaryPredicate p)", "Erases all elements from the container that satisfy a given predicate. An element is erased, if the predicate evaluates to true for it. The predicate needs to have a signature similar to (T const&)->bool.\n\nc\n\n\nThe container to modify. \n\n\n\np\n\n\nThe predicate to satisfy."},
    {"std::string ::genesis::utils::escape (std::string const & text)", "Return a string where special chars are replaces by their escape sequence.\n\nAll new lines are transformed into either \\r or \\n, tabs into \\t. Double quotation marks are preceeded by a backslash, also the backslash itself will be escaped, so that \"</tt> becomes <tt>\\\\\" and \\ becomes \\\\."},
    {"void ::genesis::utils::file_append (std::string const & content, std::string const & filename)", "Append the content of a string to a file.\n\nIf the file is not writable, the function throws std::runtime_error."},
    {"std::string ::genesis::utils::file_basename (std::string const & filename)", "Remove directory name from file name if present."},
    {"bool ::genesis::utils::file_exists (std::string const & filename)", "Return true iff the file exists."},
    {"std::string ::genesis::utils::file_extension (std::string const & filename)", "Return the extension name of a file.\n\nAlso see file_filename()."},
    {"std::string ::genesis::utils::file_filename (std::string const & filename)", "Remove extension if present.\n\nCaveat: Does not remove the path. So, if the filename itself does not contain an extension separator \".\", but the path does, this will yield an unwanted result. Call file_basename() first."},
    {"std::unordered_map< std::string, std::string > ::genesis::utils::file_info (std::string const & filename)", "Return information about a file."},
    {"void ::genesis::utils::file_output_stream (std::string const & filename, std::ofstream & out_stream, std::ios_base::openmode mode=std::ios_base::out)", "Helper function to obtain an output stream to a file.\n\nThis function is used internally by all file writers. It makes sure that the file is writable, and throws an exception otherwise.Furthermore, the function checks whether the file already exists. If it exists and Options::allow_file_overwriting() is not explicitly activated, the function throws, too. This is a safty measure to ensure that users cannot accidentally overwrite their files.\n\nfilename\n\n\nPath to the file to write to. \n\n\n\nout_stream\n\n\nReference to the target output stream. Unfortunately, we cannot return streams, as they do not offer copy or move, so we have to do it this way. \n\n\n\nmode\n\n\nMode flag as used by std::ostream.\n\n\nOptions::allow_file_overwriting( bool )"},
    {"void ::genesis::tree::mass_tree_clear_masses (MassTree & tree)", "Clear all masses of a MassTree, while keeping its topology."},
    {"std::vector< double > ::genesis::tree::mass_tree_mass_per_edge (MassTree const & tree)", "Return a std::vector that contains the total Mass for each edge of the given MassTree.\n\nThe vector is indexed using the index of the edges."},
    {"MassTree ::genesis::tree::mass_tree_merge_trees (MassTree const & lhs, MassTree const & rhs, double const scaler_lhs=1.0, double const scaler_rhs=1.0)", "Merge all masses of two MassTrees into one and return it.\n\nThe two scalers can be used to weight the masses differently, if needed.The resulting tree will have a mass of scaler_lhs * mass(lhs) + scaler_rhs * mass(rhs), which usually is not unit mass any more. Thus, if needed, call mass_tree_normalize_masses() to rescale the masses back to unit mass."},
    {"void ::genesis::tree::mass_tree_merge_trees_inplace (MassTree & lhs, MassTree const & rhs, double const scaler_lhs=1.0, double const scaler_rhs=1.0)", "Merge all masses of two MassTrees by adding them to the first MassTree.\n\nThe two scalers can be used to weight the masses differently, if needed.The resulting tree will have a mass of scaler_lhs * mass(lhs) + scaler_rhs * mass(rhs), which usually is not unit mass any more. Thus, if needed, call mass_tree_normalize_masses() to rescale the masses back to unit mass."},
    {"void ::genesis::tree::mass_tree_normalize_masses (MassTree & tree)", "Scale all masses of a MassTree so that they sum up to 1.0."},
    {"void ::genesis::tree::mass_tree_reverse_signs (MassTree & tree)", "Reverse the sign of each mass point on a MassTree."},
    {"void ::genesis::tree::mass_tree_scale_masses (MassTree & tree, double factor)", "Scale all masses of a MassTree with the multiplicative factor factor."},
    {"double ::genesis::tree::mass_tree_sum_of_masses (MassTree const & tree)", "Return the total sum of all masses on the MassTree.\n\nIn order for the earth_movers_distance() algorithm to work properly (and give meaningful results), the total mass on the MassTrees should ideally be the same. This function can be used to check this.Because of numerical issues however, be aware that the result might be slighly off. This is okay, as it usually is in the last digits of the double."},
    {"void ::genesis::tree::mass_tree_transform_to_unit_branch_lengths (MassTree & tree)", "Set all branch lengths of a MassTree to 1.0, while keeping the relative position of all masses on the branches."},
    {"bool ::genesis::tree::mass_tree_validate (MassTree const & tree, double valid_total_mass_difference=-1.0)", "Validate the data on a MassTree.\n\nThis function returns true iff the data on the Tree is valid:\nThe node and edge data types have to be MassTreeNodeData and MassTreeEdgeData, respectively.The positions of the masses are in [ 0.0, branch_length ] on their respective branches.If the optional arugment valid_total_mass_difference is not negative, the sum of all masses is also checked. It has to be close to 0.0, using the argument as the absolute allowed difference. This is useful to check whether the masses for calculating the one-argument version of the earth_movers_distance( MassTree const& ) are correct.\nThe function stops at the first encountered invalid condition and outputs a description message of the invalid value to LOG_INFO.\n\ntree\n\n\nMassTree to be validated. \n\n\n\nvalid_total_mass_difference\n\n\nIf set to a non-negative value, it is used as the absolute allowed difference from zero for the total sum of all masses on the tree."},
    {"void ::genesis::tree::mass_trees_make_average_branch_lengths (std::vector< MassTree > & mass_trees)", "Change the branch lengths of all trees to their average, and move the masses accordingly in a proportional way.\n\nThe function only is reasonable to run if all trees have identical topology, which is however not checked explicitly. Use mass_tree_all_identical_topology() for this."},
    {"size_t ::genesis::tree::max_degree (Tree const & tree)", "Return the highest degree of the Nodes of a Tree.\n\nIf the Tree is empty, 0 is returned."},
    {"utils::Matrix< double > ::genesis::tree::node_branch_length_distance_matrix (Tree const & tree)", "Return a distance matrix containing pairwise distances between all Nodes, using the branch_length of the Edges as distance measurement.\n\nThe elements of the matrix are indexed using node().index()."},
    {"std::vector< double > ::genesis::tree::node_branch_length_distance_vector (Tree const & tree, TreeNode const * node=nullptr)", "Return a vector containing the distance of all nodes with respect to the given start node, where distance is measured in the sum of branch lengths between the nodes.\n\nThe vector is indexed using the node().index() for every node. Its elements give the distance of each node with respect to the given start node. The distance is the sum of branch lengths of the edges visited on the path between the two nodes.If no Node pointer is provided, the root is taken as node."},
    {"size_t ::genesis::tree::node_count (Tree const & tree)", "Return the number of Nodes of a Tree. Same as Tree::node_count()."},
    {"std::unordered_set< std::string > ::genesis::tree::node_names (Tree const & tree, bool leaves_only=false)", "Returns an unordered set of all TreeNode names of a Tree.\n\nIf leaves_only is set to true, nodes names of inner nodes are not included. Unnamed nodes (node.data.name == \"\") are always excluded. The only difference to node_names_sorted() is the type of container used for storing the result.The provided Tree needs to have TreeNodes with data types deriveed from CommonNodeData."},
    {"std::unordered_set< std::string > ::genesis::tree::node_names (TreeSet const & tree_set, bool leaves_only=false)", "Returns a set of all TreeNode names of a TreeSet.\n\nThe function returns the set of all names of all Trees in the set. See node_names(...) this version of the function for details."},
    {"utils::SortedVector< std::string > ::genesis::tree::node_names_sorted (Tree const & tree, bool leaves_only=false)", "Returns a set of all TreeNode names of a Tree.\n\nIf leaves_only is set to true, nodes names of inner nodes are not included. Unnamed nodes (node.data.name == \"\") are always excluded. The only difference to node_names() is the type of container used for storing the result.The provided Tree needs to have TreeNodes with data types deriveed from CommonNodeData."},
    {"utils::SortedVector< std::string > ::genesis::tree::node_names_sorted (TreeSet const & tree_set, bool leaves_only=false)", "Returns a set of all TreeNode names of a TreeSet.\n\nThe function returns the set of all names of all Trees in the set. See node_names_sorted(...) this version of the function for details."},
    {"utils::Matrix< size_t > ::genesis::tree::node_path_length_matrix (Tree const & tree)", "Return a matrix containing the pairwise depth of all nodes of the tree.\n\nSee node_path_length_vector(...) for more information.The vector is indexed using the node().index() for every node."},
    {"std::vector< size_t > ::genesis::tree::node_path_length_vector (Tree const & tree, TreeNode const & node)", "Return a vector containing the depth of all nodes with respect to the given start node.\n\nThe vector is indexed using the node().index() for every node. Its elements give the depth of each node with respect to the given start node. The depth is the number of edges visited on the path between two nodes (0 for itself, 1 for immediate neighbours, etc)."},
    {"std::vector< size_t > ::genesis::tree::node_path_length_vector (Tree const & tree)", "Return a vector containing the depth of all nodes with respect to the root node.\n\nThis function calls and returns the value of node_path_length_vector(...) using the root node of the tree."},
    {"utils::Matrix< signed char > ::genesis::tree::node_root_direction_matrix (Tree const & tree)", "Calculate a Matrix that indicates the nodes on the root side of a given node.\n\nThe row and column indices of the Matrix represent TreeNode indices. Each element of the Matrix indicates whether the column node is in the subtree of the row node that contains the root (value 1), or in a subtree that does not contain the root (value -1), while the diagonale contains 0."},
    {"std::vector< TreeLink const * > ::genesis::tree::path_to_root (TreeNode const & node)", "Helper function that finds all TreeLinks between a given TreeNode and the root of the Tree.\n\nBoth the primary_link() of the Node and the root_link() of the Tree are included in the list. The order of the list starts at the provided node and ends at the root."},
    {"void ::genesis::tree::reroot (Tree & tree, TreeLink & at_link)", "Reroot the Tree at the given TreeLink.\n\nThe function sets the root of the tree to the node of the given link. This operation does not change the topology of the tree, but merely adjusts some internal properties. The main changes are that Tree::root_node() and Tree::root_link() will return the new root after calling this function, and that tree iterators will start traversing the tree from this new root by default.There are three internal changes made to the tree data structure:\nAll primary and secondary ends of the edges on the path between the new root and the old root are swapped. This is because the edges now need to point towards the new root.Similarly, all (primary) links of the nodes on that path are changed so that they point towards the new root.Also, the (internal) root_link_index is changed to the new root link. This is used for the functions Tree::root_node() and Tree::root_link().\nThe difference between this function and reroot( Tree& tree, TreeNode const& ) is that when specifying a specific link, this link is used as the (primary) link of the new root node. This way, algorithms and iterators (e.g., IteratorLevelorder) will start traversing the tree in the direction of this link by default. When specifying a node for rerooting instead, the primary link of that node is used, so that iterators start traversing the tree in the direction of the old root instead. For most applications, this does not make a difference. However, there might be cases where the start directing makes a difference. Thus, we offer both versions of this function.The link needs to be part of the tree, otherwise an exception is thrown."},
    {"void ::genesis::tree::reroot (Tree & tree, TreeNode & at_node)", "Reroot the Tree at the given TreeNode.\n\nSee reroot( Tree&, TreeLink& ) for details.The node needs to be part of the tree, otherwise an exception is thrown."},
    {"void ::genesis::tree::reroot_at_node (Tree & tree, size_t node_index)", "Reroot the Tree at the TreeNode with the given index.\n\nSee reroot( Tree&, TreeLink& ) for details.The node index needs to be valid for the tree, otherwise an exception is thrown."},
    {"void ::genesis::tree::scale_all_branch_lengths (Tree & tree, double factor=1.0)", "Scale all branch lengths of a Tree by a given factor.\n\nThis function simply multiplies all branch lengths with the given factor. See also set_all_branch_lengths() for setting the branch lengths to a value."},
    {"void ::genesis::tree::set_all_branch_lengths (Tree & tree, double length=1.0)", "Set all branch lengths of a Tree to a given value.\n\nSee also scale_all_branch_lengths() for a scaling function."},
    {"size_t ::genesis::tree::subtree_max_path_height (Tree const & tree, TreeLink const & link)", "Calculate the height of a subtree, that is, the maximum path length to a leaf of that subtree, measured in edges between the link and the leaf."},
    {"size_t ::genesis::tree::subtree_size (Tree const & tree, TreeLink const & link)", "Return the size of the subtree defined by the given TreeLink, measured in number of nodes."},
    {"std::vector< size_t > ::genesis::tree::subtree_sizes (Tree const & tree, TreeNode const & node)", "Calculate the sizes of all subtrees as seen from the given TreeNode.\n\nThe function returns a vector with as many elements as the Tree has nodes. The vector is indexed using the TreeNode::index() values.Each value in the vector tells the size (in number of nodes) of the subtree of the correnspinding node, as seen from the given starting node, and excluding that starting node.In methaphorical words, the given starting node is used as a hook where the tree is suspended from, so that it hangs down. A subtree is then the part of the tree that \"hangs down\" from a certain node. We then count the number of nodes in each of those subtrees (that is, we examine the subtree starting at each node of the tree). For the starting node, the count is always the number of nodes of the tree minus one (because the node is not counted itself)."},
    {"std::vector< size_t > ::genesis::tree::subtree_sizes (Tree const & tree)", "Calculate the sizes of all subtrees as seen from the root of the tree.\n\nSee subtree_sizes(...) for details."},
    {"bool ::genesis::tree::tree_data_is (Tree const & tree)", "Check whether the data of the nodes and edges of the Tree are exactly of the specified data types.\n\nThis function returns true iff all data types of the nodes and edges match exaclty the specified types. It uses typeid() for this matching."},
    {"bool ::genesis::tree::tree_data_is_derived_from (Tree const & tree)", "Check whether the data of the nodes and edges of the Tree are derived from the specified data types.\n\nThis function returns true iff all data types of the nodes and edges are derived from the specified types. It uses dynamic_cast() for this."},
    {"bool ::genesis::tree::validate_topology (Tree const & tree)", "Validate that all internal pointers of the Tree elements (TreeLinks, TreeNodes, TreeEdges) to each other are correct and that some other invariants are met.\n\nValidate the correctness of all Tree pointers etc.This check is a bit pedantic, but better safe than sorry."},
    {"void ::genesis::tree::write_tree_to_newick_file (CommonTree const & tree, std::string const & newick_filename)", "Write a newick file containing a tree.\n\nThis is a very simple wrapper for common cases."},
    {"void ::genesis::tree::write_tree_to_nexus_file (CommonTree const & tree, std::string const & nexus_filename)", "Write a nexus file containing a tree.\n\nThe file format can be read and visualized by, e.g., FigTree."},
    {"void ::genesis::tree::write_tree_to_phyloxml_file (CommonTree const & tree, std::string const & phyloxml_filename)", "Write a phyloxml file containing a tree.\n\nThe file format can be read and visualized by, e.g., Archaeopteryx."},
    {"TreeEdge & ::genesis::tree::add_new_leaf_node (Tree & tree, TreeEdge & target_edge)", "Add a new Node as a leaf to an existing Edge, by also adding a new Node in the middle of that Edge.\n\nThis function is a combination of add_new_node( Tree&, TreeNode& ) and add_new_node( Tree&, TreeEdge& ). Before adding the new leaf node, it first adds another Node that splits the given target_edge into two edges, and then adds the leaf to it.Thus, the procedure is as shown: \nAfter the function, the target_edge with all its data ends up on the to-root side of the new inner node.For details of how the data pointers are handled, see add_new_node( Tree&, TreeNode& ). This function behaves in a similar way. The data objects of the new nodes and edges are default-constructed objects of the same type as the target_edge and its primary node.Be aware that the data of target_edge is not changed. Thus, in trees with CommonEdgeData, the branch lengths of all three affected edges might have to be changed to the desired values after calling this function.The function returns the newly created TreeEdge that leads to the new leaf node."},
    {"TreeEdge & ::genesis::tree::add_new_node (Tree & tree, TreeNode & target_node)", "Add a new Node as a leaf to an existing Node.\n\nThe function adds a new leaf to the Tree by appending it to an existing TreeNode. For this, four new elements are created and added to the tree:\nA TreeLink that gets added to the given node and connects it to the new node.A TreeLink for the new TreeNode.The new TreeNode itself.A TreeEdge that connects the new and the given TreeNode with each other.\nThus, the procedure is as shown: \nThe new Node is added at the \"end\" of the given Node. That is, when traversing the Tree or the given Node, the new Node will be visited last. In the example, the tree is bifurcating before the new node is added. This is just an example - the function also works with Nodes that are already multifurcating.The data pointers of the new Node and Edge are initialized to default-constructed objects:\nThe new node data type is the same as the one of the given target_node.The new edge data type is the same as the one of the edge towards the root of the target_node.\nThis means that in case of a Tree where every Node and Edge has the same node and edge data type (standard case), the newly created ones will also have these data types.The function returns the newly create TreeEdge. This way, all other new elements can be accessed, using TreeEdge::primary_link(), TreeEdge::secondary_link() and TreeEdge::secondary_node()."},
    {"TreeNode & ::genesis::tree::add_new_node (Tree & tree, TreeEdge & target_edge)", "Add a new Node that splits an existing Edge.\n\nThis function adds a new Node that splits the given target_edge into two edges. Thus, the procedure is as shown: \nAfter the function, the target_edge with all its data ends up on the to-root side of the new inner node.For details of how the data pointers are handled, see add_new_node( Tree&, TreeNode& ). This function behaves in a similar way. The data objects of the new nodes and edges are default-constructed objects of the same type as the target_edge and its primary node.Be aware that the data of target_edge is not changed. Thus, in trees with CommonEdgeData, the branch lengths of all three affected edges might have to be changed to the desired values after calling this function.The function returns the newly created TreeNode ."},
    {"TreeNode & ::genesis::tree::add_root_node (Tree & tree, TreeEdge & target_edge)", "Add a new Node that splits an existing Edge, and root the tree on that new Node.\n\nThe function combines add_new_node( Tree&, TreeEdge& ) and reroot( Tree&, TreeNode& )."},
    {"bool ::genesis::tree::all_equal (TreeSet const & tset, std::function< bool(TreeNode const &, TreeNode const &)> node_comparator, std::function< bool(TreeEdge const &, TreeEdge const &)> edge_comparator)", "Compare whether all Trees in a TreeSet are equal using a given comparator functional.\n\nSee Tree::equal() for more information."},
    {"bool ::genesis::tree::all_identical_topology (TreeSet const & tset)", "Compare whether all Trees in a TreeSet are equal using their default comparision operators for nodes and edges.\n\nReturn true iff all Trees in a TreeSet have an identical topology."},
    {"Tree ::genesis::tree::average_branch_length_tree (TreeSet const & tset)", "Return a Tree where the branch lengths are the average of the Trees in the TreeSet, given that they all have the same topology.\n\nThe function works only under the following conditions: * All trees must have the same topology.\n* The TreeType must provide a data member `branch_length` for the edges.\nOtherwise, the function throws an std::runtime_error. It does not check for node names, but the returned tree will contain the names of the first tree in the set."},
    {"bool ::genesis::tree::belongs_to (Tree const & tree, TreeNode const & node)", "Return whether the TreeNode belongs to the Tree, i.e., whether it is owned by the Tree."},
    {"bool ::genesis::tree::belongs_to (TreeNode const & node, Tree const & tree)", "Return whether the TreeNode belongs to the Tree, i.e., whether it is owned by the Tree."},
    {"bool ::genesis::tree::belongs_to (Tree const & tree, TreeEdge const & edge)", "Return whether the TreeEdge belongs to the Tree, i.e., whether it is owned by the Tree."},
    {"bool ::genesis::tree::belongs_to (TreeEdge const & edge, Tree const & tree)", "Return whether the TreeEdge belongs to the Tree, i.e., whether it is owned by the Tree."},
    {"bool ::genesis::tree::belongs_to (Tree const & tree, TreeLink const & link)", "Return whether the TreeLink belongs to the Tree, i.e., whether it is owned by the Tree."},
    {"bool ::genesis::tree::belongs_to (TreeLink const & link, Tree const & tree)", "Return whether the TreeLink belongs to the Tree, i.e., whether it is owned by the Tree."},
    {"std::vector< double > ::genesis::tree::branch_lengths (Tree const & tree)", "Get a vector of all branch lengths of a Tree, index by the edge index."},
    {"std::vector< std::pair< TreeNode const *, size_t > > ::genesis::tree::closest_leaf_depth_vector (Tree const & tree)", "Returns a vector containing the closest leaf node for each node, measured in number of edges between them and its depth (number of edges between them).\n\nThe vector is indexed using the node().index() for every node. Its value contains an std::pair, where the first element is a NodeType* to the closest leaf node (with respect to its depth) and the second element its depth with respect to the node at the given index of the vector. The depth is the number of edges visited on the path between two nodes (0 for itself, 1 for immediate neighbours, etc).Thus, leaf nodes will have a pointer to themselves and a depth value of 0, and for all other nodes the depth will be the number of edges between it and the closest leaf node.There might be more than one leaf with the same depth to a given node. In this case, an arbitrary one is used."},
    {"std::vector< std::pair< TreeNode const *, double > > ::genesis::tree::closest_leaf_distance_vector (Tree const & tree)", "Return a vector containing the closest leaf node for each node, using the branch_length as distance measure.\n\nThe vector is indexed using the node().index() for every node. Its value contains an std::pair, where the first element is a TreeNode* to the closest leaf node of the node at the index, measured using the branch_length; the second element of the pair is the distance value itself. Thus, leaf nodes will have a pointer to themselves and a distance value of 0.See also furthest_leaf_distance_vector()."},
    {"Tree ::genesis::tree::convert (Tree const & source, std::function< std::unique_ptr< BaseNodeData >(BaseNodeData const &node_data)> node_data_converter, std::function< std::unique_ptr< BaseEdgeData >(BaseEdgeData const &edge_data)> edge_data_converter)", "Create a tree with the same topology as the source tree, while converting its data.\n\nThis function takes the given source Tree (possibly with different data types at the nodes and edges), and copies its topology (i.e., all links, nodes and edges, and their structure) to the newly created result tree.The data types are then converted using the two provided functions for the node data type and edge data type, respectively. If a node or an edge does not have data (i.e., the data pointer is a nullptr), the converter functions are not called, but the data of the new tree at that node or edge is also set to a nullptr."},
    {"AttributeTree ::genesis::tree::convert_common_tree_to_attribute_tree (CommonTree const & source)", "Helper function that takes a CommonTree (or any Tree with Node and Edge data derived from it) and turns its data into an AttributeTree, that is, a Tree with AttributeTreeNodeData and AttributeTreeEdgeData."},
    {"MassTree ::genesis::tree::convert_common_tree_to_mass_tree (CommonTree const & source)", "Helper function that takes a CommonTree (or any Tree with Node and Edge data derived from it) and turns its data into an MassTree, that is, a Tree with MassTreeNodeData and MassTreeEdgeData."},
    {"CommonTree ::genesis::tree::convert_to_common_tree (Tree const & source_tree)", "Convert a Tree to a CommonTree with CommonNodeData and CommonEdgeData.\n\nThis works for all Trees that have data derived from those two data base classes. Also nodes or edges without data work. However, an expection is thrown if any node or edge contains data that is not derived from CommonNodeData and CommonEdgeData, respectively.The data itself is copied using the clone functions, so that all names and branch lengths are transferred to the returned Tree."},
    {"double ::genesis::tree::deepest_distance (Tree const & tree)", "Return the longest distance from any point in the tree (on the edges) to any leaf."},
    {"size_t ::genesis::tree::degree (TreeNode const & node)", "Return the degree of the node, i.e. how many neighbouring nodes it has."},
    {"double ::genesis::tree::diameter (Tree const & tree)", "Get the diameter of the tree, i.e., the longest distance between any two nodes, measured using the branch_length."},
    {"double ::genesis::tree::earth_movers_distance (MassTree const & lhs, MassTree const & rhs, double p=1.0)", "Calculate the earth mover's distance of two distributions of masses on a given Tree.\n\nThe earth mover's distance is typically a distance measure between two distributions. See [Earth mover's distance](https://en.wikipedia.org/wiki/Earth_mover's_distance) for an introduction.In our case, we use distibutions of masses along the branches of a tree. Each branch can have multiple masses at different positions within [0.0, branch_length].The distance is calculated as the amount of work needed to move the masses of one distribution so that they end up in the positions of the masses of the other distribution. Work is here defined as mass times dislocation. Thus, the work is higher if either more mass has to be moved, or if mass has to be moved further.Here, the parameter p is used to control the influence of mass and distance, with 0.0 < p < inf, and default p == 1.0, which is the neutral case. A larger p increases the impact of distance traveled, while a smaller p emphasizes differences of mass. For details, see the references cited below.The resulting distance is independed of the rooting of the tree and commutative with respect to the two mass distributions.The earth mover's distance is only meaningful if both mass distributions contain the same amount of total mass. See mass_tree_sum_of_masses()  to check this. Also, in order to give comparable results over different tree topologies, the mass can be normalized using mass_tree_normalize_masses(). Then, the result of the earth mover's distance is always in the range [ 0.0, 1.0 ].See earth_movers_distance( Sample const&, ... )  for an exemplary usage of this function, which applies the earth mover's distance to the placement weights (like_weight_ratio) of a PlacementTree.References:[1] Guppy Documentation: http://matsen.github.io/pplacer/generated_rst/guppy_kr.html#guppy-kr[2] F. A. Matsen and S. N. Evans, Edge principal components and squash clustering: using the special structure of phylogenetic placement data for sample comparison., PLoS One, 2011. DOI: 10.1371/journal.pone.0056859[3] S. N. Evans and F. A. Matsen, The phylogenetic Kantorovich-Rubinstein metric for environmental sequence samples., Statistical Methodology, 2012. DOI: 10.1111/j.1467-9868.2011.01018.x"},
    {"utils::Matrix< double > ::genesis::tree::earth_movers_distance (std::vector< MassTree > const & trees, double p=1.0)", "Calculate the pairwise earth mover's distance for all MassTrees.\n\nThe result is a pairwise distance Matrix using the indices of the given vector. See earth_movers_distance( MassTree const&, MassTree const&, double ) for details on the calculation."},
    {"std::pair< double, double > ::genesis::tree::earth_movers_distance (MassTree const & tree, double p=1.0)", "Calculate the earth mover's distance of masses on a given Tree.\n\nThis function is mainly used as a speed-up for calculating earth_movers_distance( MassTree const&, MassTree const& ). See there for more details.It uses the following convention for the two distributions: The masses of one distribution are stored using a positive sign, the masses of the other distribution use a negative sign. This way, only one Tree needs to be stored, and the algorithm is significantly simplyfied.Thus, as the earth mover's distance is only meaningful if both distributions have the same sum, and we use opposite signs to store the masses, the sum of all masses on the tree should ideally be zero (apart from numerical derivations). See mass_tree_sum_of_masses()  and mass_tree_validate()  for functions to verify this.The function returns two doubles: The first one is the actual distance, the second one gives the remaining mass at the root node. This should also be close to 0.0, as there, all masses from the subtrees should ideally cancel each other out. Use this value to check whether this actually worked out. Too big numbers indicate that something is wrong with the sums of the signed masses."},
    {"TreeEdge * ::genesis::tree::edge_between (TreeNode & lhs, TreeNode & rhs)", "Return the TreeEdge between two TreeNode&s, if they are neighbours, or nullptr otherwise."},
    {"TreeEdge const * ::genesis::tree::edge_between (TreeNode const & lhs, TreeNode const & rhs)", "Return the TreeEdge between two TreeNode&s, if they are neighbours, or nullptr otherwise."},
    {"size_t ::genesis::tree::edge_count (Tree const & tree)", "Return the number of Edges of a Tree. Same as Tree::edge_count()."},
    {"utils::Matrix< signed char > ::genesis::tree::edge_sides (Tree const & tree)", "Create a Matrix that indiciaces the relative position of the Edges of a Tree, i.e., whether they are on the root side or non-root side.\n\nFor a Tree with e many Edges, the resulting square Matrix has dimensions ( e, e ). The row at index i corresponds to edge i, which can be accessed via Tree::edge_at(). The entries of that row indicate whether the other edges (as indexed by the columns) are on the root side of the edge i, in which case the entry is -1, or on the non-root side, in which case the entry is 1. The entry for the edge i itself (which is the diagonale) is 0.In other words, all edges on the proximal side of a given edge are denoted by a -1, while all edges on the distal side of the given edge are denoted by a 1.As a consequence, the rows of edges that lead to a leaf are full of 1s (with the exception of the diagonal entry, which still is 0). This is because for leaf edges, all other edges are on the root side of the tree."},
    {"bool ::genesis::tree::equal (Tree const & lhs, Tree const & rhs, std::function< bool(TreeNode const &, TreeNode const &) > node_comparator, std::function< bool(TreeEdge const &, TreeEdge const &) > edge_comparator)", "Compares two trees for equality given binary comparator functionals for their nodes and edges.\n\nThis function does a preorder traversal of both trees in parallel and calls the comparator functionals for each position of the iterator. It returns true iff the comparators are true for every position.The comparator functionals can be either function pointers, function objects, or lambda expressions.As the traversal is done in parallel, the trees are also checked for equal topology: their elements (links, nodes, edges) have to be equal in size and the degree of each node during the traversal has to be identical in both trees. Those assumptions are made because two trees that do not have identical topology are never considered equal."},
    {"bool ::genesis::tree::equal_common_trees (Tree const & lhs, Tree const & rhs, bool compare_node_names, bool compare_branch_lengths)", "Compare two CommonTrees, that is, check whether they have identical topology, node names, and branch lenghts."},
    {"std::vector< size_t > ::genesis::tree::find_monophyletic_subtree_edges (Tree const & tree, std::vector< Bipartition > const & bips, std::vector< TreeNode const * > nodes)", "Find clades of the tree that are monophyletic with respect to the given list of nodes, that is, clades that only contain nodes from that list. Retun all edge indices of those clades."},
    {"TreeNode const * ::genesis::tree::find_node (Tree const & tree, const std::string & name, bool replace_underscores)", "Finds a Node, given its name. If not found, nullptr is returned."},
    {"TreeNode * ::genesis::tree::find_node (Tree & tree, const std::string & name, bool replace_underscores)", "Finds a Node, given its name. If not found, nullptr is returned."},
    {"Bipartition ::genesis::tree::find_smallest_subtree (Tree const & tree, std::vector< Bipartition > const & bipartitions, std::vector< TreeNode const * > nodes)", "Find the smallest subtree (measured in number of nodes) that contains all given nodes.\n\nA subtree is defined by one of the two parts of a tree that are splitted by one edge. Thus, this function tries all subtrees by leaving out each edge once.If no fitting subtree exists, the function returns an empty Bipartition."},
    {"Tree * ::genesis::tree::find_tree (TreeSet & tset, std::string const & name)", "Get the first Tree in a TreeSet that is stored with a given name, or nullptr if not found."},
    {"Tree const * ::genesis::tree::find_tree (TreeSet const & tset, std::string const & name)", "Get the first Tree in a TreeSet that is stored with a given name, or nullptr if not found."},
    {"std::vector< std::pair< TreeNode const *, double > > ::genesis::tree::furthest_leaf_distance_vector (Tree const & tree)", "Opposite of closest_leaf_distance_vector()."},
    {"double ::genesis::tree::height (Tree const & tree)", "Get the height of the tree, i.e., the longest distance from the root to a leaf, measured using the branch_length."},
    {"bool ::genesis::tree::identical_topology (Tree const & lhs, Tree const & rhs)", "Returns true iff both trees have an identical topology.\n\nThe topology is considered identical only if the order of edges is also the same in both trees. This means, although two trees might have the same number of leaves and branches, they might still be not identical (with respect to this function) when the branches appear in a different order or when the root sits at a different node."},
    {"size_t ::genesis::tree::inner_edge_count (Tree const & tree)", "Return the number of Edges of a Tree that do not lead to a leaf Node."},
    {"std::vector< size_t > ::genesis::tree::inner_edge_indices (Tree const & tree)", "Get a list of the edge indices of all inner edges, that is, all TreeEdges that do not lead to a leaf TreeNode."},
    {"size_t ::genesis::tree::inner_node_count (Tree const & tree)", "Count the number of inner Nodes."},
    {"std::vector< size_t > ::genesis::tree::inner_node_indices (Tree const & tree)", "Get a list of the node indices of all inner TreeNodes."},
    {"bool ::genesis::tree::is_bifurcating (Tree const & tree, bool strict=false)", "Return whether the Tree is bifurcating.\n\nIf strict is set to true, the tree may not contain any nodes of degree 2 (nodes that do not have a furcation at all). This includes the root node. Thus, with this option set, the tree also has to be unrooted."},
    {"bool ::genesis::tree::is_inner (TreeLink const & link)", "Return true iff the node of the given link is an inner node."},
    {"bool ::genesis::tree::is_inner (TreeEdge const & edge)", "Return true iff the secondary node (outwards) of the given edge is an inner node."},
    {"bool ::genesis::tree::is_inner (TreeNode const & node)", "Return whether the node is an inner node."},
    {"bool ::genesis::tree::is_leaf (TreeLink const & link)", "Return true iff the node of the given link is a leaf node."},
    {"bool ::genesis::tree::is_leaf (TreeEdge const & edge)", "Return true iff the secondary node (outwards) of the given edge is a leaf node."},
    {"bool ::genesis::tree::is_leaf (TreeNode const & node)", "Return whether the node is a leaf/tip."},
    {"bool ::genesis::tree::is_root (TreeNode const & node)", "Return whether the node is the root of its Tree."},
    {"bool ::genesis::tree::is_rooted (Tree const & tree)", "Return whether the Tree is rooted, that is, whether the root node has two neighbors."},
    {"std::vector< std::pair< TreeNode const *, double > > ::genesis::tree::leaf_distance_vector (Tree const & tree, utils::Matrix< double > const & node_distances, Comparator comp)", "Local helper function to calculate either closest_leaf_distance_vector() or furthest_leaf_distance_vector()."},
    {"size_t ::genesis::tree::leaf_edge_count (Tree const & tree)", "Return the number of Edges of a Tree that lead to a leaf Node."},
    {"std::vector< size_t > ::genesis::tree::leaf_edge_indices (Tree const & tree)", "Get a list of the edge indices of all leaf edges, that is, all TreeEdges that lead to a leaf TreeNode."},
    {"utils::Bitvector ::genesis::tree::leaf_node_bitvector (Tree const & tree, std::vector< TreeNode const * > leaf_nodes)", "Return a Bitvector that has as many entries as the tree has leaf nodes, and is true where the given leaf_nodes are."},
    {"size_t ::genesis::tree::leaf_node_count (Tree const & tree)", "Count the number of leaf Nodes of a Tree."},
    {"std::vector< size_t > ::genesis::tree::leaf_node_indices (Tree const & tree)", "Get a list of the node indices of all leaf TreeNodes."},
    {"double ::genesis::tree::length (Tree const & tree)", "Get the length of the tree, i.e., the sum of all branch lengths."},
    {"TreeNode const & ::genesis::tree::lowest_common_ancestor (TreeNode const & node_a, TreeNode const & node_b)", "Return the lowest common ancestor of two TreeNodes."},
    {"TreeNode & ::genesis::tree::lowest_common_ancestor (TreeNode & node_a, TreeNode & node_b)", "Return the lowest common ancestor of two TreeNodes."},
    {"utils::Matrix< size_t > ::genesis::tree::lowest_common_ancestors (Tree const & tree)", "Return the lowest common ancestor of each pair of TreeNodes for a given tree, in form of a Matrix of their indices.\n\nThe entries in the resulting Matrix are the Node indices of the lowest common ancestor (LCA) of a given pair of Nodes. For example, for the result Matrix r, the entry r[ 3, 5 ] == 7 means that the LCA of Nodes 3 and 5 is Node 7.These Nodes can for example be accesses via Tree::node_at()."},
    {"bool ::genesis::tree::mass_tree_all_identical_topology (std::vector< MassTree > const & mass_trees)", "Return true iff all Trees in the vector have an identical topology."},
    {"double ::genesis::tree::mass_tree_binify_masses (MassTree & tree, size_t number_of_bins)", "Accumulate all masses of a MassTree into bins on each branch.\n\nEach branch is divided into intervals of equal size, where number_of_bins is the number of those intervals. The mid points of these intervals are then used as bins, to which the masses on the branch are moved. Each mass point is moved to its closest bin, so that all mass is accumulated at the bins.This function is useful to reduce the data load of big MassTrees, without affecting the accuracy of downstream analyses too much. Using the interval mid points as bins means that masses are moved as little as possible.Example: Given number_of_bins == 6, for a branch of length 3.6, the bins look like this: Intervals   0.0   0.6   1.2   1.8   2.4   3.0   3.6\n            |     |     |     |     |     |     |\n               ^     ^     ^     ^     ^     ^\nBins           0.3   0.9   1.5   2.1   2.7   3.3\nThe function returns the work (mass times distance) that was needed to move the masses to the bins."},
    {"double ::genesis::tree::mass_tree_center_masses_on_branches (MassTree & tree)", "Accumulate all masses of a MassTree on the centers of their edges.\n\nThis function can be used to minimize the data load of a MassTree. It is equal to mass_tree_binify_masses() when using number_of_bins == 1.Return the work (mass times distance) that was needed to move the masses to the centers."},
    {"double ::genesis::tree::mass_tree_center_masses_on_branches_averaged (MassTree & tree)", "Accumulate all masses of a MassTree at the average mass position per edge.\n\nThis function is similar to mass_tree_center_masses_on_branches(), but instead of accumulating the masses at the branch center, they are accumulated at their average position on the branch.Return the work (mass times distance) that was needed to move the masses to the centers."},
    {"Taxon & ::genesis::taxonomy::add_from_taxopath (Taxonomy & taxonomy, Taxopath const & taxopath, bool expect_parents)", "Add a Taxon to a Taxonomy, using the taxonomic elements of a Taxopath.\n\nFor example, given a Taxopath like [ \"Animalia\", \"Vertebrata\", \"Mammalia\", \"Carnivora\" ]\nthis functions adds the following hierarchy to the Taxonomy: Animalia\n    Vertebrata\n        Mammalia\n            Carnivora\nFor any existing Taxa, nothing happens. If any (parent) Taxon in the hierarchy does not exist, it is created by default.\n\ntaxonomy\n\n\nTaxonomy to add the Taxon to. \n\n\n\ntaxopath\n\n\nA Taxopath object from which the Taxon and its parents are taken. \n\n\n\nexpect_parents\n\n\nOptional, defaults to false. If set to true, the function expects all super-taxa of the added Taxon to exists, that is, all taxa except for the last one in the hierachry. If this expectation is not met, that is, if not all super-taxa exist, an std::runtime_error exception is thrown. If left at the default (false), all necessary super-taxa are created if they do not exists yet.\n\n\nThe function returns a reference to the newly created Taxon. This is the deepest Taxon of the Taxopath; in other words, its last element."},
    {"size_t ::genesis::taxonomy::count_taxa_with_prune_status (Taxonomy const & taxonomy, EntropyTaxonData::PruneStatus status)", "Return the number of Taxa that have a certain prune status."},
    {"void ::genesis::taxonomy::expand_small_subtaxonomies (Taxonomy & taxonomy, size_t min_subtaxonomy_size)", "Expand the leaves of a pruned Taxonomy if their sub-taxonomies are smaller than the given threshold.\n\nThis function takes a Taxonomy with EntropyTaxonData on its Taxa and looks for taxa with status kBorder which have fewer than the threshold many leaves. If so, this sub-taxonomy is expaneded. This is, it is turned into taxa with status kInside for inner taxa and kBorder for leaf taxa."},
    {"Taxon const * ::genesis::taxonomy::find_taxon (Taxonomy const & tax, UnaryPredicate p)", "Alias for find_taxon(..., DepthFirstSearch{})"},
    {"Taxon * ::genesis::taxonomy::find_taxon (Taxonomy & tax, UnaryPredicate p)", "Alias for find_taxon(..., DepthFirstSearch{})"},
    {"Taxon const * ::genesis::taxonomy::find_taxon (Taxonomy const & tax, UnaryPredicate p, DepthFirstSearch )", "Find a Taxon based on a given predicate by recursively searching the Taxonomy in a depth first manner."},
    {"Taxon const * ::genesis::taxonomy::find_taxon (Taxonomy const & tax, UnaryPredicate p, BreadthFirstSearch )", "Find a Taxon based on a given predicate by recursively searching the Taxonomy in a breadth first manner."},
    {"Taxon * ::genesis::taxonomy::find_taxon (Taxonomy & tax, UnaryPredicate p, SearchStrategy strat)", "Find a Taxon based on a given predicate by recursively searching the Taxonomy according to a search strategy."},
    {"Taxon const * ::genesis::taxonomy::find_taxon_by_id (Taxonomy const & tax, std::string const & id)", "Alias for find_taxon_by_id(..., DepthFirstSearch{})."},
    {"Taxon * ::genesis::taxonomy::find_taxon_by_id (Taxonomy & tax, std::string const & id)", "Alias for find_taxon_by_id(..., DepthFirstSearch{})."},
    {"Taxon const * ::genesis::taxonomy::find_taxon_by_id (Taxonomy const & tax, std::string const & id, SearchStrategy strat)", "Find a Taxon with a given ID by recursively searching the Taxonomy according to a search strategy."},
    {"Taxon * ::genesis::taxonomy::find_taxon_by_id (Taxonomy & tax, std::string const & id, SearchStrategy strat)", "Find a Taxon with a given ID by recursively searching the Taxonomy according to a search strategy."},
    {"Taxon const * ::genesis::taxonomy::find_taxon_by_name (Taxonomy const & tax, std::string const & name)", "Alias for find_taxon_by_name(..., DepthFirstSearch{})."},
    {"Taxon * ::genesis::taxonomy::find_taxon_by_name (Taxonomy & tax, std::string const & name)", "Alias for find_taxon_by_name(..., DepthFirstSearch{})."},
    {"Taxon const * ::genesis::taxonomy::find_taxon_by_name (Taxonomy const & tax, std::string const & name, SearchStrategy strat)", "Find a Taxon with a given name by recursively searching the Taxonomy according to a search strategy."},
    {"Taxon * ::genesis::taxonomy::find_taxon_by_name (Taxonomy & tax, std::string const & name, SearchStrategy strat)", "Find a Taxon with a given name by recursively searching the Taxonomy according to a search strategy."},
    {"Taxon const * ::genesis::taxonomy::find_taxon_by_taxopath (Taxonomy const & tax, Taxopath const & taxopath)", "Find a Taxon in a Taxonomy, given its Taxopath."},
    {"Taxon * ::genesis::taxonomy::find_taxon_by_taxopath (Taxonomy & tax, Taxopath const & taxopath)", "Find a Taxon in a Taxonomy, given its Taxopath."},
    {"bool ::genesis::taxonomy::has_unique_ids (Taxonomy const & tax)", "Return true iff all IDs of the Taxa in the Taxonomy are unique."},
    {"void ::genesis::taxonomy::levelorder_for_each (Taxonomy & tax, std::function< void(Taxon &)> fn, bool include_inner_taxa=true)", "Apply a function to all taxa of the Taxonomy, traversing it in levelorder.\n\nThe given Taxonomy is traversed in levelorder (i.e., breadth-first search). If include_inner_taxa is set to true (default), the provided functional is called for all Taxa . Otherwise, the functional is only called for the taxa of lowest rank, that is, for each Taxon that does not have sub-taxa.This is the non-const version of the function."},
    {"void ::genesis::taxonomy::levelorder_for_each (Taxonomy const & tax, std::function< void(Taxon const &)> fn, bool include_inner_taxa=true)", "Apply a function to all taxa of the Taxonomy, traversing it in levelorder.\n\nThe given Taxonomy is traversed in levelorder (i.e., breadth-first search). If include_inner_taxa is set to true (default), the provided functional is called for all Taxa . Otherwise, the functional is only called for the taxa of lowest rank, that is, for each Taxon that does not have sub-taxa.This is the const version of the function."},
    {"void ::genesis::taxonomy::postorder_for_each (Taxonomy & tax, std::function< void(Taxon &)> fn, bool include_inner_taxa=true)", "Apply a function to all taxa of the Taxonomy, traversing it in postorder.\n\nThe given Taxonomy is traversed in postorder (i.e., a variant of depth-first search). If include_inner_taxa is set to true (default), the provided functional is called for all Taxa . Otherwise, the functional is only called for the taxa of lowest rank, that is, for each Taxon that does not have sub-taxa.This is the non-const version of the function."},
    {"void ::genesis::taxonomy::postorder_for_each (Taxonomy const & tax, std::function< void(Taxon const &)> fn, bool include_inner_taxa=true)", "Apply a function to all taxa of the Taxonomy, traversing it in postorder.\n\nThe given Taxonomy is traversed in postorder (i.e., a variant of depth-first search). If include_inner_taxa is set to true (default), the provided functional is called for all Taxa . Otherwise, the functional is only called for the taxa of lowest rank, that is, for each Taxon that does not have sub-taxa.This is the const version of the function."},
    {"void ::genesis::taxonomy::preorder_for_each (Taxonomy & tax, std::function< void(Taxon &)> fn, bool include_inner_taxa=true)", "Apply a function to all taxa of the Taxonomy, traversing it in preorder.\n\nThe given Taxonomy is traversed in preorder (i.e., a variant of depth-first search). If include_inner_taxa is set to true (default), the provided functional is called for all Taxa . Otherwise, the functional is only called for the taxa of lowest rank, that is, for each Taxon that does not have sub-taxa.This is the non-const version of the function."},
    {"void ::genesis::taxonomy::preorder_for_each (Taxonomy const & tax, std::function< void(Taxon const &)> fn, bool include_inner_taxa=true)", "Apply a function to all taxa of the Taxonomy, traversing it in preorder.\n\nThe given Taxonomy is traversed in preorder (i.e., a variant of depth-first search). If include_inner_taxa is set to true (default), the provided functional is called for all Taxa . Otherwise, the functional is only called for the taxa of lowest rank, that is, for each Taxon that does not have sub-taxa.This is the const version of the function."},
    {"std::string ::genesis::taxonomy::print_pruned_taxonomy (Taxonomy const & taxonomy)", "Print a Taxonomy, highlighting those Taxa that are the pruning border, i.e., where we cut off the sub-taxa, and print their entropies next to them."},
    {"void ::genesis::taxonomy::prune_by_entropy (Taxonomy & taxonomy, size_t target_taxonomy_size, PruneByEntropySettings settings={})", "Prune a Taxonomy so that the result (approximately) contains a desired number of \"leaf\" Taxa, using the entropy of the Taxa as indicator where to prune.\n\nThe function takes a Taxonomy with data type EntropyTaxonData and a target size which indicates the desired number of \"leaf\" Taxa after pruning the Taxonomy. In the pruned Taxonomy, some Taxa are considered as belonging to the Taxonomy (have status EntropyTaxonData::PruneStatus::kInside or EntropyTaxonData::PruneStatus::kBorder), while others (deeper in the Taxonomy) are excluded (have status EntropyTaxonData::PruneStatus::kOutside). The number of border taxa (or \"leaves\") of the included Taxa then is aimed to be as close as possible to the target size.That means, this function sets the status of the Taxa, but does not remove any Taxa. All Taxa with status EntropyTaxonData::PruneStatus::kOutside are then considered to be pruned from the taxonomy.Example: The Taxonomy Tax_1\n    Tax_2\n        Tax_3\n        Tax_4\n    Tax_5\n        Tax_6\nTax_7\n    Tax_8\n    Tax_9\ncontains 5 \"leaf\" taxa, i.e., Tax_3, Tax_4, Tax_6, Tax_8 and Tax_9. If we want to prune it with a target size of 3, we might end up with either Tax_1\n    Tax_2\n    Tax_5\nTax_7\nor Tax_1\nTax_7\n    Tax_8\n    Tax_9\nas both contain 3 \"leaves\": Tax_2, Tax_5 and Tax_7 in the former case and Tax_1, Tax_8 and Tax_9 in the latter. Which of those two is used depends on the entropies of the Taxa.In the former case, Tax_1 is considered inside, Tax_2, Tax_5 and Tax_7 are border, and all other taxa are outside of the pruned Taxonomy. In the latter case, Tax_7 is inside, Tax_1, Tax_8 and Tax_9 are border, and again all others are outside.It is not always possible to prune a Taxonomy in a way the we exaclty hit the target size. The function then ends at a number of border Taxa that is closest (either below or above the target size).In order to decide which Taxa to set to inside (i.e., not include as leaves, but further resolve into their children), we use the entropies of the Taxa: We choose to split up at a current border Taxon with the highest entropy value, as long as this brings us closer to the target size.This means that the above case where we had two possible ways of splitting should be rare, as the entropies will rarely be identical with real world data sets. If this happens nonetheless, it is random which of the Taxa with equal entropy will be used.In order to control further settings, see PruneByEntropySettings."},
    {"std::string ::genesis::taxonomy::rank_from_abbreviation (char r)", "Get the taxonomic rank name given its abbreviation.\n\nThe common taxonomic ranks are used: D Domain\nK Kingdom\nP Phylum\nC Class\nO Order\nF Family\nG Genus\nS Species\nIf any of those abbreviations (case-independend) is given, the full rank name is returned. For all other input, an empty string is returned."},
    {"std::string ::genesis::taxonomy::rank_to_abbreviation (std::string const & rank)", "Get the abbreviation of a taxonomic rank name.\n\nThis function returns the abbreviation for a given common taxonomic rank name, case-independently. See rank_from_abbreviation() for a list of valid rank names. If the given rank name is invalid, an empty string is returned."},
    {"void ::genesis::taxonomy::remove_pruned_taxonomy_children (Taxonomy & taxonomy)", "Remove the children of all Taxa that are pruned, i.e, that have prune status == kOutside.\n\nThe function does not validate the status before. Use validate_pruned_taxonomy() if you are unsure whether the status is correct for all Taxa."},
    {"void ::genesis::taxonomy::remove_taxa_at_level (Taxonomy & tax, size_t level)", "Remove all Taxa  at a given level of depth in the Taxonomy hierarchy, and all their children.\n\nThat is, providing level = 0 has the same effect as calling clear_children()  on the given Taxonomy; level = 1 has this effect for the children of the given Taxonomy; and so on.See taxon_level() for more information on the level."},
    {"void ::genesis::taxonomy::reset_taxonomy_data (Taxonomy & taxonomy, bool allow_overwrite=true)", "(Re-)set all Taxon data of a Taxonomy to a specified data type.\n\nThe data is created empty, using BaseTaxonData::create(). If the optional parameter allow_overwrite is set to false (instead of the default true), the function throws an exception if a Taxon already has data assigned to it."},
    {"std::pair< std::string, std::string > ::genesis::taxonomy::resolve_rank_abbreviation (std::string const & entry)", "Resolve a combined rank and name entry of the form \"k_Bacteria\" into the full rank and the name, i.e. \"Kingdom\" and \"Bacteria\".\n\nThe function returns a pair of { \"rank\", \"name\" }.The expected format of the input string is \"x_abc\", where \"x\" is a rank name abbreviation and \"abc\" is a taxon name. If the string is in this format, it is split and the rank name abbreviation is resolved. If this abbreviation is valid, the rank (first) and the name (second) are returned. See rank_from_abbreviation() for the list of valid rank name abbreviations. The number of underscores is irrelevant, that is, C___Mammalia also works and will return { \"Class\", \"Mammalia\" }.If any of the conditions is not met (either, the string does not start with \"x_\", or the rank name abbreviation is invalid), the rank is left empty, and the whole given string is used as name. Thus, this function also works on normal taxon names."},
    {"void ::genesis::taxonomy::sort_by_name (Taxonomy & tax, bool recursive=true, bool case_sensitive=false)", "Sort the Taxa of a Taxonomy by their name.\n\nAfter calling this function, the Taxa are stored in the order given by their names. This is useful for e.g., output.\n\ntax\n\n\nTaxonomy to be sorted. \n\n\n\nrecursive\n\n\nOptional, default is true. If set to true, the sub-taxa are also sorted. If set to false, only the immediate children of the given Taxonomy are sorted. \n\n\n\ncase_sensitive\n\n\nOptional, default is false. Determines whether the name string comparison is done in a case sensitive manner or not."},
    {"void ::genesis::taxonomy::swap (Taxonomy & lhs, Taxonomy & rhs)", "Swapperator for Taxonomy."},
    {"size_t ::genesis::taxonomy::taxa_count_at_level (Taxonomy const & tax, size_t level)", "Count the number of Taxa at a certain level of depth in the Taxonomy.\n\nThe function returns how many Taxa there are in the Taxonomy that are at a certain level - that is excluding the number of their respective sub-taxa. The first/top level has depth 0.See here for a version of this function that returns those values for all levels of depth."},
    {"std::vector< size_t > ::genesis::taxonomy::taxa_count_levels (Taxonomy const & tax)", "Count the number of Taxa at each level of depth in the Taxonomy.\n\nThe function returns how many Taxa there are in the Taxonomy that are at each level - that is excluding the number of their respective sub-taxa. The first/top level has depth 0; it's count is the first element in the returned vector, and so on.This function returns the values of taxa_count_at_level( Taxonomy const& tax, size_t level ) for all levels of depth."},
    {"size_t ::genesis::taxonomy::taxa_count_lowest_levels (Taxonomy const & tax)", "Return the number of lowest level Taxa (i.e., taxa without sub-taxa) in the Taxonomy.\n\nThe function counts the number of taxa without any sub-taxa, that is, the \"leaves\" of the Taxonomy.Example: The Taxonomy Tax_1\n    Tax_2\n        Tax_3\n    Tax_4\n        Tax_5\nTax_6\n    Tax_7\ncontains 3 such taxa, i.e., Tax_3, Tax_5 and Tax_7."},
    {"std::unordered_map< std::string, size_t > ::genesis::taxonomy::taxa_count_ranks (Taxonomy const & tax, bool case_sensitive=false)", "Count the number of Taxa in a Taxonomy per rank.\n\nThe function gives a list of all ranks found in the Taxonomy, with a count of how many Taxa there are that have this rank.It is similar to this function, but gives the result for all ranks.If the optional parameter case_sensitive is set to true, all ranks are treated case sensitive, that is, ranks with different case produce different entries. If left at the default false, they are converted to lower case first, so that they are all treated case insensitivly."},
    {"size_t ::genesis::taxonomy::taxa_count_with_rank (Taxonomy const & tax, std::string const & rank, bool case_sensitive=false)", "Count the number of Taxa in a Taxonomy that have a certain rank assigned to them.\n\nThe function recursively iterates all sub-taxa of the Taxonomy and counts how many of the Taxa have the given rank assigned (case sensitive or not).See here for a version of this function that returns this number for all ranks in the Taxonomy."},
    {"size_t ::genesis::taxonomy::taxon_level (Taxon const & taxon)", "Return the level of depth of a given Taxon.\n\nThis level is the number of parents the Taxon has, excluding the Taxonomy which contains them. That means, the immediate children of a Taxonomy all have level 0, their children level 1, and so on."},
    {"bool ::genesis::taxonomy::taxonomy_data_is (Taxonomy const & taxonomy)", "Check whether the data of a Taxonomy are exactly of the specified data type.\n\nThis function returns true iff all Taxa have data of the given type, using typeid() for this matching."},
    {"bool ::genesis::taxonomy::taxonomy_data_is_derived_from (Taxonomy const & taxonomy)", "Check whether the data of a Taxonomy are derived from the specified data type.\n\nThis function returns true iff all Taxa have data whose types are derived from the specified type. It uses dynamic_cast() for this."},
    {"size_t ::genesis::taxonomy::total_taxa_count (Taxonomy const & tax)", "Return the total number of taxa contained in the Taxomony, i.e., the number of (non-unique) names of all children (recursively).\n\nExample: The Taxonomy Tax_1\n    Tax_2\n        Tax_3\n    Tax_4\n        Tax_3\nTax_5\ncontains a total of 6 taxa. The name Tax_3 appears twice and is counted twice."},
    {"bool ::genesis::taxonomy::validate (Taxonomy const & taxonomy, bool stop_at_first_error=false)", "Validate the internal data structures of a Taxonomy and its child Taxa Taxa.\n\nThe function validates the correctness of internal pointers, particularly, the parent pointers of Taxon. If the structure is broken, a log message is logged to LOG_INFO and the functions returns false.\n\ntaxonomy\n\n\nThe Taxonomy object to validate. \n\n\n\nstop_at_first_error\n\n\nOptional, defaults to false. By default, all errors are reported. If set to true, only the first one is logged and the function immediately returns false (or runs through and returns true if no errors are found)."},
    {"bool ::genesis::taxonomy::validate_pruned_taxonomy (Taxonomy const & taxonomy)", "Validate that the pruning status of a Taxonomy is valid.\n\nThis function expects the Taxa of the Taxonomy to have data type EntropyTaxonData. It then checks whether the pruning states are all correctly set.That means:\nTaxa with status kInside can only have children of the same status or of kBorder.Taxa with status kBorder can only have children of status kOutside.Taxa with status kOutside can only have children of the same status.\nIf any of those conditions is not met, an information about the faulty Taxon is written to LOG_INFO, and the function returns false."},
    {"double ::genesis::sequence::absolute_entropy (SiteCounts const & counts, SiteEntropyOptions per_site_options)", "Return the sum of all site entropies.\n\nThis function simply sums up up the site_entropy() for all sites of the SiteCounts object. The function additionally takes optional flags to refine the site entropy calculation, see SiteEntropyOptions for their explanation."},
    {"std::string ::genesis::sequence::amino_acid_codes_all ()", "Return all valid amino acid codes. Those are \"ACDEFGHIKLMNOPQRSTUVWYBJZX*-?\"."},
    {"std::string ::genesis::sequence::amino_acid_codes_degenerated ()", "Return all degenerated amino acid codes. Those are \"BJZ\"."},
    {"std::string ::genesis::sequence::amino_acid_codes_plain ()", "Return all plain amino acid codes. Those are \"ACDEFGHIKLMNOPQRSTUVWY\"."},
    {"std::string ::genesis::sequence::amino_acid_codes_undetermined ()", "Return all undetermined amino acid codes. Those are \"X*-?\"."},
    {"std::map< char, utils::Color > ::genesis::sequence::amino_acid_colors ()", "Return a map of Colors for each amino acid code.\n\nThis function gives a Color for each amino acid code."},
    {"std::string ::genesis::sequence::amino_acid_name (char code)", "Get the name of a amino acid given its IUPAC code.\n\nThe codes are translated as follows: A Alanine\nB Aspartic acid or Asparagine\nC Cysteine\nD Aspartic acid\nE Glutamic acid\nF Phenylalanine\nG Glycine\nH Histidine\nI Isoleucine\nJ Leucine or Isoleucine\nK Lysine\nL Leucine\nM Methionine\nN Asparagine\nO Pyrrolysine\nP Proline\nQ Glutamine\nR Arginine\nS Serine\nT Threonine\nU Selenocysteine\nV Valine\nW Tryptophan\nY Tyrosine\nZ Glutamic acid or Glutamine\nX any\n* translation stop\n- gap\n? gap\nThe code char is treated case-insensitive. If the given code char is not valid, an std::out_of_range exception is thrown."},
    {"std::map< char, std::string > ::genesis::sequence::amino_acid_text_colors ()", "Return a map of text colors for each amino acid code.\n\nThis function gives a color name usable for utils::Style for each amino acid code. The return value of this function can for example be used in sequence::print_color() function."},
    {"double ::genesis::sequence::averaged_entropy (SiteCounts const & counts, bool only_determined_sites=false, SiteEntropyOptions per_site_options)", "Return the averaged sum of all site entropies.\n\nThis function sums up up the site_entropy() for all sites of the SiteCounts object and returns the average result per site.If only_determined_sites is false (default), the average is calculated using the total number of sites, that is, it simply calculates the average entropy per site.If only_determined_sites is true, the average is calculated using the number of determined sites only; that is, sites that only contain zeroes in all counts are skipped. Those sites do not contribute entropy anyway. Thus, it calcuates the average entropy per determiend site.The function additionally takes optional flags to refine the site entropy calculation, see SiteEntropyOptions for their explanation."},
    {"std::map< char, double > ::genesis::sequence::base_frequencies (Sequence const & seq, std::string const & plain_chars)", "Get the base frequencies of the sites in a Sequence given the base chars.\n\nThis returns the relative proportions of the given plain_chars to each other. Typically, the given chars come from either nucleic_acid_codes_plain() or amino_acid_codes_plain(), depending on the dataset.It is necessary to select those chars on a per-dataset basis, as it is up to the user to define the meaning of those chars."},
    {"std::map< char, double > ::genesis::sequence::base_frequencies (SequenceSet const & set, std::string const & plain_chars)", "Get the base frequencies of the sites in a SequenceSet given the base chars.\n\nSee the Sequence implementation of this function for details."},
    {"std::map< char, double > ::genesis::sequence::base_frequencies_accumulator (std::map< char, size_t > const & sitehistogram, std::string const & plain_chars)", "Local helper function that turns a site histogram into base frequencies."},
    {"std::string ::genesis::sequence::consensus_sequence_cavener (SiteCounts const & counts, bool allow_gaps=true)", "Calculate a consensus sequence using the method by Cavener for nucleic acid codes ACGT and their ambiguities.\n\nFor every site, the nucleotides are sorted by frequency. Then, the following checks are performed:\nA single nucleotide is used if its frequency is at least 50% and more than twice as high as the second most frequent nucleotide.If two nucleotides occur in at leat 75% of the sequences, and rule 1 does not apply, their ambiguity code is used (double-degenerate code).If none of the above applies, but one of the nucleotides has a count of zero, the (triple-degenerate) code of the other three nucleotides is used.In all other cases, the code 'N' is used.\nThe method is meant for finding a consensus sequence in sets of sequences without gaps. This implementation however also allows gaps, which are just treated as a normal character if allow_gaps is true (default). In this case, if any of rules 1-3 applies to a gap character, the result is simply reduced to a gap. That is, whenever a gap is used to form a degenerate code according to the rules, the whole code is reduced to a gap.If however allow_gaps is false, gap characters are completely ignored from the counting.The method was described in:D. R. Cavener, \"Comparison of the consensus sequence flanking translational start sites in\nDrosophila and vertebrates\", Nucleic Acids Res., vol. 15, no. 4, 1987.The method is also used by the Transfac Project:V. Matys et al., \"TRANSFAC: Transcriptional regulation, from patterns to profiles\", Nucleic Acids Res., vol. 31, no. 1, pp. 374378, 2003."},
    {"std::string ::genesis::sequence::consensus_sequence_cavener (SequenceSet const & sequences, bool allow_gaps=true)", "Calculate a consensus sequence using the method by Cavener for nucleic acid codes ACGT and their ambiguities.\n\nSee consensus_sequence_cavener(...) for details. This is merely a wrapper function that takes a SequenceSet instead of a SiteCounts object."},
    {"std::string ::genesis::sequence::consensus_sequence_template (SiteCounts const & counts, bool const allow_gaps, CharSelector const & char_selector)", "Local helper function template that handles the common code for the nucleic acid consensus sequence functions."},
    {"std::string ::genesis::sequence::consensus_sequence_with_ambiguities (SiteCounts const & counts, double similarity_factor=0.9, bool allow_gaps=true)", "Calculate a consensus sequence by using the most frequent characters at each site, for nucleic acid codes ACGT and their ambiguities.\n\nThe function calculates a consensus sequence for nucleic acid codes (ACGT), using their ambiguity codes (e.g., W for \"weak\" == AT) if the counts (i.e., character frequencies) are similar at a site. It uses similarity_factor to decide which counts are close enough to each other in order to be considered ambiguous.For example, with similarity_factor == 1.0, only exact matches are used, that is, if two counts are exactly the same. Let count('A') == 42 and count('T') == 42, and both other counts (C and G) be 0, this results in the code W at that site. If however count('T') == 41, only A is used for the site. Thus, with similarity_factor == 1.0, this function behaves very similar to consensus_sequence_with_majorities(), except in cases were two counts are exaclty the same.On the other hand, with similarity_factor == 0.0, all codes that are present at a site are considered to be ambiguous. That is, if a site contains counts > 0 for A, G and T, the resulting site gets the code D (\"not C\").For intermediate values, e.g., the default 0.9, the value is used as a threshold to decide the ambiguities. For example, let count('A') == 42 and count('T') == 38, and both other counts be 0. Then, the allowed deviation from the maximum 42 is 0.9 * 42 = 37.8. Thus, as the count for T is above this value, those two codes are considered ambiguous, resulting in a W at that site.The optional parameter allow_gaps (default is true) behaves similar to its counterpart in consensus_sequence_with_majorities(). If set to true, the count of the gap character is also considered. As the ambiguity for a gap combined with any other character is still a gap, sites where gap is the most frequent charater or is within the deviation get a gap as result.If allow_gaps is set to false instead, gaps are not considered. That means, the ambiguities are calculated as if there were no gaps. So even if a site contains mostly gaps, but only a few other characters, those will be used. Solely all-gap sites result in a gap at that site.Remark: As this function expects nucleic acid codes, the gap character is fixed to '-' here. The ambiguity codes are converted using nucleic_acid_ambiguity_code(). See there for more information on the used codes.If the provided SiteCounts object does not use nucleic acid codes, or if the similarity_factor is not within the range [ 0.0, 1.0 ], an exception is thrown."},
    {"std::string ::genesis::sequence::consensus_sequence_with_ambiguities (SequenceSet const & sequences, double similarity_factor=0.9, bool allow_gaps=true)", "Calculate a consensus sequence by using the most frequent characters at each site, for nucleic acid codes ACGT and their ambiguities.\n\nSee consensus_sequence_with_ambiguities(...) for details. This is merely a wrapper function that takes a SequenceSet instead of a SiteCounts object."},
    {"std::string ::genesis::sequence::consensus_sequence_with_majorities (SiteCounts const & counts, bool allow_gaps=true, char gap_char='-')", "Calculate the majority rule consensus sequence by using the most frequent character at each site.\n\nThe function creates a consensus sequence by using the character at each position that has the highest count (or frequency). It does not assume any character codes. Thus, it works for all kinds of sequence codes, e.g., nucleic acid or amino acid codes.The optional parameter allow_gaps (default is true) determines whether gaps in the consensus sequence are allowed. By default, if a site consists mostly of gaps, the consensus sequence also contains a gap at that site. If however this option is set to false, the consensus sequence will contain the most frequent non-gap character, even if there are more gaps at this site than the character itself. In other words, if the parameter is set to false, gaps are treated as missing characters instead of another type of character for computing the consensus. The only exception are gaps-only sites; in this case, the resulting sites contain a gap characters even if the parameter is set to false.The optional parameter gap_char (default value '-') is used for sites where no counts are available (i.e., are all zero), or, if allow_gaps is set to true, for sites that contain mostly gaps.Furthermore, if two or more characters have the same frequency, the first one is used. That is, the one that appears first in SiteCounts::characters().For an alternative version of this function that takes those ambiguities into account, see consensus_sequence_with_ambiguities(). Also, for a version of this function that takes a threshold for the character frequencies into account, see consensus_sequence_with_threshold(). However, both of them currently only work for nucleic acid codes (ACGT)."},
    {"std::string ::genesis::sequence::consensus_sequence_with_majorities (SequenceSet const & sequences, std::string const & characters, bool allow_gaps=true, char gap_char='-')", "Calculate the majority rule consensus sequence by using the most frequent character at each site.\n\nSee consensus_sequence_with_majorities(...) for details.This function is merely a wrapper that instead of a SiteCounts objects, takes a SequenceSet object and the set of characters to be used for counting character frequencies in the Sequences. That means, only the provided characters are counted and used for the consensus sequence. This is useful in order to get rid of errors and noise in the Sequences. For example, if you want to build a consensus sequence for a set of sequences with amino acid codes, use amino_acid_codes_plain() for set characters parameter."},
    {"std::string ::genesis::sequence::consensus_sequence_with_majorities (SequenceSet const & sequences, bool allow_gaps=true)", "Calculate the majority rule consensus sequence by using the most frequent character at each site for nucleic acid codes ACGT.\n\nSee consensus_sequence_with_majorities(...) for details.This function is merely a wrapper that instead of a SiteCounts objects, takes a SequenceSet object consisting of Sequences with nucleic acid codes ACGT and uses '-' for gaps."},
    {"std::string ::genesis::sequence::consensus_sequence_with_threshold (SiteCounts const & counts, double frequency_threshold=0.6, bool allow_gaps=true, bool use_ambiguities=true)", "Calculate a consensus sequence where the character frequency needs to be above a given threshold, for nucleic acid codes ACGT.\n\nThe function calculates a consensus sequence for nucleic acid codes (ACGT). It uses the frequency of characters at each site to determine the consensus. The frequency is relative to the total number of counts at that site, thus, it is a value in the range [ 0.0, 1.0 ].If the frequency of a character at a site is above the given frequency_threshold, it is used for the consensus. If not, the resulting character depends on use_ambiguities. If use_ambiguities is set to true (default), the sorted frequencies of the characters are added until the threshold is reached, and the ambiguity code for those characters is used. For example, let frequency_threshold == 0.9, count('A') == 42 and count('T') == 42, and both other counts (C and G) be 0. Then, neither A nor T have counts above the threshold, but combined they do, so the result is code W == AT at that site. If however use_ambiguities is false, the mask character X is used for sites that are below the threshold.Furthermore, if allow_gaps is set to true (default), gaps are counted when determining the threshold and checking whether the frequency is above it. That is, gaps are then treated as just another character at the site. For sites where the gap frequency is needed to reach the threshold, a gap is used as consensus. If allow_gaps is false, however, gaps are not counted for determining the frequency of the other characters. This is similar to the counterpart in consensus_sequence_with_majorities(). Solely sites that are gaps-only result in a gap char for the consensus then.For frequency_threshold < 0.5, it may happen that more than one character has a frequency above the threshold. In such cases, the most frequent character is used (or, if they have exaclty the same counts, they are used in the order ACGT). This is in line with the behaviour of consensus_sequence_with_majorities(). Usually, however, the threshold is above 0.5 anyway, as this gives more meaningful results. If you want to use ambiguity characters for low frequency characters, you can use consensus_sequence_with_ambiguities() instead.An extreme case is a frequency_threshold of 1.0. In this case, for sites which only have one character, this one is directly used in the consensus. Sites with multiple different characters result in the ambiguity code of all occuring characters at that site. Thus, the function then behaves similar to consensus_sequence_with_ambiguities() with a similarity_factor of 0.0.The other extrem case is a frequency_threshold of 0.0. In this case, the function simply uses the most frequent character per site, as it always fulfills the threshold. As said above, if then more than one character has exactly the same frequency, they are used in the order ACGT, thus the function then behaves similar to consensus_sequence_with_majorities().Remark: As this function expects nucleic acid codes, the gap character is fixed to '-' here, and the mask character to 'X'. The ambiguity codes are converted using nucleic_acid_ambiguity_code(). See there for more information on the used codes.If the provided SiteCounts object does not use nucleic acid codes, or if the frequency_threshold is not within the range [ 0.0, 1.0 ], an exception is thrown."},
    {"std::string ::genesis::sequence::consensus_sequence_with_threshold (SequenceSet const & sequences, double frequency_threshold=0.6, bool allow_gaps=true, bool use_ambiguities=true)", "Calculate a consensus sequence where the character frequency needs to be above a given threshold, for nucleic acid codes ACGT.\n\nSee consensus_sequence_with_ambiguities(...) for details. This is merely a wrapper function that takes a SequenceSet instead of a SiteCounts object."},
    {"size_t ::genesis::sequence::count_chars (SequenceSet const & set, std::string const & chars)", "Count the number of occurrences of the given chars within the sites of the SequenceSet.\n\nThis function can be used to count e.g. gaps or ambiguous characters in sequences. For presettings of usable chars, see the functions nucleic_acid_codes_... and amino_acid_codes_.... The chars are treated case-insensitive.If chars contains invalid (non-standard ASCII) characters, an std::invalid_argument exception is thrown."},
    {"bool ::genesis::sequence::CountPairComparator (CountPair const & lhs, CountPair const & rhs)", "Local helper function to sort a CountPair.\n\nThe comparatorfirst sorts by count, and for equal counts, sorts alphanumercially by the char. Thus, gaps are always first (their ascii code is smaller than all letters)."},
    {"void ::genesis::sequence::filter_by_label_list (SequenceSet & set, std::unordered_set< std::string > const & labels, bool invert=false)", "Remove all those Sequences from a SequenceSet whose labels are in the given list.\n\nIf invert is set to true, it does the same inverted: it removes all Sequences except those whose label is in the list."},
    {"void ::genesis::sequence::filter_max_sequence_length (SequenceSet & set, size_t max_length)", "Remove all Sequences from the SequenceSet whose length is above the given max_length.\n\nSee also filter_min_sequence_length() and filter_min_max_sequence_length()."},
    {"void ::genesis::sequence::filter_min_max_sequence_length (SequenceSet & set, size_t min_length, size_t max_length)", "Remove all Sequences from the SequenceSet whose length is not inbetween the min_length and max_length.\n\nThis function has the same effect as calling filter_min_sequence_length() and filter_max_sequence_length(), but does it in one iteration over the SequenceSet."},
    {"void ::genesis::sequence::filter_min_sequence_length (SequenceSet & set, size_t min_length)", "Remove all Sequences from the SequenceSet whose length is below the given min_length.\n\nSee also filter_max_sequence_length() and filter_min_max_sequence_length()."},
    {"Sequence const * ::genesis::sequence::find_sequence (SequenceSet const & set, std::string const & label)", "Return a pointer to a Sequence with a specific label, or nullptr iff not found."},
    {"utils::Bitvector ::genesis::sequence::find_sites (Sequence const & seq, std::string const & chars)", "Find sites by character and mark them in a Bitvector.\n\nThe function iterates the sites of a Sequence and checkes whether the char at a site is in the provided set of chars (case insensitive). If so, the resulting Bitvector is set to true at that position."},
    {"utils::Bitvector ::genesis::sequence::find_sites (Sequence const & seq, utils::CharLookup< bool > const & chars)", "Find sites by character and mark them in a Bitvector.\n\nThe function iterates the sites of a Sequence and checkes whether the char at a site is set to true in the provided lookup of chars. If so, the resulting Bitvector is set to true at that position."},
    {"utils::Bitvector ::genesis::sequence::gap_sites (Sequence const & seq, std::string const & gap_chars)", "Return a Bitvector that is true where the Sequence has a gap and false where not.\n\nThe gap_chars are used case-insensitively to determine what is considerted to be a gap. By default, nucleic_acid_codes_undetermined() are used, but any other set of characters is allowed."},
    {"utils::Bitvector ::genesis::sequence::gap_sites (SequenceSet const & set, std::string const & gap_chars)", "Return a Bitvector that is true where all Sequences in the SequenceSet have a gap and false where not, that is, where at least on Sequence is not a gap.\n\nThe gap_chars are used case-insensitively to determine what is considerted to be a gap. By default, nucleic_acid_codes_undetermined() are used, but any other set of characters is allowed."},
    {"double ::genesis::sequence::gapyness (SequenceSet const & set, std::string const & gap_chars)", "Return the \"gapyness\" of the Sequences, i.e., the proportion of gap chars and other completely undetermined chars to the total length of all sequences.\n\nThis function returns a value in the interval 0.0 (no gaps and undetermined chars at all) and 1.0 (all chars are undetermined). See nucleic_acid_codes_undetermined() and amino_acid_codes_undetermined() for presettings of gap character that can be used here depending on the data set type. The chars are treated case-insensitive. In the special case that there are no sequences or sites, 0.0 is returned."},
    {"std::pair< std::string, size_t > ::genesis::sequence::guess_sequence_abundance (Sequence const & sequence)", "Guess the abundance of a Sequence, using it's label.\n\nThe function splits the label of a Sequence into two parts: the descriptive name of the sequence, and an abundance value (weight or multiplicity of the sequence), which are returned as a std::pair.The function accepts two patterns of reporting abundances via the label() of a Sequence:\nAppended via underscore: name_123. In this case, the number has to be the last in the label, that is, no other text may follow.Using the format [;]size=123[;]. The semicoli are optional.\nIf neither of them is found, a default abundance of 1 is returned."},
    {"std::pair< std::string, size_t > ::genesis::sequence::guess_sequence_abundance (std::string const & label)", "Guess the abundance of a Sequence, given it's label.\n\nThis is the same as guess_sequence_abundance( Sequence const& ), but takes just the label instead of the Sequence object."},
    {"bool ::genesis::sequence::has_unique_labels (SequenceSet const & set, bool case_sensitive=true)", "Return true iff all labels of the Sequences in the SequenceSet are unique.\n\nThe optional parameter case_sensitive controls how labels are compared. Default is true, that is, Sequences are compared case-sensitively."},
    {"bool ::genesis::sequence::has_valid_label (Sequence const & seq)", "Check whether a Sequence has a valid label.\n\nThis might be important for printing the Sequence to a file that needs to be read by other applications. See is_valid_label() for details on what is considered a valid label. See sanitize_label() for a function that replaces all invalid characters of the label by underscores."},
    {"bool ::genesis::sequence::has_valid_labels (SequenceSet const & set)", "Check whether all Sequences in a SequenceSet have valid labels.\n\nThis might be important for printing the Sequences to a file that needs to be read by other applications. See is_valid_label() for details on what is considered a valid label. See sanitize_labels() for a function that replaces all invalid characters of the labels by underscores."},
    {"bool ::genesis::sequence::is_alignment (SequenceSet const & set)", "Return true iff all Sequences in the SequenceSet have the same length."},
    {"bool ::genesis::sequence::is_valid_label (std::string const & label)", "Check whether a given string is a valid label for a Sequence.\n\nWhile we can work with any form of label (as long as it is a string), most file formats and consequently most programs that read them restrict the set of valid characters for labels of sequences. We thus provide this function, which uses the most common interpretation of valid labels.A label is valid if its characters have a graphical representation (i.e., isgraph() is true) and if non of these characters occurs: :,();[]'\nThus, all whitespaces, control characters, and the listed special characters are invalid. See sanitize_label() for a function that replaces all invalid characters of the label by underscores."},
    {"std::string ::genesis::sequence::kmer_string_overlapping (Sequence const & sequence, SignatureSpecifications const & settings)", "Return the sequence spitted into overlapping k-mers.\n\nThe function takes the sequence and splits it into k-mers according to settings, using a space char as delimiter between k-mers, with overlap.For example, the sequence ACGTACGT with k == 3 becomes ACG CGT GTA TAC ACG CGT\nThe naming of the function followsD. Kimothi, A. Soni, P. Biyani, and J. M. Hogan, Distributed Representations for Biological Sequence Analysis, CoRR, vol. abs/1608.0, 2016.See there for details."},
    {"void ::genesis::sequence::kmer_string_overlapping (Sequence const & sequence, SignatureSpecifications const & settings, std::ostream & out)", "Print the sequence spitted into overlapping k-mers.\n\nThis is identical to kmer_string_overlapping( Sequence const&, SignatureSpecifications const& ), but prints directly to a stream, which is better for processing large files. After the k-mer sequence, a new line character is printed."},
    {"void ::genesis::sequence::kmer_string_overlapping_line (Sequence const & sequence, SignatureSpecifications const & settings, std::ostream & out)", "Local helper function that writes an overlapping kmer string to a stream."},
    {"void ::genesis::sequence::kmer_string_single_kmer (Sequence const & sequence, SignatureSpecifications const & settings, size_t start, std::ostream & out)", "Local helper function that writes one kmer string to a stream."},
    {"std::vector< std::string > ::genesis::sequence::kmer_strings_non_overlapping (Sequence const & sequence, SignatureSpecifications const & settings)", "Return the sequence spitted into a set of non-overlapping k-mers.\n\nThe function takes the sequence and splits it into k-mers according to settings, using a space char as delimiter between k-mers, without overlap.For example, the sequence ACGTACGTACGT with k == 3 becomes ACG TAC GTA CGT\nCGT ACG TAC\nGTA CGT ACG\nThe naming of the function followsD. Kimothi, A. Soni, P. Biyani, and J. M. Hogan, Distributed Representations for Biological Sequence Analysis, CoRR, vol. abs/1608.0, 2016.See there for details."},
    {"void ::genesis::sequence::kmer_strings_non_overlapping (Sequence const & sequence, SignatureSpecifications const & settings, std::ostream & out)", "Print the sequence spitted into non-overlapping k-mers.\n\nThis is identical to kmer_strings_non_overlapping( Sequence const&, SignatureSpecifications const& ), but prints directly to a stream, which is better for processing large files. After each k-mer sequence, a new line character is printed."},
    {"void ::genesis::sequence::kmer_strings_non_overlapping_line (Sequence const & sequence, SignatureSpecifications const & settings, std::ostream & out, size_t offset)", "Local helper function that does one line of a non overlapping kmer string."},
    {"std::unordered_set< std::string > ::genesis::sequence::labels (SequenceSet const & set)", "Return a set of all labels of the SequenceSet."},
    {"size_t ::genesis::sequence::longest_sequence_length (SequenceSet const & set)", "Return the length of the longest Sequence in the SequenceSet."},
    {"void ::genesis::sequence::merge_duplicate_sequences (SequenceSet & set, MergeDuplicateSequencesCountPolicy count_policy, std::string const & counter_prefix=\"_\")", "Merge all Sequences in a SequenceSet that have identical sites.\n\nThe merging is done by removing all but the first Sequence with identical sites. That means, the resulting \"representative\" of a set of merged Sequences has the label of the original Sequence that was first in the SequenceSet.Using the MergeDuplicateSequencesCountPolicy, it is possible to store the counts of the Sequences (i.e., how often they appeard before merging) within the label of the Sequence, separated by counter_prefix. With the default settings, the count is appended to the label, separated by an underscore."},
    {"char ::genesis::sequence::normalize_amino_acid_code (char code, bool accept_degenerated=true)", "Normalize an amino acid code.\n\nThat is, make it upper case and replace all undetermined chars by -. See amino_acid_codes_undetermined() for a list of the latter.If accept_degenerated is set to true (default), degenerated chars are just put to upper case, but otherwise left as they are. If set to false, an exception is thrown if a degenerated char is encountered. See amino_acid_codes_degenerated() for their list.Lastly, an exception is also thrown for non amino acid codes, that is all chars that are not part of amino_acid_codes_all()."},
    {"void ::genesis::sequence::normalize_amino_acid_codes (Sequence & sequence, bool accept_degenerated=true)", "Call normalize_amino_acid_code() for each site of the Sequence.\n\nSee there for details."},
    {"void ::genesis::sequence::normalize_amino_acid_codes (SequenceSet & sequence_set, bool accept_degenerated=true)", "Call normalize_amino_acid_code() for each site of all Sequences in the SequenceSet.\n\nSee there for details."},
    {"std::string ::genesis::sequence::normalize_code_alphabet (std::string const & alphabet)", "Normalize an alphabet set of Sequence codes, i.e., make them upper case, sort them, and remove duplicates.\n\nFor example, when given a set of nucleic acid codes like \"aGtc\", the function returns \"ACGT\". This is useful to get consistent codes in functions that accept a user defined code alphabet."},
    {"char ::genesis::sequence::normalize_nucleic_acid_code (char code, bool accept_degenerated=true)", "Normalize a nucleic acide code.\n\nThat is, make it upper case, replace U by T, replace all undetermined chars by -. See nucleic_acid_codes_undetermined() for a list of the latter.If accept_degenerated is set to true (default), degenerated chars are just put to upper case, but otherwise left as they are. If set to false, an exception is thrown if a degenerated char is encountered. See nucleic_acid_codes_degenerated() for their list.Lastly, an exception is also thrown for non nucleic acid codes, that is all chars that are not part of nucleic_acid_codes_all()."},
    {"void ::genesis::sequence::normalize_nucleic_acid_codes (Sequence & sequence, bool accept_degenerated=true)", "Call normalize_nucleic_acid_code() for each site of the Sequence.\n\nSee there for details."},
    {"void ::genesis::sequence::normalize_nucleic_acid_codes (SequenceSet & sequence_set, bool accept_degenerated=true)", "Call normalize_nucleic_acid_code() for each site of all Sequences in the SequenceSet.\n\nSee there for details."},
    {"std::string ::genesis::sequence::nucleic_acid_ambiguities (char code)", "Return the possible ambiguous nucleic acid codes for a given code char.\n\nThe codes are resolved as follows: 'A' ==> \"A\"\n'C' ==> \"C\"\n'G' ==> \"G\"\n'T' ==> \"T\"\n'U' ==> \"T\"\n\n'W' ==> \"AT\"\n'S' ==> \"CG\"\n'M' ==> \"AC\"\n'K' ==> \"GT\"\n'R' ==> \"AG\"\n'Y' ==> \"CT\"\n\n'B' ==> \"CGT\"\n'D' ==> \"AGT\"\n'H' ==> \"ACT\"\n'V' ==> \"ACG\"\n\n'N' ==> \"ACGT\"\n'O' ==> \"-\"\n'X' ==> \"-\"\n'.' ==> \"-\"\n'-' ==> \"-\"\n'?' ==> \"-\"\nThe code char is treated case-insensitive. If the given code char is not valid, an std::out_of_range exception is thrown.See nucleic_acid_ambiguity_code() for a reverse version of this function. It is however not exactly the reverse, as some degenerated codes are mapped to the gap char. Thus, this function is not injective."},
    {"char ::genesis::sequence::nucleic_acid_ambiguity_code (std::string codes)", "Return the nucleic acid code that represents all given codes.\n\nThe codes are resolved as follows: \"A\"    ==> 'A'\n\"C\"    ==> 'C'\n\"G\"    ==> 'G'\n\"T\"    ==> 'T'\n\n\"AT\"   ==> 'W'\n\"CG\"   ==> 'S'\n\"AC\"   ==> 'M'\n\"GT\"   ==> 'K'\n\"AG\"   ==> 'R'\n\"CT\"   ==> 'Y'\n\n\"CGT\"  ==> 'B'\n\"AGT\"  ==> 'D'\n\"ACT\"  ==> 'H'\n\"ACG\"  ==> 'V'\n\n\"ACGT\" ==> 'N'\n\"-\"    ==> '-'\nThe given codes are treated case-insensitive and order-independent. For example, given \"tCgG\", the function still returns 'B'. However, if any of the given codes is not valid, an std::out_of_range exception is thrown.See nucleic_acid_ambiguities() for the reverse of this function."},
    {"std::string ::genesis::sequence::nucleic_acid_codes_all ()", "Return all valid nucleic acid codes. Those are \"ACGTUWSMKRYBDHVNOX.-?\"."},
    {"std::string ::genesis::sequence::nucleic_acid_codes_degenerated ()", "Return all degenerated nucleic acid codes. Those are \"WSMKRYBDHV\"."},
    {"std::string ::genesis::sequence::nucleic_acid_codes_plain ()", "Return all plain nucleic acid codes. Those are \"ACGTU\"."},
    {"std::string ::genesis::sequence::nucleic_acid_codes_undetermined ()", "Return all undetermined nucleic acid codes. Those are \"NOX.-?\"."},
    {"std::map< char, utils::Color > ::genesis::sequence::nucleic_acid_colors ()", "Return a map of Colors for each nucleic acid code.\n\nThis function gives a Color for each nucleic acid code."},
    {"std::string ::genesis::sequence::nucleic_acid_name (char code)", "Get the name of a nucleic acid given its IUPAC code.\n\nThe codes are translated as follows: A Adenine\nC Cytosine\nG Guanine\nT Thymine\nU Uracil\nW Weak\nS Strong\nM aMino\nK Keto\nR puRine\nY pYrimidine\nB not A\nD not C\nH not G\nV not T\nN any\nO omitted\nX masked\n. gap\n- gap\n? gap\nThe code char is treated case-insensitive. If the given code char is not valid, an std::out_of_range exception is thrown."},
    {"std::map< char, std::string > ::genesis::sequence::nucleic_acid_text_colors ()", "Return a map of text colors for each nucleic acid code.\n\nThis function gives a color name usable for utils::Style for each nucleic acid code. The return value of this function can for example be used in sequence::print_color() function."},
    {"bool ::genesis::sequence::operator& (SiteEntropyOptions lhs, SiteEntropyOptions rhs)", "And-operator to check whether a SiteEntropyOptions is set.\n\nTypical usage: SiteEntropyOptions options;\nif( options & SiteEntropyOptions::kWeighted ) {\n    // Do stuff...\n}\nUse the or-operator in order to set and combine options."},
    {"SiteEntropyOptions ::genesis::sequence::operator| (SiteEntropyOptions lhs, SiteEntropyOptions rhs)", "Or-operator to combine two SiteEntropyOptionss.\n\nTypical usage: auto options = SiteEntropyOptions::kWeighted | SiteEntropyOptions::kNormalized;\nUse the and-operator in order to check whether an option is set."},
    {"SiteEntropyOptions & ::genesis::sequence::operator|= (SiteEntropyOptions & lhs, SiteEntropyOptions rhs)", "Or-assignment-operator to combine two SiteEntropyOptionss.\n\nTypical usage: SiteEntropyOptions options;\noptions |= SiteEntropyOptions::kWeighted;\nUse the and-operator in order to check whether an option is set."},
    {"void ::genesis::sequence::relabel_with_hash (Sequence & seq, utils::HashingFunctions hash_function)", "Relabel the Sequence using the hash digest of its sites.\n\nSee utils::HashingFunctions for the available hashing functions."},
    {"void ::genesis::sequence::relabel_with_hash (SequenceSet & set, utils::HashingFunctions hash_function)", "Relabel all Sequences in the SequenceSet using the hash digest of the sites.\n\nSee utils::HashingFunctions for the available hashing functions.If there are duplicate Sequences, this function will lead to multiple Sequences with the same name, which might be an issue for downstream programs that expect unique labels. See has_unique_labels() to check this."},
    {"void ::genesis::sequence::remove_all_gaps (Sequence & seq, std::string const & gap_chars)", "Remove all gap characters from the sites of the Sequence.\n\nThis function is an alias for remove_characters(), which by default uses the gap sites of nucleic_acid_codes_undetermined()."},
    {"void ::genesis::sequence::remove_all_gaps (SequenceSet & set, std::string const & gap_chars)", "Remove all gap characters from the sites of the Sequences in the SequenceSet.\n\nThis function is an alias for remove_characters(), which by default uses the gap sites of nucleic_acid_codes_undetermined()."},
    {"void ::genesis::sequence::remove_characters (Sequence & seq, std::string const & search)", "Remove all of the characters in search from the sites of the Sequence."},
    {"void ::genesis::sequence::remove_characters (SequenceSet & set, std::string const & search)", "Remove all of the characters in search from the sites of the Sequences in the SequenceSet."},
    {"void ::genesis::sequence::remove_gap_sites (SequenceSet & set, std::string const & gap_chars)", "Remove all sites that only contain gap characters from the SequenceSet."},
    {"void ::genesis::sequence::remove_sites (Sequence & seq, utils::Bitvector sites)", "Remove all sites from a Sequence where the given Bitvector is true, and keep all others.\n\nThe Bitvector needs to have the same size as the Sequence, otherwise an expection is thrown.This function is for example useful in combination with gap_sites()."},
    {"void ::genesis::sequence::remove_sites (SequenceSet & set, utils::Bitvector sites)", "Remove all sites from all Sequences in a SequenceSet where the given Bitvector is true, and keep all others.\n\nThe Bitvector and all Sequences need to have the same size, otherwise an expection is thrown. This check is done before any Sequence is changed. Thus, if the function throws for this reason, the Sequences are left unchanged.This function is for example useful in combination with gap_sites()."},
    {"void ::genesis::sequence::replace_characters (Sequence & seq, std::string const & search, char replacement)", "Replace all occurences of the chars in search by the replace char, for all sites in the given Sequence.\n\nThe function is case sensitive. Thus, you need to use both cases for the search string if you are unsure. The replace char is always used as is, independent of the case of the matching search char."},
    {"void ::genesis::sequence::replace_characters (SequenceSet & set, std::string const & search, char replacement)", "Replace all occurences of the chars in search by the replace char, for all sites in the Sequences in the given SequenceSet.\n\nThe function is case sensitive. Thus, you need to use both cases for the search string if you are unsure. The replace char is always used as is, independent of the case of the matching search char."},
    {"void ::genesis::sequence::replace_t_with_u (Sequence & seq)", "Replace all occurrences of T by U in the sites of the Sequence.\n\nThis is a small helper function for sequences with nucleic acid codes. It is case sensitive, that is, lower case t is replaced by lower case u, and upper case T by upper case U."},
    {"void ::genesis::sequence::replace_t_with_u (SequenceSet & set)", "Replace all occurrences of T by U in the sites of all Sequences in the SequenceSet.\n\nThis is a small helper function for sequences with nucleic acid codes. It is case sensitive, that is, lower case t is replaced by lower case u, and upper case T by upper case U."},
    {"void ::genesis::sequence::replace_u_with_t (Sequence & seq)", "Replace all occurrences of U by T in the sites of the Sequence.\n\nThis is a small helper function for sequences with nucleic acid codes. It is case sensitive, that is, lower case u is replaced by lower case t, and upper case U by upper case T."},
    {"void ::genesis::sequence::replace_u_with_t (SequenceSet & set)", "Replace all occurrences of U by T in the sites of all Sequences in the SequenceSet.\n\nThis is a small helper function for sequences with nucleic acid codes. It is case sensitive, that is, lower case u is replaced by lower case t, and upper case U by upper case T."},
    {"std::string ::genesis::sequence::reverse_complement (std::string const & sequence, bool accept_degenerated=true)", "Get the reverse complement of a nucleic acid sequence.\n\nThat is, reverse the string and flip A with T and C with G. Gap characters are normalized to -, and an exception is thrown for invalid characters.If furthermore accept_degenerated is true (default), degenerated codes are also flipped. For example M == AC becomes K == TG, W == AT stays the same, and B == CGT becomes V = GCA. If set to false, an exception is thrown when degenerated chars are found."},
    {"std::string ::genesis::sequence::sanitize_label (std::string const & label)", "Sanitize a label by replacing all invalid characters with underscores.\n\nThis might be important for printing the Sequences to a file that needs to be read by other applications. See is_valid_label() for details on what is considered a valid label."},
    {"void ::genesis::sequence::sanitize_label (Sequence & seq)", "Sanitize a label by replacing all invalid characters with underscores.\n\nThis might be important for printing the Sequences to a file that needs to be read by other applications. See is_valid_label() for details on what is considered a valid label."},
    {"void ::genesis::sequence::sanitize_labels (SequenceSet & set)", "Sanitize the labels of all Sequences in the SequenceSet by replacing all invalid characters with underscores.\n\nThis might be important for printing the Sequences to a file that needs to be read by other applications. See is_valid_label() for details on what is considered a valid label."},
    {"std::vector< double > ::genesis::sequence::signature_complementarity_frequencies_helper (Sequence const & sequence, SignatureSpecifications const & settings, Combinator combinator)", "Local helper function that returns a vector where the frequencies of the non-palindromic kmers are combined using a functor."},
    {"std::vector< size_t > ::genesis::sequence::signature_counts (Sequence const & sequence, SignatureSpecifications const & settings)", "Count the occurences of k-mers in the sequence according to the settings.\n\nThe function returns a vector that contains the count for each k-mer that can be build from the characters in the alphabet, in the order given by SignatureSpecifications::kmer_list()."},
    {"std::vector< double > ::genesis::sequence::signature_frequencies (Sequence const & sequence, SignatureSpecifications const & settings)", "Calculate the frequencies of occurences of k-mers in the sequence according to the settings.\n\nThe function simply calculates the frequencies as the normalized values of signature_counts()."},
    {"std::vector< double > ::genesis::sequence::signature_frequency_ratios_1 (Sequence const & sequence, SignatureSpecifications const & settings)", "Calculate the ratio 1 signature of a sequence.\n\nThe function is calculated according toF. Gori, D. Mavroedis, M. S. M. Jetten, and E. Marchiori, Genomic signatures for metagenomic data analysis: Exploiting the reverse complementarity of tetranucleotides, 2011 IEEE Int. Conf. Syst. Biol. ISB 2011, pp. 149154, 2011.It excludes palindromic k-mers where the reverse complement is the k-mer itself."},
    {"std::vector< double > ::genesis::sequence::signature_frequency_ratios_2 (Sequence const & sequence, SignatureSpecifications const & settings)", "Calculate the ratio 2 signature of a sequence.\n\nThe function is calculated according toF. Gori, D. Mavroedis, M. S. M. Jetten, and E. Marchiori, Genomic signatures for metagenomic data analysis: Exploiting the reverse complementarity of tetranucleotides, 2011 IEEE Int. Conf. Syst. Biol. ISB 2011, pp. 149154, 2011.It excludes palindromic k-mers where the reverse complement is the k-mer itself."},
    {"std::vector< double > ::genesis::sequence::signature_jensen_shannon (Sequence const & sequence, SignatureSpecifications const & settings)", "Calculate the Jensen-Shannon (JS) signature of a sequence.\n\nThe function is calculated according toF. Gori, D. Mavroedis, M. S. M. Jetten, and E. Marchiori, Genomic signatures for metagenomic data analysis: Exploiting the reverse complementarity of tetranucleotides, 2011 IEEE Int. Conf. Syst. Biol. ISB 2011, pp. 149154, 2011.using details ofJ. Lin, Divergence Measures Based on the Shannon Entropy, IEEE Trans. Inf. Theory, vol. 37, no. 1, pp. 145151, 1991.It excludes palindromic k-mers where the reverse complement is the k-mer itself."},
    {"std::vector< double > ::genesis::sequence::signature_maximal_complementarity_frequencies (Sequence const & sequence, SignatureSpecifications const & settings)", "Calculate the signature of a sequence that uses the maximum frequency of reverse complement k-mers.\n\nThe function is calculated according toF. Gori, D. Mavroedis, M. S. M. Jetten, and E. Marchiori, Genomic signatures for metagenomic data analysis: Exploiting the reverse complementarity of tetranucleotides, 2011 IEEE Int. Conf. Syst. Biol. ISB 2011, pp. 149154, 2011.It excludes palindromic k-mers where the reverse complement is the k-mer itself."},
    {"std::vector< double > ::genesis::sequence::signature_minimal_complementarity_frequencies (Sequence const & sequence, SignatureSpecifications const & settings)", "Calculate the signature of a sequence that uses the minimum frequency of reverse complement k-mers.\n\nThe function is calculated according toF. Gori, D. Mavroedis, M. S. M. Jetten, and E. Marchiori, Genomic signatures for metagenomic data analysis: Exploiting the reverse complementarity of tetranucleotides, 2011 IEEE Int. Conf. Syst. Biol. ISB 2011, pp. 149154, 2011.It excludes palindromic k-mers where the reverse complement is the k-mer itself."},
    {"std::vector< size_t > ::genesis::sequence::signature_ranks (Sequence const & sequence, SignatureSpecifications const & settings)", "Calcuate the rank signature of a sequence according to the settings.\n\nThat is, standard ranking is applied to the k-mer counts of the Sequence."},
    {"std::vector< double > ::genesis::sequence::signature_reverse_identity_frequencies (Sequence const & sequence, SignatureSpecifications const & settings)", "Calculate the signature of a sequence that uses only the frequencies of k-mers whose reverse complement is the k-mer itself.\n\nThe function is calculated according toF. Gori, D. Mavroedis, M. S. M. Jetten, and E. Marchiori, Genomic signatures for metagenomic data analysis: Exploiting the reverse complementarity of tetranucleotides, 2011 IEEE Int. Conf. Syst. Biol. ISB 2011, pp. 149154, 2011.It excludes k-mers where the reverse complement is a different k-mer."},
    {"std::vector< size_t > ::genesis::sequence::signature_symmetrized_counts (Sequence const & sequence, SignatureSpecifications const & settings)", "Calcuate the symmetrized counts of the sequence according to the settings.\n\nThe function uses signature_counts(), and sums up the counts of k-mers that are reverse complements of each other."},
    {"std::vector< double > ::genesis::sequence::signature_symmetrized_frequencies (Sequence const & sequence, SignatureSpecifications const & settings)", "Calcuate the symmetrized counts of the sequence according to the settings.\n\nThe function uses signature_frequencies(), and sums up the counts of k-mers that are reverse complements of each other."},
    {"std::vector< T > ::genesis::sequence::signature_symmetrized_helper (std::vector< T > const & kmers, SignatureSpecifications const & settings)", "Local helper function that adds up the values for reverse complement k-mers."},
    {"std::vector< size_t > ::genesis::sequence::signature_symmetrized_ranks (Sequence const & sequence, SignatureSpecifications const & settings)", "Calcuate the symmetrized rank signature of a sequence according to the settings.\n\nThat is, standard ranking is applied to the symmetrized (combined reverse complement) k-mer counts of the Sequence."},
    {"double ::genesis::sequence::site_entropy (SiteCounts const & counts, size_t site_index, SiteEntropyOptions options)", "Calculate the entropy at one site of a SiteCounts object.\n\nThe entropy $ H $ (uncertainty) at site $ i $ (= site_idx) is calculated as $ H_{i}=-\\sum f_{{c,i}}\\times \\log _{2}f_{{c,i}} $, where $ f_{c,i} $ is the relative frequency of character $ c $ at site $ i $, summed over all characters in the SiteCounts object.The function additionally takes optional flags to refine the calculation, see SiteEntropyOptions for their explanation."},
    {"std::map< char, size_t > ::genesis::sequence::site_histogram (Sequence const & seq)", "Get a histogram of the occurrences of particular sites, given a Sequence.\n\nThis gives the raw counts of how often each site (character) appears in the Sequence. See base_frequencies() for the relative version of this function."},
    {"std::map< char, size_t > ::genesis::sequence::site_histogram (SequenceSet const & set)", "Get a histogram of the occurrences of particular sites, given a SequenceSet.\n\nThis gives the raw counts of how often each site (character) appears in the whole set. See base_frequencies() for the relative version of this function."},
    {"double ::genesis::sequence::site_information (SiteCounts const & counts, size_t site_index, bool use_small_sample_correction=false, SiteEntropyOptions options)", "Calculate the information content at one site of a SiteCounts object.\n\nThe information content $ R $ at site $ i $ (= site_index) is calculated as $ R_{i} = \\log_{2}( s ) - (H_{i}+e_{n}) $.Here, $ s $ is the number of possible characters in the sequences (usually, 4 for nucleic acids and 20 for amino acids), which is taken from the characters() used in the SiteCounts object. Furthermore, $ H_{i} $ is the site_entropy() at the given site.The optional term $ e_{n} $ is the small-sample correction, calculated as $ e_{n}={\\frac{1}{\\ln {2}}}\\times {\\frac{s-1}{2n}} $, with $ n $ being the number of sequences. It is only used if use_small_sample_correction is set to true (default is false).The function additionally takes optional flags to refine the site entropy calculation, see SiteEntropyOptions for their explanation."},
    {"size_t ::genesis::sequence::total_length (SequenceSet const & set)", "Return the total length (sum) of all Sequences in the SequenceSet."},
    {"bool ::genesis::sequence::validate_chars (SequenceSet const & set, std::string const & chars)", "Returns true iff all Sequences only consist of the given chars.\n\nFor presettings of usable chars, see the functions nucleic_acid_codes_... and amino_acid_codes_.... For example, to check whether the sequences are nucleic acids, use nucleic_acid_codes_all(). The chars are treated case-insensitive.If chars contains invalid (non-standard ASCII) characters, an std::invalid_argument exception is thrown."},
    {"std::vector< size_t > ::genesis::placement::epca_filter_constant_columns (utils::Matrix< double > & imbalance_matrix, double epsilon=1e-5)", "Filter out columns that have nearly constant values, measured using an epsilon.\n\nThe Matrix is modified so that all columns c with max(c) - min(c) <= epsilon are removed.The function returns a sorted list of all column indices of the original matrix that are kept, i.e., that have a greater min-max difference than epsilon. This is useful for e.g., visualising the result of an Edge PCA.\n\nimbalance_matrix\n\n\nMatrix to filter inplace. \n\n\n\nepsilon\n\n\nMaximum deviation for what is considered constant. \n\n\nList of original column indices that are kept (not filtered)."},
    {"utils::Matrix< double > ::genesis::placement::epca_imbalance_matrix (SampleSet const & samples, bool include_leaves=false, bool normalize=true)", "Calculate the imbalance matrix of placment mass for all Samples in a SampleSet.\n\nThe first step to perform Edge PCA is to make a Matrix with rows indexed by the Samples, and columns by the Edges of the Tree. Each entry of this matrix is the difference between the distribution of mass on either side of an edge for a Sample. Specifically, it is the amount of mass on the distal (non-root) side of the edge minus the amount of mass on the proximal side.The matrix is row-indexed according to the Samples in the SampleSet.If include_leaves is set to false (default), the columns for edges belonging to leaves of the tree are left out. Their value is -1.0 anyway, as there is no mass on the distal side of those edges. Hence, they are constant for all Samples and have no effect on the Edge PCA result. In this case, the matrix is column-indexed so that each inner edge of the Tree has one column in the Matrix. See epca_imbalance_vector() for more details.If include_leaves is set to true, the constant values for leaf edges are also included. In this case, the matrix is column-indexed according to the edge indices of the Tree. This is for example useful if the indexing is needed later. The columns can then also be filtered out using epca_filter_constant_columns().Lastly normalize is used as in epca_imbalance_vector(). See there for details."},
    {"void ::genesis::placement::filter_min_weight_threshold (Pquery & pquery, double threshold)", "Remove all PqueryPlacements that have a like_weight_ratio below the given threshold."},
    {"std::vector< double > ::genesis::placement::epca_imbalance_vector (Sample const & sample, bool normalize=true)", "Calculate the imbalance of placement mass for each Edge of the given Sample.\n\nThe entries of the vector are the difference between the distribution of mass on either side of the edge for the given Sample. Specifically, it is the amount of mass on the distal (non-root) side of the edge minus the amount of mass on the proximal (root) side.If normalize is true (default), the imbalance values are normalized by the total amount of mass on the tree (expect for the mass of the respective edge, as this one also does not count for its own imbalance).The vector is indexed using the index() of the edges. This is different from how how guppy indexes the edges, namely by using their edge_nums. See https://matsen.github.io/pplacer/generated_rst/guppy_splitify.html for details on the guppy edge imbalance matrix. We chose to use our internal edge index instead, as it is consistent and needs no checking for correctly labeled edge nums.epca_imbalance_matrix() for the Matrix of imbalances for a whole SampleSet."},
    {"void ::genesis::placement::epca_splitify_transform (utils::Matrix< double > & imbalance_matrix, double kappa=1.0)", "Perform a component-wise transformation of the imbalance matrix used for epca().\n\nAll entries of the Matrix are transformed inplace, using\\[ \\varphi_\\kappa(x) = \\mathrm{sgn}(x) \\cdot |x|^\\kappa \\]where the kappa ( $\\kappa$) parameter can be any non-negative number. This parameter scales between ignoring abundance information (kappa = 0), using it linearly (kappa = 1), and emphasizing it (kappa > 1).\n\nimbalance_matrix\n\n\nMatrix to transform inplace. \n\n\n\nkappa\n\n\nScaling value for abundance information. Has to be >= 0."},
    {"void ::genesis::placement::filter_min_accumulated_weight (Pquery & pquery, double threshold=0.99)", "Remove the PqueryPlacements with the lowest like_weight_ratio, while keeping the accumulated weight (sum of all remaining like_weight_ratios) above a given threshold.\n\nThis is a cleaning function to get rid of unlikely placement positions, withouth sacrificing too much detail of the overall distribution of weights. The EPA support a similar option, which only writes enough of the most likely placement positions to the output to fullfil a threshold."},
    {"void ::genesis::placement::filter_min_accumulated_weight (Sample & smp, double threshold=0.99)", "Remove the PqueryPlacements with the lowest like_weight_ratio, while keeping the accumulated weight (sum of all remaining like_weight_ratios) above a given threshold.\n\nThis function calls filter_min_accumulated_weight( Pquery& pquery, double threshold ) for all Pqueries of the Sample. See this version of the function for more information."},
    {"void ::genesis::placement::fill_node_distance_histogram_set (Sample const & sample, utils::Matrix< double > const & node_distances, utils::Matrix< signed char > const & node_sides, NodeDistanceHistogramSet & histogram_set)", "Fill the placements of a Sample into Histograms."},
    {"bool ::genesis::placement::validate (Sample const & smp, bool check_values=false, bool break_on_values=false)", "Validate the integrity of the pointers, references and data in a Sample object.\n\nReturns true iff everything is set up correctly. In case of inconsistencies, the function stops and returns false on the first encountered error.If check_values is set to true, also a check on the validity of numerical values is done, for example that the proximal_length is smaller than the corresponding branch_length. If additionally break_on_values is set, validate() will stop on the first encountered invalid value. Otherwise it will report all invalid values to the log stream."},
    {"void ::genesis::placement::filter_pqueries_removing_names (Sample & smp, std::unordered_set< std::string > remove_list)", "Remove all Pqueries which have at least one name that is in the given remove list.\n\nIf the Pquery has a PqueryName whose PqueryName::name value is in the remove_list, the Pquery is removed. If none of its names is in the remove_list, the Pquery is kept.This is similar to filter_pqueries_keeping_names(), but not quite the opposite, as Pqueries can have multiple names."},
    {"Pquery const * ::genesis::placement::find_pquery (Sample const & smp, std::string const & name)", "Return the first Pquery that has a particular name, or nullptr of none has."},
    {"Pquery * ::genesis::placement::find_pquery (Sample & smp, std::string const & name)", "Return the first Pquery that has a particular name, or nullptr of none has."},
    {"void ::genesis::placement::filter_pqueries_removing_names (Sample & smp, std::string const & regex)", "Remove all Pqueries which have at least one name that matches the given regex.\n\nIf the Pquery has a PqueryName whose PqueryName::name value matches the reges, the Pquery is removed. If none of its names matches, the Pquery is kept."},
    {"Sample * ::genesis::placement::find_sample (SampleSet & sample_set, std::string const & name)", "Get the first Sample in a SampleSet that has a given name, or nullptr if not found."},
    {"Sample const * ::genesis::placement::find_sample (SampleSet const & sample_set, std::string const & name)", "Get the first Sample in a SampleSet that has a given name, or nullptr if not found."},
    {"bool ::genesis::placement::has_consecutive_edge_nums (PlacementTree const & tree)", "Verify that the PlacementTree has no duplicate edge_nums and that they form consecutive numbers starting from 0.\n\nThis function is very similar to has_correct_edge_nums(). However, instead of checking whether the edge_nums are correctly assigned following a postorder traversal of the tree, as demanded by the Jplace standard, this function simply checks whehter they are all unique, start at 0 and continue consecutively without gaps.This is imporant for using the edge_nums as indices, for example.We offer this function, because Genesis can work with improperly assigned edge_nums, but for some functions we need to ensure those properties. Generally, you should however prefer correct edge_nums according to the standard, and use has_correct_edge_nums() to verify them."},
    {"bool ::genesis::placement::has_correct_edge_nums (PlacementTree const & tree)", "Verify that the tree has correctly set edge nums.\n\nThe edge_num property of the PlacementTreeEdges is defined by the jplace standard. The values have to be assigned increasingly with a postorder traversal of the tree. This function checks whether this is the case.See also has_consecutive_edge_nums() for a relaxed version of this function, which might also be useful in some cases where the strict correct order according to the standard is not needed."},
    {"bool ::genesis::placement::has_name (Pquery const & pquery, std::string const & name)", "Return true iff the given Pquery contains a particular name."},
    {"bool ::genesis::placement::has_name (Sample const & smp, std::string const & name)", "Return true iff the given Sample contains a Pquery with a particular name, i.e., a PqueryName whose name member equals the given name."},
    {"double ::genesis::placement::pquery_distance (PqueryPlain const & pquery_a, PqueryPlain const & pquery_b, utils::Matrix< double > const & node_distances, bool with_pendant_length=false)", "Calculate the weighted distance between two plain pqueries. It is mainly a helper method for distance calculations (e.g., pairwise distance, variance).\n\nFor each placement in the two pqueries, a distance is calculated, and their weighted sum is returned. Weighing is done using the mass of placements in both pqueries.The distance between two placements is calculated as the shortest path between them. This includes the their position on the branches, and - if specified - the pendant_length of both. There are three cases that might occur:\nBoth placements are on the same branch. In this case, their distance is caluclated as their difference in proximal_lengths (plus the sum of their pendant_lengths, if specified).The path between the placements includes the root. The distance of a placement from its neighbouring nodes is usually given in form of the proximal_length, which is the distance of the placement to the node (at the end of its branch) that lies in direction of the root. Thus, there is an implicit notion of a root, that we need to consider. If the path between two placements contains the root, we can directly calculate their distance as the distance between the two promixal nodes plus proximal_lengths (and possibly pendant_lengths) of both placements. We call this the promixal-promixal case.The root is not part of the path between the placements. This case means that one of the two placements lies on the path between the other placement and the root  thus, the path between the placements does not contain the root. The distance between the placements cannot be calculated using the proximal_lengths directly, but we need to get the distal_length (away from the root) of the inner placement first. This is simply the difference between branch_length and proximal_length of that placement. Of course, this case comes in two flavours, because both placements can be the inner or outer one. They are called proximal-distal case and distal-proximal case, respectively.\nThe first case is easy to detect by comparing the edge nums. However, distinguishing between the latter two cases is expensive, as it involves finding the path to the root for both placements. To speed this up, we instead use a distance matrix that is calculated in the beginning of any algorithm using this method and contains the pairwise distances between all nodes of the tree. Using this, we do not need to find paths between placements, but simply go to the nodes at the end of the branches of the placements and do a lookup for those nodes.With this technique, we can calculate the distances between the placements for all three cases (promixal-promixal, proximal-distal and distal-proximal) cheaply. The wanted distance is then simply the minimum of those three distances. This is correct, because the two wrong cases will always produce an overestimation of the distance.This distance is normalized using the like_weight_ratio of both placements, before summing it up to calculate the total distance between the pqueries.The Matrix node_distances has to come from tree::node_branch_length_distance_matrix()."},
    {"double ::genesis::placement::pquery_distance (Pquery const & pquery_a, Pquery const & pquery_b, DistanceFunction distance_function)", "Local helper function to avoid code duplication."},
    {"double ::genesis::placement::pquery_distance (Pquery const & pquery_a, Pquery const & pquery_b, utils::Matrix< double > const & node_distances, bool with_pendant_length=false)", "Calculate the weighted distance between two Pqueries, in branch length units, as the pairwise distance between their PqueryPlacements, and using the like_weight_ratio for weighing.\n\nThe Matrix node_distances has to come from tree::node_branch_length_distance_matrix()."},
    {"std::vector< PqueryPlacement const * > ::genesis::placement::placements_per_edge (Sample const & smp, PlacementTreeEdge const & edge)", "Return a vector of all PqueryPlacements that are placed on the given PlacementTreeEdge.\n\nThis functions iterates over all placements and collects those that are placed on the given edge. In case that this is needed for multiple edges, it is faster to use placements_per_edge( Sample ) instead.The result is invalidated when calling Pquery::add_placement() or other functions that change the number of Pqueries or PqueryPlacements in the Sample."},
    {"std::vector< std::vector< PqueryPlacement const * > > ::genesis::placement::placements_per_edge (Sample const & smp, bool only_max_lwr_placements=false)", "Return a mapping from each PlacementTreeEdges to the PqueryPlacements that are placed on that edge.\n\nThe result vector is indexed using PlacementTreeEdge::index(). For each entry, it contains another vector that holds pointers to the PqueryPlacements of the Sample.If the optional parameter only_max_lwr_placements is set to false (default), each placement in the Sample is added, not just the most likely ones. If set to true, only the PqueryPlacement with the highest like_weight_ratio is added.The result is invalidated when calling Pquery::add_placement() or other functions that change the number of Pqueries or PqueryPlacements in the Sample."},
    {"std::vector< PqueryPlain > ::genesis::placement::plain_queries (Sample const & smp)", "Return a plain representation of all pqueries of this map.\n\nThis method produces a whole copy of all pqueries and their placements (though, not their names) in a plain POD format. This format is meant for speeding up computations that need access to the data a lot - which would require several pointer indirections in the normal representation of the data.This comes of course at the cost of reduced flexibility, as all indices are fixed in the plain data structre: changing a value here will not have any effect on the original data or even on the values of the pqueries. Thus, most probably this will lead to corruption. Therefore, this data structure is meant for reading only."},
    {"std::vector< std::vector< Pquery const * > > ::genesis::placement::pqueries_per_edge (Sample const & sample, bool only_max_lwr_placements=false)", "Return a mapping from each edge to the Pqueries on that edge.\n\nIf only_max_lwr_placements is false (default), each PqueryPlacement of the Pqueries is counted. If true, only the most probable one is added to the map."},
    {"double ::genesis::placement::placement_distance (PqueryPlacement const & place_a, PqueryPlacement const & place_b, utils::Matrix< double > const & node_distances)", "Calculate the distance between two PqueryPlacements, using their positin on the tree::TreeEdges, measured in branch length units.\n\nThe Matrix node_distances has to come from tree::node_branch_length_distance_matrix()."},
    {"double ::genesis::placement::placement_distance (PqueryPlacement const & placement, tree::TreeNode const & node, utils::Matrix< double > const & node_distances)", "Calculate the distance in branch length units between a PqueryPlacement and a tree::TreeNode.\n\nThe Matrix node_distances has to come from tree::node_branch_length_distance_matrix()."},
    {"std::pair< PlacementTreeEdge const *, double > ::genesis::placement::placement_mass_max_edge (Sample const & smp)", "Get the summed mass of the placements on the heaviest edge, measured by their like_weight_ratio, and a pointer to this edge."},
    {"std::vector< double > ::genesis::placement::placement_mass_per_edge_without_multiplicities (Sample const & sample)", "Return a vector that contains the sum of the masses of the PqueryPlacements per edge of the tree of the Sample.\n\nThe mass is measured in like_weight_ratio. The vector is indexed using the index of the edges.Note that this does not take multiplicities into account; that is, it simply gives the sum of all like_weight_ratios. See placement_mass_per_edges_with_multiplicities() for a version of this function that also takes the multiplicities  of the Pqueries into account."},
    {"utils::Matrix< double > ::genesis::placement::placement_mass_per_edge_without_multiplicities (SampleSet const & sample_set)", "Return a Matrix that contains the placement masses per edge.\n\nSee placement_mass_per_edge_without_multiplicities( Sample const& ) for details. The Matrix is simply a row-wise concatenation of this vector function."},
    {"std::vector< double > ::genesis::placement::placement_mass_per_edges_with_multiplicities (Sample const & sample)", "Return a vector that contains the sum of the masses of the PqueryPlacements per edge of the tree of the Sample, using the multiplicities  as factors."},
    {"utils::Matrix< double > ::genesis::placement::placement_mass_per_edges_with_multiplicities (SampleSet const & sample_set)", "Return a Matrix that contains the placement masses per edge, using the multiplicities  as factors.\n\nSee placement_mass_per_edges_with_multiplicities( Sample const& ) for details. The Matrix is simply a row-wise concatenation of this vector function."},
    {"size_t ::genesis::placement::placement_path_length_distance (PqueryPlacement const & place_a, PqueryPlacement const & place_b, utils::Matrix< size_t > const & node_path_lengths)", "brief Calculate the discrete distance between two PqueryPlacements, using their positin on the tree::TreeEdges, measured in number of nodes between the placement locations.That is, two PqueryPlacements on the same edge have a distance of zero, on neighbouring edges a distance of 1 (as there is one node in between), and so on.The Matrix node_path_lengths has to come from tree::node_path_length_matrix()."},
    {"size_t ::genesis::placement::placement_path_length_distance (PqueryPlacement const & placement, tree::TreeEdge const & edge, utils::Matrix< size_t > const & edge_path_lengths)", "Calculate the discrete distance from a PqueryPlacement to an edge, measured as the number of nodes between them.\n\nThe Matrix edge_path_lengths has to come from tree::edge_path_length_matrix()."},
    {"double ::genesis::placement::pquery_path_length_distance (Pquery const & pquery_a, Pquery const & pquery_b, utils::Matrix< size_t > const & node_path_lengths)", "Calculate the weighted discrete distance between two Pqueries, measured as the pairwise distance in number of nodes between between their PqueryPlacements, and using the like_weight_ratio for weighing.\n\nThe Matrix node_path_lengths has to come from tree::node_path_length_matrix()."},
    {"double ::genesis::placement::pquery_path_length_distance (Pquery const & pquery, tree::TreeEdge const & edge, utils::Matrix< size_t > const & edge_path_lengths)", "Calculate the weighted discrete distance between the PqueryPlacements of a Pquery and a tree::TreeNode, in number of nodes, using the like_weight_ratio of the PqueryPlacements for weighing.\n\nThe Matrix node_path_lengths has to come from tree::node_path_length_matrix().The Matrix node_path_lengths has to come from tree::node_path_length_matrix(). Calculate the weighted discrete distance between the PqueryPlacements of a Pquery and a tree::TreeEdge, in number of nodes between them, using the like_weight_ratio of the PqueryPlacements for weighing.The Matrix edge_path_lengths has to come from tree::edge_path_length_matrix()."},
    {"double ::genesis::placement::pquery_distance (Pquery const & pquery, DistanceFunction distance_function)", "Local helper function to avoid code duplication."},
    {"double ::genesis::placement::pquery_distance (Pquery const & pquery, tree::TreeNode const & node, utils::Matrix< double > const & node_distances)", "Calculate the weighted distance between the PqueryPlacements of a Pquery and a tree::TreeNode, in branch length units, using the like_weight_ratio of the PqueryPlacements for weighing.\n\nThe Matrix node_distances has to come from tree::node_branch_length_distance_matrix()."},
    {"std::string ::genesis::genesis_version ()", "Return the current genesis version.\n\nWe use semantic versioning 2.0.0 for genesis.Given a version number MAJOR.MINOR.PATCH, increment the:\nMAJOR version when you make incompatible API changes,MINOR version when you add functionality in a backwards-compatible manner, andPATCH version when you make backwards-compatible bug fixes.\nAdditional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format."},
    {"std::string ::genesis::genesis_version_name ()", "Return the current genenis version name.\n\nJust for fun."},
    {"size_t ::genesis::placement::total_name_count (Sample const & smp)", "Get the total number of PqueryNames in all Pqueries  of the given Sample."},
    {"size_t ::genesis::placement::total_placement_count (Sample const & smp)", "Get the total number of PqueryPlacements in all Pqueries  of the given Sample."},
    {"double ::genesis::placement::total_placement_mass_without_multiplicities (Sample const & smp)", "Get the summed mass of all PqueryPlacements in all Pqueries  of the given Sample, where mass is measured by the like_weight_ratios of the PqueryPlacements.\n\nBe aware that this function only gives the pure sum of the like_weight_ratios. See total_placement_mass_with_multiplicities() for a version of this function, which also takes the multiplicities  of the Pqueries into account."},
    {"double ::genesis::placement::total_placement_mass_with_multiplicities (Sample const & smp)", "Get the mass of all PqueryPlacements of the Sample, using the multiplicities  as factors.\n\nThis function returns the summed mass of all PqueryPlacements in all Pqueries  of the given Sample, where mass is measured by like_weight_ratio, and the mass of each Pquery is multiplied by the sum of the multiplicities  of this Pquery.This method returns the same value as total_placement_mass_without_multiplicities() in case that the multiplicity is left at its default value of 1.0 for all Pqueries."},
    {"size_t ::genesis::placement::total_pquery_count (SampleSet const & sample_set)", "Return the total number of Pqueries in the Samples of the SampleSet."},
    {"tree::TreeSet ::genesis::placement::tree_set (SampleSet const & sample_set)", "Return a TreeSet containing all the trees of the SampleSet."},
    {"double ::genesis::placement::total_multiplicity (Pquery const & pqry)", "Return the sum of all multiplicities  of the Pquery."},
    {"double ::genesis::placement::total_multiplicity (Sample const & sample)", "Return the sum of all multiplicities  of all the Pqueries of the Sample."},
    {"double ::genesis::placement::pairwise_distance (const Sample & smp_a, const Sample & smp_b, bool with_pendant_length=false)", "Calculate the normalized pairwise distance between all placements of the two Samples.\n\nThis method calculates the distance between two Samples as the normalized sum of the distances between all pairs of Pqueries  in the Sample. It is similar to the variance() calculation, which calculates this sum for the squared distances between all Pqueries of one Sample.\n\nsmp_a\n\n\nFirst Sample to which the distances shall be calculated to. \n\n\n\nsmp_b\n\n\nSecond Sample to which the distances shall be calculated to. \n\n\n\nwith_pendant_length\n\n\nWhether or not to include all pendant lengths in the calculation.\n\n\nDistance value."},
    {"std::vector< utils::Color > ::genesis::placement::placement_color_count_gradient (Sample const & smp, bool linear)", "Returns a vector with a Color for each edge that visualizes the number of placements on that edge.\n\nThe vector is indexed using the edge.index(). Each edge gets assigned a Color value with these properties:\nEdges with no placements on them are grey (RGB 0.5, 0.5, 0.5).Edges with placements get a color according to the relative number of placements compared to the other edges. The edge with most placements is pure red (RGB 255, 0, 0), while lower numbers of placements smoothly transition towards yellow and green edges.\nThe gradient can be controlled via the linear parameter. If set to true, the scaling of the color gradient is linar in the number of placements. If set to false (default), it is logarithmic. This way, the color resolution is higher for low placement numbers, and compressed for higher numbers. A typical distribution of placements yields only some edges with a very high number of placements, while most of the other edges have little to no placements. Thus, it is reasonable to emphasize the differences between those edges with a lower placement count - which is what the default does.See color heat_gradient() for more information."},
    {"std::pair< PlacementTreeEdge const *, size_t > ::genesis::placement::placement_count_max_edge (Sample const & smp)", "Get the number of placements on the edge with the most placements, and a pointer to this edge."},
    {"std::vector< size_t > ::genesis::placement::placement_count_per_edge (Sample const & sample)", "Return a vector that contains the number of PqueryPlacements per edge of the tree of the Sample.\n\nThe vector is indexed using the index of the edges."},
    {"void ::genesis::placement::normalize_weight_ratios (Sample & smp)", "Recalculate the like_weight_ratio of the PqueryPlacement&s of each Pquery in the Sample, so that their sum is 1.0, while maintaining their ratio to each other.\n\nThis function simply calls normalize_weight_ratios( Pquery& pquery ) for all Pqueries of the Sample."},
    {"void ::genesis::placement::normalize_weight_ratios (Pquery & pquery)", "Recalculate the like_weight_ratio of the PqueryPlacement&s of a Pquery, so that their sum is 1.0, while maintaining their ratio to each other."},
    {"double ::genesis::placement::variance (const Sample & smp, bool with_pendant_length=false)", "Calculate the variance of the placements on a tree.\n\nThe variance is a measure of how far a set of items is spread out in its space (http://en.wikipedia.org/wiki/variance). In many cases, it can be measured using the mean of the items. However, when considering placements on a tree, this does not truly measure how far they are from each other. Thus, this algorithm applies a different method of calculating the variance in terms of squared deviations of all items from each other: $ Var(X) = \\frac{1}{n^2} \\sum_{i=1}^n \\sum_{j=1}^n \\frac{1}{2}(x_i - x_j)^2 $, where $ (x_i - x_j) $ denotes the distance between two placements.According to the formula above, each pair of placements is evaluated twice, and subsequently their distance need to be halfed when being added to the sum of distanaces. Instead of that, we calculate the distance for each pair only once, thus are able skip half the calculations, and of course skip the division by two.Furthermore, the normalizing factor $ \\frac{1}{n^2} $ of the variance usually contains the number of elements being processed. However, as the placements are weighted by their like_weight_ratio, we instead calculate n as the sum of the like_weight_ratio of all placements. In case that for each pquery the ratios of all its placements sum up to 1.0, this number will be equal to the number of pqueries (and thus be equal to the usual case of using the number of elements). However, as this is not required (placements with small ratio can be dropped, so that their sum per pquery is less than 1.0), we cannout simply use the count."},
    {"double ::genesis::placement::variance_partial (const PqueryPlain & pqry_a, const std::vector< PqueryPlain > & pqrys_b, const utils::Matrix< double > & node_distances, bool with_pendant_length)", "Internal function that calculates the sum of distances contributed by one pquery for the variance. See variance() for more information.\n\nThis function is intended to be called by variance() or variance_thread()  it is not a stand-alone function."},
    {"void ::genesis::placement::variance_thread (const int offset, const int incr, const std::vector< PqueryPlain > * pqrys, const utils::Matrix< double > * node_distances, double * partial, bool with_pendant_length)", "Internal function that calculates the sum of distances for the variance that is contributed by a subset of the pqueries. See variance() for more information.\n\nThis function is intended to be called by variance()  it is not a stand-alone function. It takes an offset and an incrementation value and does an interleaved loop over the pqueries, similar to the sequential version for calculating the variance."},
    {"void ::genesis::placement::filter_n_max_weight_placements (Pquery & pquery, size_t n=1)", "Remove all PqueryPlacements but the n most likely ones from the Pquery.\n\nPqueries can contain multiple placements on different branches. For example, the EPA algorithm of RAxML outputs up to the 7 most likely positions for placements to the output Jplace file by default. The property like_weight_ratio weights those placement positions so that the sum over all positions (all branches of the tree) per pquery is 1.0.This function removes all but the n most likely placements (the ones which have the highest like_weight_ratio) from the Pquery. The like_weight_ratio of the remaining placements is not changed."},
    {"void ::genesis::placement::filter_min_weight_threshold (Sample & smp, double threshold)", "Remove all PqueryPlacements that have a like_weight_ratio below the given threshold from all Pqueries  of the Sample."},
    {"void ::genesis::placement::filter_n_max_weight_placements (Sample & smp, size_t n=1)", "Remove all PqueryPlacements but the n most likely ones from all Pqueries  in the Sample.\n\nThis function calls filter_n_max_weight_placements( Pquery& pquery, size_t n ) for all Pqueries of the Sample. See this version of the function for more information."},
    {"void ::genesis::placement::filter_pqueries_differing_names (Sample & sample_1, Sample & sample_2)", "Remove all Pqueries from the two Samples that have a name in common.\n\nThis function builds the intersection of the set of names of both Samples and removes all those Pqueries that have a PqueryName with one of those names.This is not quite the same as building the symmetric difference and keeping those elements, and, although similar, it not the opposite of filter_pqueries_intersecting_names(), because Pqueries can have multiple names."},
    {"void ::genesis::placement::filter_pqueries_intersecting_names (Sample & sample_1, Sample & sample_2)", "Remove all Pqueries from the two Samples except the ones that have names in common.\n\nThis function builds the intersection of the set of names of both Samples and only keeps those Pqueries that have a PqueryName with one of those names."},
    {"void ::genesis::placement::filter_pqueries_keeping_names (Sample & smp, std::unordered_set< std::string > keep_list)", "Remove all Pqueries which do not have at least one name that is in the given keep list.\n\nIf the Pquery has a PqueryName whose PqueryName::name value is in the keep_list, the Pquery is kept. If none of its names is in the keep_list, the Pquery is removed.This is similar to filter_pqueries_removing_names(), but not quite the opposite, as Pqueries can have multiple names."},
    {"void ::genesis::placement::filter_pqueries_keeping_names (Sample & smp, std::string const & regex)", "Remove all Pqueries which do not have at least one name that matches the given regex.\n\nIf the Pquery has a PqueryName whose PqueryName::name value matches the regex, the Pquery is kept. If none of its names matches, the Pquery is removed."},
    {"void ::genesis::placement::scale_all_branch_lengths (Sample & smp, double factor=1.0)", "Scale all branch lengths of the Tree and the position of the PqueryPlacements by a given factor.\n\nThis function calls tree::scale_all_branch_lengths() for scaling the tree, and also applies the same scaling to the PqueryPlacement::proximal_length."},
    {"void ::genesis::placement::set_depths_distributed_weights (Sample const & sample, std::vector< double > const & depth_weights, SimulatorEdgeDistribution & edge_distrib)", "Set the weights so that they follow a given depth distribution of the edges in the PlacementTree.\n\nThe depth_weights vector provides weights for each level of depth for an edge in the tree. This means, each edge which is adjacent to a leaf node (speak: it has depth 0) will use the weight at position 0; edges which are one level deeper in the tree will get the weight at position 1, and so on.This method can conveniently be used with the output of closest_leaf_weight_distribution() called on some exemplary Sample. This way, it will mimic this sample in terms of the depths distribution of the placements: E.g., if the original sample (the one where the histrogram results were taken from and used as input for this method) has many placements near the leaves, so will the simulated one. See set_depths_distributed_weights( Sample const& sample, SimulatorEdgeDistribution& edge_distrib ) for a version of this function which does exaclty that."},
    {"void ::genesis::placement::set_depths_distributed_weights (Sample const & sample, SimulatorEdgeDistribution & edge_distrib)", "Set the weights of an SimulatorEdgeDistribution so that they follow the depth distribution of the edges in the provided Sample.\n\nThis function is similar to set_depths_distributed_weights( Sample const& sample, std::vector<int> const& depth_weights, SimulatorEdgeDistribution& edge_distrib ), but instead of using a given depth_weight vector, this vector is also estimated from the given Sample. This is done by using closest_leaf_weight_distribution(), which counts the number of placements at a given depth in the tree."},
    {"void ::genesis::placement::set_random_edges (Sample const & sample, SimulatorEdgeDistribution & edge_distrib)", "Set the weights of a SimulatorEdgeDistribution randomly to either 0.0 or 1.0, so that a random subset of edges is selected (with the same probability for each selected edge).\n\nThe number of edges is taken from the provided Sample."},
    {"void ::genesis::placement::reset_edge_nums (PlacementTree & tree)", "Reset all edge nums of a PlacementTree.\n\nThe edge_num property of the PlacementTreeEdges is defined by the jplace standard. The values have to be assigned increasingly with a postorder traversal of the tree. This function resets them so that this is established.See has_correct_edge_nums() to check whether the edge nums are already correct. This should be the case for any valid jplace file."},
    {"void ::genesis::placement::set_random_edges (size_t edge_count, SimulatorEdgeDistribution & edge_distrib)", "Set the weights of an SimulatorEdgeDistribution randomly to either 0.0 or 1.0, so that a random subset of edges is selected (with the same probability for each selected edge)."},
    {"size_t ::genesis::placement::set_random_subtree_weights (Sample const & sample, SimulatorEdgeDistribution & edge_distrib)", "Sets the weights of an SimulatorEdgeDistribution to 1.0 for a randomly chosen subtree, all others to 0.0.\n\nReturns the index of the chosen edge."},
    {"void ::genesis::placement::set_random_weights (Sample const & sample, SimulatorEdgeDistribution & edge_distrib)", "Set the weights of an SimulatorEdgeDistribution for the edges randomly to a value between 0.0 and 1.0.\n\nThe number of edges is taken from the provided Sample."},
    {"void ::genesis::placement::set_random_weights (size_t edge_count, SimulatorEdgeDistribution & edge_distrib)", "Set the weights of an SimulatorEdgeDistribution for the edges randomly to a value between 0.0 and 1.0."},
    {"void ::genesis::placement::set_uniform_weights (Sample const & sample, SimulatorEdgeDistribution & edge_distrib)", "Sets the weights of an SimulatorEdgeDistribution to 1.0 for all edges, so that each edge has the same probability of being chosen.\n\nThe number of edges is taken from the provided Sample."},
    {"void ::genesis::placement::set_subtree_weights (Sample const & sample, size_t link_index, SimulatorEdgeDistribution & edge_distrib)", "Set the weights of a subtree to 1.0 and all other weights to 0.0.\n\nThe subtree is selected via the index of the link that leads away from it. As leaf nodes do not count as subtrees, the link has to belong to an inner node."},
    {"void ::genesis::placement::set_uniform_weights (size_t edge_count, SimulatorEdgeDistribution & edge_distrib)", "Sets the weights of an SimulatorEdgeDistribution to 1.0 for all edges, so that each edge has the same probability of being chosen."},
    {"void ::genesis::placement::sort_placements_by_weight (Pquery & pquery)", "Sort the PqueryPlacements of a Pquery by their like_weight_ratio, in descending order (most likely first)."},
    {"void ::genesis::placement::sort_placements_by_weight (Sample & smp)", "Sort the PqueryPlacements of all Pqueries  by their like_weight_ratio, in descending order (most likely first)."},
    {"double ::genesis::placement::add_sample_to_mass_tree (Sample const & smp, double const sign, double const scaler, tree::MassTree & target)", "Helper function to copy masses from a Sample to a MassTree.\n\nThe function copies the masses from a Sample to a MassTree. It returns the amount of work needed to move the masses from their pendant position to the branch (this result is only used if with_pendant_length is true in the calculation functions)."},
    {"double ::genesis::placement::node_histogram_distance (NodeDistanceHistogramSet const & lhs, NodeDistanceHistogramSet const & rhs)", "Given the histogram sets that describe two Samples, calculate their distance."},
    {"utils::Matrix< double > ::genesis::placement::node_histogram_distance (SampleSet const & sample_set, size_t const histogram_bins=25)", "Calculate the Node Histogram Distance of every pair of Samples in the SampleSet.\n\nThis is a high level convenience function that takes a whole SampleSet, calculates the necessary matrices, builds the histograms, and calculates their distances."},
    {"double ::genesis::placement::node_histogram_distance (Sample const & sample_a, Sample const & sample_b, size_t const histogram_bins=25)", "Calculate the Node Histogram Distance of two Samples.\n\nThe necessary matrices of the Samples are calculated, then their NodeDistanceHistogramSet are build, and finally the distance is calcualted. Basically, this is a high level function that simply chains node_distance_histogram_set() and node_histogram_distance() for convenience."},
    {"utils::Matrix< double > ::genesis::placement::node_histogram_distance (std::vector< NodeDistanceHistogramSet > const & histogram_sets)", "Given the histogram sets that describe a set of Samples, calculate their pairwise distance matrix."},
    {"NodeDistanceHistogramSet ::genesis::placement::node_distance_histogram_set (Sample const & sample, utils::Matrix< double > const & node_distances, utils::Matrix< signed char > const & node_sides, size_t const histogram_bins)", "Calcualte the NodeDistanceHistogramSet representing a single Sample, given the necessary matrices of this Sample.\n\nThis is a basic function that is mainly used for speedup in applications. The two matrices only depend on the tree, but not on the placement data, so for a set of Samples with the same tree, they only need to be calculated once."},
    {"std::vector< NodeDistanceHistogramSet > ::genesis::placement::node_distance_histogram_set (SampleSet const & sample_set, size_t const histogram_bins)", "Local helper function that calculates all Histograms for all Samples in a SampleSet."},
    {"void ::genesis::placement::adjust_branch_lengths (SampleSet & sample_set, tree::Tree const & source)", "Take the branch lengths of the source Tree and use them as the new branch lengths of the Samples in the sample_set.\n\nThis function simply calls adjust_branch_lengths( Sample&, tree::Tree const& ) for all Samples in the set. See there for details.All involved Trees need to have identical topology. This is not checked."},
    {"void ::genesis::placement::adjust_to_average_branch_lengths (SampleSet & sample_set)", "Set the branch lengths of all Samples in the sample_set to the respecitve average branch length of the Samples.\n\nThat is, for each edge of the tree, find the average branch length over all Samples, and use this for the Samples. This means, all Samples in the SampleSet need to have identical tree topologies."},
    {"void ::genesis::placement::adjust_branch_lengths (Sample & sample, tree::Tree const & source)", "Take the branch lengths of the source Tree and use them as the new branch lengths of the sample.\n\nThe proximal_lengths of the PqueryPlacements are adjusted accordingly, so that their relative position on the branch stays the same.The source Tree is expected to have edges with data type tree::CommonEdgeData.The topology of the source and the tree of the Sample have to be identical. This is however not checked, so the user has to provide a fitting tree."},
    {"tree::Tree ::genesis::placement::average_branch_length_tree (SampleSet const & sample_set)", "Return the Tree that has edges with the average branch length of the respective edges of the Trees in the Samples of the given SampleSet."},
    {"std::unordered_set< std::string > ::genesis::placement::all_pquery_names (Sample const & sample)", "Return a set of all unique PqueryNames of the Pqueries  of the given sample.\n\nIf a Pquery contains multiple names, all of them are added to the set."},
    {"bool ::genesis::placement::all_identical_trees (SampleSet const & sample_set)", "Returns true iff all Trees of the Samples in the set are identical.\n\nThis is the case if they have the same topology, node names and edge_nums. However, branch lengths are not checked, because usually those differ slightly."},
    {"std::pair< PlacementTreeEdge const *, double > ::genesis::placement::center_of_gravity (Sample const & smp, bool const with_pendant_length=false)", "Calculate the Center of Gravity of the placements on a tree.\n\nThe center of gravity is the point on the tree where all masses of the placements on the one side of it times their distance from the point are equal to this sum on the other side of the point. In the following example, the hat ^ marks this point on a line with two placements: One has mass 1 and distance 3 from the central point, and one as mass 3 and distance 1, so that the product of their mass and distance to the point is the same:               3\n              |\n1             |\n|_____________|\n          ^\nIt is thus like calculating masses and torques on a lever in order to find their physical center of mass/gravity.This calculation is done for the whole tree, with the masses calculated from the like_weight_ratio and distances in terms of the branch_length of the edges and the proximal_length and (if specificed in the method parameter) the pendant_length of the placements."},
    {"void ::genesis::placement::learn_per_edge_weights (Sample const & sample, SimulatorEdgeDistribution & edge_distrib)", "Sets the weights of an SimulatorEdgeDistributionso that they follow the same distribution of placement weight per edge as a given Sample.\n\nThis method \"learns\" how the placements on the given Sample are distributed by summing up their weight per edge and using this as weights. This way, the given distribution can be imitated by randomly generated placements.The method is intended to be used on a Tree that has the same topology as the one that is given with the Sample, otherwise the Edge indices will not fit."},
    {"std::string ::genesis::placement::print_tree (Sample const & smp)", "Return a simple view of the Tree of a Sample with information about the Pqueries  on it."},
    {"void ::genesis::placement::rectify_values (Sample & sample)", "Correct invalid values of the PqueryPlacements and PqueryNames as good as possible.\n\nSome values can be slightly outside their valid boundaries, either for numerical reasons, or because something went wrong. Often, those can be rectified without too much loss of information.This function\nsets negative like_weight_ratio to 0.0sets like_weight_ratio > 1.0 to 1.0normalizes the like_weight_ratio if their sum is > 1.0sets negative pendant_length to 0.0sets negative proximal_length to 0.0sets proximal_length > branch_length to branch_length for its edge.sets negative multiplicity to 0.0 for the name\nSee rectify_values( SampleSet& ) for a version of this function that works on whole SampleSets."},
    {"void ::genesis::placement::rectify_values (SampleSet & sset)", "Correct invalid values of the PqueryPlacements and PqueryNames as good as possible.\n\nThis function calls rectify_values( Sample& ) for all Samples in the SampleSet. See there for details."},
    {"size_t ::genesis::placement::remove_empty_pqueries (Sample & sample)", "Remove all Pqueries from the Sample that have no PqueryPlacements.\n\nThis is useful for example after filtering, as this can result in removing all PqueryPlacements from a Pquery.The function returns the number of removed Pqueries."},
    {"void ::genesis::placement::merge_duplicate_placements (Pquery & pquery)", "Merge all PqueryPlacements of a Pquery that are on the same TreeEdge into one averaged PqueryPlacement.\n\nThe merging is done via averaging all values of the PqueryPlacement: likelihood, like_weight_ratio, proximal_length, pendant_length and parsimony."},
    {"void ::genesis::placement::merge_duplicate_names (Sample & smp)", "Call merge_duplicate_names() for each Pquery of the Sample."},
    {"void ::genesis::placement::merge_duplicates (Sample & smp)", "Look for Pqueries  with the same name and merge them.\n\nThis function is a wrapper that simply calls three other functions on the provided Sample: * collect_duplicate_pqueries()\n* merge_duplicate_names()\n* merge_duplicate_placements()\nSee there for more information on what they do."},
    {"void ::genesis::placement::merge_duplicate_placements (Sample & smp)", "Call merge_duplicate_placements( Pquery& ) for each Pquery of a Sample."},
    {"void ::genesis::placement::merge_duplicate_names (Pquery & pquery)", "Merge all PqueryNames that have the same name property into one, while adding up their multiplicity."},
    {"NodeDistanceHistogramSet ::genesis::placement::make_empty_node_distance_histogram_set (tree::Tree const & tree, utils::Matrix< double > const & node_distances, utils::Matrix< signed char > const & node_sides, size_t const histogram_bins)", "Create a set of Histograms without any weights for a given Tree."},
    {"Sample ::genesis::placement::merge_all (SampleSet const & sample_set)", "Returns a Sample where all Samples of a SampleSet have been merged into.\n\nFor this method to succeed, all Samples need to have the same topology, including identical edge_nums and node names. The Tree of the returned Sample has the average branch lenghts from the input trees, using TreeSet::average_branch_length_tree()."},
    {"std::string ::genesis::genesis_url ()", "Return the URL of the genesis home page."},
    {"std::vector< int > ::genesis::placement::closest_leaf_depth_histogram (Sample const & smp)", "Return a histogram representing how many placements have which depth with respect to their closest leaf node.\n\nThe depth between two nodes on a tree is the number of edges between them. Thus, the depth of a placement (which sits on an edge of the tree) to a specific node is the number of edges between this node and the closer one of the two nodes at the end of the edge where the placement sits.The closest leaf to a placement is thus the leaf node which has the smallest depth to that placement. This function then returns a histogram of how many placements (values of the vector) are there that have a specific depth (indices of the vector) to their closest leaf.Example: A return vector of histogram[0] = 2334\nhistogram[1] = 349\nhistogram[2] = 65\nhistogram[3] = 17\nmeans that there are 2334 placements that sit on an edge which leads to a leaf node (thus, the depth of one of the nodes of the edge is 0). It has 349 placements that sit on an edge where one of its nodes has one neighbour that is a leaf; and so on.The vector is automatically resized to the needed number of elements."},
    {"std::vector< int > ::genesis::placement::closest_leaf_distance_histogram (Sample const & smp, const double min, const double max, const int bins=10)", "Returns a histogram counting the number of placements that have a certain distance to their closest leaf node, divided into equally large intervals between a min and a max distance.\n\nThe distance range between min and max is divided into bins many intervals of equal size. Then, the distance from each placement to its closest leaf node is calculated and the counter for this particular distance inverval in the histogram is incremented.The distance is measured along the branch_length values of the edges, taking the pendant_length and proximal_length of the placements into account. If the distances is outside of the interval [min,max], the counter of the first/last bin is incremented respectively.Example: double min      =  0.0;\ndouble max      = 20.0;\nint    bins     = 25;\ndouble bin_size = (max - min) / bins;\nstd::vector<int> hist = closest_leaf_distance_histogram (min, max, bins);\nfor (unsigned int bin = 0; bin < hist.size(); ++bin) {\n    LOG_INFO << \"Bin \" << bin << \" [\" << bin * bin_size << \"; \"\n             << (bin+1) * bin_size << \") has \" << hist[bin] << \" placements.\";\n}"},
    {"double ::genesis::placement::center_of_gravity_variance (Sample const & smp, bool const with_pendant_length=false)", "Calcualte the variance of the PqueryPlacements of a Sample around its Center of Gravity.\n\nThe caluclation of the variance is as follows:$ Var(X) = E[ (x - \\mu)^2 ] = \\frac{\\sum (x - \\mu)^2 \\cdot \\omega} {\\sum \\omega} $, where the weights $ \\omega $ are the like_weight_ratios of the placements.See center_of_gravity() for more."},
    {"double ::genesis::placement::center_of_gravity_distance (Sample const & smp_a, Sample const & smp_b, bool const with_pendant_length=false)", "Calculate the distance between the two Centers of Gravity of two Samples.\n\nThe distance is measured in branch length units; for the Center of Gravity, see center_of_gravity()."},
    {"tree::Tree ::genesis::placement::labelled_tree (Sample const & sample, bool fully_resolve=false, std::string const & name_prefix=\"\")", "Produce a Tree where the most probable PqueryPlacement of each Pquery in a Sample is turned into an Edge.\n\nThe function takes the original Tree of the Sample, and for each Pquery of the Sample, it attaches a new leaf Node to it. The new leaf represents the most probable PqueryPlacement of the Pquery, measured using the like_weight_ratio. The leaf is positioned according to the proximal_length and pendant_length of the PqueryPlacement. The resulting Tree is useful to get an overview of the distribution of placements. It is mainly intended to view a few placements. For large Samples, it might be a bit cluttered.Similar trees are produced by RAxML EPA, where the file is called RAxML_labelledTree, and by the pplacer guppy `tog` command. Both programs differ in the exact way the the placements are added as edges. To control this behaviour, use the fully_resolve parameter.Parameter fully_resolve == falseIf fully_resolve is set to false (default), all placements at one edge are collected as children of one central base edge:\nThis method is similar to the way RAxML produces a labelled tree.The base edge is positioned on the original edge at the average proximal_length of the placements. The base edge has a multifurcation if there are more than two placements on the edge.The pendant_length of the placements is used to calculate the branch_length of the new placement edges. This calculation subtracts the shortest pendant_length of the placements on the edge, so that the base edge is maximally \"moved\" towards the placement edges. This also implies that at least one of the placement edges has branch_length == 0.0. Furthermore, the placements are sorted by their pendant_length.Using this method, the new nodes of the resulting tree are easier to distinguish and collapse, as all placements are collected under the base edge. However, this comes at the cost of losing the detailled information of the proximal_length of the placements. If you want to keep this information, use fully_resolve == true instead.Parameter fully_resolve == trueIf fully_resolve is set to true, the placements are turned into single leaf nodes:\nThis method is similar to the way guppy tog produces a labelled tree.The original edge is splitted into separate parts where each placement edge is attached. The branch_lengths between those parts are calculated using the proximal_length of the placements, while the branch_lengths of the placement edges use their pendant_length.Using this method gives maximum information, but results in a more crowded tree. The new placement edges are \"sorted\" along the original edge by their proximal_length. For this reason in the example image above, \"Query 2\" is closer to \"Node A\" then \"Query 1\": it has a higher proximal_length. This information was lost in the multifurcating tree from above.Further DetailsFor edges that contain only a single placement, both versions of fully_resolve behave the same. In this case, the placement is simply attached using its proximal_length and pendant_length.Pqueries with multiple PqueryNames are treated as if each name is a separate placement, i.e., for each of them, a new (identical) edge is added to the Tree. If using fully_resolve == true, this results in a branch_length of 0.0 between the nodes of those placements.\n\nsample\n\n\nInput Sample to get the Tree and PqueryPlacements from. \n\n\n\nfully_resolve\n\n\nControl in which way multiple placements at one edge are turned into new edges. See above for details. \n\n\n\nname_prefix\n\n\nSpecify a prefix to be added to all new leaf Nodes (the ones that represent Placements). This is useful if a PqueryName also occurs as a name in the original tree. By default, empty. In order to get the same naming as labelled trees as produced by RAxML, use QUERY___.\n\n\nA CommonTree, i.e., a tree with node names and branch lengths."},
    {"PlacementTree ::genesis::placement::convert_common_tree_to_placement_tree (tree::CommonTree const & source_tree)", "Convert a CommonTree  into a PlacementTree.\n\nThis function returns a new tree with the same topology as the source tree, and the same node names and branch lengths. In addition, the edge_num property of the PlacementTree is established, as it is not part of the CommonTree data."},
    {"std::pair< std::vector< tree::MassTree >, std::vector< double >> ::genesis::placement::convert_sample_set_to_mass_trees (SampleSet const & sample_set)", "Convert all Samples in a SampleSet to tree::MassTrees."},
    {"std::pair< tree::MassTree, double > ::genesis::placement::convert_sample_to_mass_tree (Sample const & sample)", "Convert a Sample to a tree::MassTree.\n\nThe function takes all PqueryPlacements of the Sample and adds their masses in form of the like_weight_ratio as mass points on a tree::MassTree."},
    {"double ::genesis::placement::earth_movers_distance (Sample const & lhs, Sample const & rhs, double const p=1.0, bool const with_pendant_length=false)", "Calculate the earth mover's distance between two Samples.\n\nThis function interprets the like_weight_ratios of the PqueryPlacements as masses distributed along the branches of a tree. It then calculates the earth mover's distance between those masses for the distrubitons induced by the two given Samples.In order to do so, first, a tree with the average branch lengths of the two PlacementTrees is calculated. This is because of numerical issues that might yield different branch lengths. This necessiates that the trees have the same topology. If not, an std::runtime_error is thrown. The masses are then distributed on this tree, using the same relative position on their branches that they had in their original trees.The calculation furthermore takes the multiplicities of the Pqueries into account. That means, pqueries with higher (total) multiplicity have a higher influence on the calculated distance.As the two Samples might have a different total number of Pqueries, the masses of the Samples are first normalized to 1.0, using all the like_weight_ratios and multiplicities of the Pqueries. As a consequence, the resulting distance will not reflect the total number of Pqueries, but only their relative (normalized) distrubution on the tree.Furthermore, the parameter p is used to control the influence of mass and distance, with 0.0 < p < inf, and default p == 1.0, which is the neutral case. A larger p increases the impact of distance traveled, while a smaller p emphasizes differences of mass.See earth_movers_distance( MassTree const&, MassTree const& ) for more information on the actual distance calculation and details on the parameter p."},
    {"void ::genesis::placement::copy_pqueries (Sample const & source, Sample & target)", "Copy all Pqueries  from the source Sample (left parameter) to the target Sample (right parameter).\n\nFor this method to succeed, the PlacementTrees of the Samples need to have the same topology, including identical edge_nums and node names. Otherwise, this function throws an std::runtime_error.The PlacementTree of the target Sample is not modified. If the average branch length tree is needed instead, see SampleSet::merge_all()."},
    {"bool ::genesis::placement::compatible_trees (Sample const & lhs, Sample const & rhs)", "Return whether the PlacementTrees of two Samples are compatible.\n\nSee this version  of the function for details."},
    {"void ::genesis::placement::collect_duplicate_pqueries (Sample & smp)", "Find all Pqueries  that share a common name and combine them into a single Pquery containing all their collective PqueryPlacements and PqueryNames.\n\nThe function collects all Pqueries that share at least one name. This is transitive, so that for example three Pqueries with two names each like (a,b) (b,c) (c,d) will be combined into one Pquery. Thus, the transitive closure of shared names is collected.All those Pqueries with shared names are combined by simply moving all their Placements and Names into one Pquery and deleting the others. This means that at least the shared names will be doubled after this function. Also, Placements on the same edge can occur. Thus, usually merge_duplicate_names() and merge_duplicate_placements() are called after this function. The function merge_duplicates() does exaclty this, for convenience."},
    {"bool ::genesis::placement::compatible_trees (PlacementTree const & lhs, PlacementTree const & rhs)", "Return whether two PlacementTrees are compatible.\n\nThis is the case iff:\nthey have the same topology,they have the same internal structure (e.g., node indices),they have the same node names at corresponding nodes,they have the same edge nums at corresponding edges,the data types of all nodes and edges are those of a PlacementTree\nIn all other cases, false is returned."},
    {"utils::Matrix< double > ::genesis::placement::earth_movers_distance (SampleSet const & sample_set, double const p=1.0, bool const with_pendant_length=false)", "Calculate the pairwise Earth Movers Distance for all Samples in a SampleSet.\n\nThe result is a pairwise distance Matrix using the indices of the Samples in the SampleSet. See earth_movers_distance( Sample const&, Sample const&, ... ) for details on this distance measure on Samples, and see earth_movers_distance( MassTree const&, MassTree const& ) for more information on the actual distance calculation, and the parameter p."},
    {"double ::genesis::placement::edpl (Pquery const & pquery, utils::Matrix< double > const & node_distances)", "Calculate the EDPL uncertainty values for a Pquery.\n\nThis is the function that does the actual computation. It is used by the other edpl functions, which first calculate the node_distances matrix before calling this function. It is useful to separate these steps in order to avoid duplicate work when calculating the edpl for many Pqueries at a time.node_distances has to be the result of node_branch_length_distance_matrix()."},
    {"std::unordered_map< int, PlacementTreeEdge * > ::genesis::placement::edge_num_to_edge_map (PlacementTree const & tree)", "Return a mapping of edge_num integers to the corresponding PlacementTreeEdge object.\n\nIn a valid jplace file, the edge_nums are in increasing order with a postorder traversal of the tree. However, as Genesis does not need this constraint, we return a map here instead."},
    {"std::vector< double > ::genesis::placement::edpl (Sample const & sample, utils::Matrix< double > const & node_distances)", "Calculate the edpl() for all Pqueries in the Sample.\n\nnode_distances has to be the result of node_branch_length_distance_matrix()."},
    {"std::vector< double > ::genesis::placement::edpl (Sample const & sample)", "Calculate the edpl() for all Pqueries in the Sample.\n\nSee http://matsen.github.io/pplacer/generated_rst/guppy_edpl.html for more information."},
    {"std::unordered_map< int, PlacementTreeEdge * > ::genesis::placement::edge_num_to_edge_map (Sample const & smp)", "Return a mapping of edge_num integers to the corresponding PlacementTreeEdge object.\n\nThis function depends on the tree only and does not involve any pqueries. Thus, it forwards to edge_num_to_edge_map( PlacementTree const& ). See there for details."},
    {"double ::genesis::placement::edpl (Sample const & sample, Pquery const & pquery)", "Calculate the EDPL uncertainty values for a Pquery.\n\nSee http://matsen.github.io/pplacer/generated_rst/guppy_edpl.html for more information.This function expects a Pquery and the Sample it belongs to. This is necessary in order to get the Tree of the Sample and calculate distances between its Nodes."},
    {"EpcaData ::genesis::placement::epca (SampleSet const & samples, double kappa=1.0, double epsilon=1e-5, size_t components=0)", "Perform EdgePCA on a SampleSet.\n\nThe parameters kappa and epsilon are as described in epca_splitify_transform() and epca_filter_constant_columns(), respectively.The result is returned as a struct similar to the one used by utils::pca(), but containing an additional vector of the edge indices that the rows of the eigenvectors Matrix correspond to. This is necessary for back-mapping the eigenvectors onto the edges of the tree."},
    {"std::string ::genesis::genesis_header ()", "Return the header for genesis.\n\nThis is simply a text version of the logo, including the current version. It can for example be displayed at the start of a program to indicate that this program uses genesis."},
    {"std::string ::genesis::genesis_license ()", "Return the genesis license boilerplate information.\n\nThis function is useful for programs with terminal interaction. In such cases, you should include a command to show this license information."},
    {"std::vector< int > ::genesis::placement::closest_leaf_distance_histogram_auto (Sample const & smp, double & min, double & max, const int bins=10)", "Returns the same type of histogram as closest_leaf_distance_histogram(), but automatically determines the needed boundaries.\n\nSee closest_leaf_distance_histogram() for general information about what this function does. The difference between both functions is that this one first procresses all distances from placements to their closest leaf nodes to find out what the shortest and longest are, then sets the boundaries of the histogram accordingly. The number of bins is then used to divide this range into intervals of equal size.The boundaries are returned by passing two doubles min and max to the function by reference. The value of max will actually contain the result of std::nextafter() called on the longest distance; this makes sure that the value itself will be placed in the interval.Example: double min, max;\nint    bins = 25;\nstd::vector<int> hist = closest_leaf_distance_histogram (min, max, bins);\ndouble bin_size = (max - min) / bins;\nLOG_INFO << \"Histogram boundaries: [\" << min << \",\" << max << \").\";\nfor (unsigned int bin = 0; bin < hist.size(); ++bin) {\n    LOG_INFO << \"Bin \" << bin << \" [\" << bin * bin_size << \"; \"\n             << (bin+1) * bin_size << \") has \" << hist[bin] << \" placements.\";\n}\nIt has a slightly higher time and memory consumption than the non-automatic version closest_leaf_distance_histogram(), as it needs to process the values twice in order to find their min and max."},
    {"tree::Tree ::genesis::placement::labelled_tree (Sample const & sample, tree::Tree const & tree, bool fully_resolve=false, std::string const & name_prefix=\"\")", "Produce a Tree where each PqueryPlacement of a Sample is turned into an Edge.\n\nThis function is an extension of labelled_tree( Sample const&, bool, std::string const& ) that takes a custom Tree instead of using the one of the Sample. This allows to produce a labelled Tree that can contain other data at its Nodes and Edges. This Tree has to be topologically identical to the Sample Tree.Furthermore, the data of the provided Tree needs to derived from CommonNodeData and CommonEdgeData. This data is then copied to the resulting Tree. The edge data of edges where new placement edges are added is kept that the topmost edge, i.e., the one that is closest to the root."},
};

const char* get_docstring (const std::string& signature)
{
    if (doc_strings_.count(signature) > 0) {
        return doc_strings_[signature].c_str();
    } else {
        return "";
    }
}
